<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>官方QQ群机器人开发环境搭建(使用webhook方式)</title>
    <link href="/2025/06/17/%E5%AE%98%E6%96%B9QQ%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%BD%BF%E7%94%A8webhook%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/06/17/%E5%AE%98%E6%96%B9QQ%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%BD%BF%E7%94%A8webhook%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="使用webhook方式搭建QQ群机器人"><a href="#使用webhook方式搭建QQ群机器人" class="headerlink" title="使用webhook方式搭建QQ群机器人"></a>使用webhook方式搭建QQ群机器人</h1><p>最近突然想开发一个 QQ 群机器人，于是就去找了相关资料，发现有 <code>websocket</code> 和 <code>webhook</code> 两种方式，但是 <code>websocket</code> 方式将慢慢弃用转向 <code>webhook</code> 方式<br>既然都弃用了，那肯定要选新的方式了，于是就尝试使用 <code>webhook</code> 方式来搭建一个 QQ 群机器人<br>这篇文章用于记录机器人的开发环境搭建</p><span id="more"></span><h1 id="创建机器人"><a href="#创建机器人" class="headerlink" title="创建机器人"></a>创建机器人</h1><p>首先根据<a href="https://bot.q.qq.com/wiki/">文档</a>的描述，注册一个账号，然后在<a href="https://q.qq.com/">QQ开放平台</a>创建一个机器人<br>机器人创建好之后，找一个自己是群主或者管理员的少于20个人的群，在沙箱配置中设置该群，然后在 QQ 群中将机器人加入群聊<br><img src="/img/2025-06-17-1.png"><br>创建机器人之后，在开发管理中查看机器人的 <code>AppID</code>  和 <code>Token</code>，并生成 <code>AppSecret</code>，记好备用<br><img src="/img/2025-06-17-2.png"></p><h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>为了搭建官方 QQ 群机器人，需要一个经过 ICP 备案的域名，并将这个域名指向一台国内的服务器<br>域名指向服务器后，需要申请 SSL 证书，如果是国内的提供商，一般有免费的 SSL 证书可以直接申请，也可以使用 <a href="https://github.com/acmesh-official/acme.sh">acme</a> 申请证书<br>申请 SSL 证书后，将证书上传到服务器以备后续使用</p><h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><p>机器人框架我使用的是 <a href="https://nonebot.dev/">NoneBot</a>，需要 Python3.9 以上的版本，Ubuntu 可以直接安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install python3.9 python3.9-venv python3.9-dev<br></code></pre></td></tr></table></figure><p>然后创建一个虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> QQ_BOT<br><span class="hljs-built_in">cd</span> QQ_BOT<br>python3.9 -m venv .venv<br><br><span class="hljs-built_in">source</span> .venv/bin/activate<br>pip install pipx<br>pipx install nb-cli<br></code></pre></td></tr></table></figure><p>按照文档安装 nonebot2 以及驱动器，为了使用 webhook 方式，需要安装 fastapi 和 httpx 这两个驱动器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nb driver install nonebot2[fastapi]<br>nb driver install nonebot2[httpx]<br></code></pre></td></tr></table></figure><p>再安装适配器，这里使用的官方 QQ 的适配器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nb adapter install nonebot-adapter-qq<br></code></pre></td></tr></table></figure><h1 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h1><p>官方 QQ 群机器人必须使用 <code>HTTPS</code>，所以需要安装 nginx 来配置反向代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install nginx<br></code></pre></td></tr></table></figure><p>创建配置文件 <code>/etc/nginx/sites-available/域名.conf</code>，并编辑如下配置，其中的域名请替换为自己的域名，自定义端口可以随意设置，只要与后面的机器人配置的端口一致即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs conf">server &#123;<br>    listen 80;<br>    server_name 域名;<br>    return 301 https://$host$request_uri;  # 强制HTTP跳转到HTTPS<br>&#125;<br><br>server &#123;<br>    listen 443 ssl http2;<br>    server_name 域名;<br><br>    # SSL证书路径<br>    ssl_certificate /path/to/your/domain.crt;<br>    ssl_certificate_key /path/to/your/domain.key;<br><br>    # SSL协议和加密套件<br>    ssl_protocols TLSv1.2 TLSv1.3;<br>    ssl_ciphers &#x27;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256&#x27;;<br>    ssl_prefer_server_ciphers on;<br><br>    # 反向代理配置<br>    location /qq/webhook &#123;<br>        proxy_pass http://127.0.0.1:自定义端口/qq/webhook;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_set_header X-Forwarded-Proto $scheme;<br>        proxy_http_version 1.1;<br>        proxy_set_header Upgrade $http_upgrade;<br>        proxy_set_header Connection &quot;upgrade&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>保存并退出后，使用命令链接配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -sf /etc/nginx/sites-available/域名.conf /etc/nginx/sites-enabled/<br></code></pre></td></tr></table></figure><p>测试配置文件是否正确，并重载 nginx 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> nginx -t<br><span class="hljs-built_in">sudo</span> systemctl reload nginx<br></code></pre></td></tr></table></figure><h1 id="配置机器人"><a href="#配置机器人" class="headerlink" title="配置机器人"></a>配置机器人</h1><p>在 <code>QQ_BOT</code> 目录下创建一个 <code>.env</code> 文件，并编辑如下内容，其中的 <code>id</code> , <code>token</code> , <code>secret</code> 分别为前面开发管理中获取到的<code>AppID</code>  和 <code>Token</code>，和生成的 <code>AppSecret</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs conf">HOST=0.0.0.0<br>PORT=自定义端口，与nginx配置文件中的端口一致<br>COMMAND_START=[&quot;/&quot;, &quot;&quot;]<br>COMMAND_SEP=[&quot;.&quot;, &quot; &quot;]<br>DRIVER=~fastapi+~httpx<br>LOG_LEVEL=DEBUG<br>API_TIMEOUT=10.0<br>NICKNAME=[&quot;机器人昵称1&quot;, &quot;机器人昵称2&quot;]<br>SESSION_EXPIRE_TIMEOUT=00:02:00<br>QQ_IS_SANDBOX=true<br><br>QQ_BOTS=[&#123;&quot;id&quot;:&quot;xxx&quot;,&quot;token&quot;:&quot;xxx&quot;,&quot;secret&quot;:&quot;xxx&quot;,&quot;intent&quot;:&#123;&quot;c2c_group_at_messages&quot;:true&#125;,&quot;use_websocket&quot;:false&#125;]<br></code></pre></td></tr></table></figure><h1 id="测试机器人"><a href="#测试机器人" class="headerlink" title="测试机器人"></a>测试机器人</h1><p>写一个简单的小功能测试机器人是否搭建完成<br>在 <code>QQ_BOT</code> 下创建机器人主文件 <code>bot.py</code>，内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> nonebot<br><span class="hljs-keyword">from</span> nonebot.adapters.qq <span class="hljs-keyword">import</span> Adapter <span class="hljs-keyword">as</span> QQAdapter<br><br>nonebot.init()<br><br>driver = nonebot.get_driver()<br>driver.register_adapter(QQAdapter)<br><br>nonebot.load_plugins(<span class="hljs-string">&quot;my_bot/plugins&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    nonebot.run()<br></code></pre></td></tr></table></figure><p>在 <code>QQ_BOT</code> 下创建一个目录，并再在其下创建一个 <code>plugins</code> 目录，在 <code>plugins</code> 目录下创建一个 <code>repeater.py</code> 文件，内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nonebot <span class="hljs-keyword">import</span> on_message<br><span class="hljs-keyword">from</span> nonebot.adapters.qq <span class="hljs-keyword">import</span> MessageEvent, MessageSegment<br><br><span class="hljs-comment"># 捕获所有消息事件</span><br>repeater = on_message()<br><br><span class="hljs-meta">@repeater.handle()</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">repeat</span>(<span class="hljs-params">event: MessageEvent</span>):<br>    msg = event.get_plaintext()<br>    <span class="hljs-keyword">await</span> repeater.send(MessageSegment.text(msg))<br></code></pre></td></tr></table></figure><p>目录结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">QQ_BOT/<br>├── bot.py<br>├── .env<br>├── my_bot/<br>│   └── plugins/<br>│   │   └── repeater.py<br></code></pre></td></tr></table></figure><p>这段代码可以使机器人重复发送所有收到的消息，使用如下命令启动机器人</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .venv/bin/activate<br>python bot.py<br></code></pre></td></tr></table></figure><p>启动之后，在 QQ 开放平台的机器人页面中，回调配置地址设置为 <code>https://your_domain/qq/webhook/</code></p><p>在沙箱群中，测试机器人是否正常运行<br><img src="/img/2025-06-17-3.jpg" alt="测试成功"></p><hr><p>突然奇想想开发一个机器人，小时候用过一键脚本搭建过机器人，那时候还什么技术都不懂，只知道这样很好玩，现在长大了，学了很多技术了，可以尝试自己实现一个想要的功能了(★O∀O*)◇+｡</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QQ</tag>
      
      <tag>bot</tag>
      
      <tag>webhook</tag>
      
      <tag>NoneBot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jellyfin使用pt下载的数据踩坑</title>
    <link href="/2025/06/02/Jellyfin%E4%BD%BF%E7%94%A8pt%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%B8%A9%E5%9D%91/"/>
    <url>/2025/06/02/Jellyfin%E4%BD%BF%E7%94%A8pt%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="qBittorrent每次重启莫名其妙的文件丢失"><a href="#qBittorrent每次重启莫名其妙的文件丢失" class="headerlink" title="qBittorrent每次重启莫名其妙的文件丢失"></a>qBittorrent每次重启莫名其妙的文件丢失</h1><p>最近重装了一个新的 NAS，使用的是 Intel 的 N100 处理器，相较于上一台 J1900 性能得到了极大提升<br>在装好系统后，迁移种子到新的 NAS 上做种子的时候，发现有些种子会出现文件损失的情况，每次都需要手动强制重新校验，然后会发现有些文件丢失了需要重新下载<br>刚开始我不以为然，以为是小问题，但当我重启多了之后发现，经常会有重启后文件丢失的情况<br>我当然是不愿意怀疑是硬盘坏了的，毕竟新硬盘没用几天，怎么可能这么快就坏了呢<br>于是就尝试寻找一下问题出现的原因和解决的办法</p><span id="more"></span><h1 id="问题的发生地点"><a href="#问题的发生地点" class="headerlink" title="问题的发生地点"></a>问题的发生地点</h1><p>首先是在 qBittorrent 中查看丢失的是什么文件，发现大多数文件损失会出现在 pt 下载的资源下的<code>CDs</code>这个目录<br><img src="/img/2025-06-02-1.png"></p><p>这个目录通常存储的是音频文件还有封面图片，再看丢失的是什么文件，可以发现，丢失的大都是封面图片(cover.jpg)<br><img src="/img/2025-06-02-2.png"></p><p>为什么丢失的大多是这个文件呢，我带着疑问到文件目录下查看了这个文件的信息<br><img src="/img/2025-06-02-3.png"></p><p>可以看到，这些出问题的文件都是最近生成的，显然不是资源中自带的文件<br>那么问题的原因就很明显了，存在什么程序会生成同样的文件，并且会覆盖这个地方的文件</p><h1 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h1><p>很快我就联想到了这个文件生成时间我在做什么，我当时在 Jellyfin 对这个资源进行了手动刮削，其中有一项替换图片的选项，大概率就是这个步骤出现的问题<br>但是 Jellyfin 默认是不会在这个地方产生这样的文件的，于是我找到了 Jellyfin 的媒体库设置，找到了问题的根源<br><img src="/img/2025-06-02-4.png" alt="现已关闭"></p><p>在 Jellyfin 媒体库的设置中，这一项可以将刮削得到的图像保存到这个文件所在的目录下，即放在了一起<br>这一设置的本意是方便文件的迁移和编辑，是个很好的功能，但是它同时会保存封面图像(cover.jpg)在目录下，这正好与资源中自带的封面图像重名了，于是资源中的文件被覆盖，导致了 qBittorrent 每次重启校验都会发现文件丢失<br>虽然是个好功能，但是影响到了原资源，只好将其关闭了</p><hr><p>这个问题在上一台 NAS 上也时有发生，都没有太在意，直到最近新组了台 NAS 才发现这个问题愈发的严重，这才想到寻找解决的方法<br>以后对于软件的设置还是需要慎之又慎，在不清楚实际功能的情况下，还是保持开发者设置的默认选项吧(シ. .)シ</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jellyfin</tag>
      
      <tag>pt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sunshine+Moonlight+Tailscale远程操控电脑</title>
    <link href="/2025/04/25/Sunshine-Moonlight-Tailscale%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7%E7%94%B5%E8%84%91/"/>
    <url>/2025/04/25/Sunshine-Moonlight-Tailscale%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7%E7%94%B5%E8%84%91/</url>
    
    <content type="html"><![CDATA[<h1 id="尝试实现了一套新的远程操控电脑的方案"><a href="#尝试实现了一套新的远程操控电脑的方案" class="headerlink" title="尝试实现了一套新的远程操控电脑的方案"></a>尝试实现了一套新的远程操控电脑的方案</h1><p>最近几天尝试了在内网中使用 Sunshine 和 Moonlight 实现了局域网内串流玩游戏<del>(GalGame)</del><br>在使用了一段时间后，体验非常好，可以躺在床上玩游戏，于是就想这么方便的方案，为什么不能用在工网上远程控制电脑呢<br>在尝试了网络上的方案后，发现使用 IPv6 的方案对我来说是不可行的，必须尝试使用其他的方案，于是就想到了使用 Tailscale 进行内网穿透再使用 Sunshine 和 Moonlight 来远程控制电脑</p><span id="more"></span><h1 id="局域网内实现串流控制"><a href="#局域网内实现串流控制" class="headerlink" title="局域网内实现串流控制"></a>局域网内实现串流控制</h1><p>首先在被控电脑上安装 Sunshine，Sunshine 可以在 <a href="https://github.com/lizardbyte/sunshine/releases">GitHub</a> 上下载对应系统的安装包<br>我是在 Windows 上安装的，所以下载的是 <code>sunshine-windows-installer.exe</code><br>安装完成后，打开 Sunshine，在浏览器中对 Sunshine 进行配置<br>由于这个方案本质上是构建了一个大内网，所以对于 Sunshine 来说，配置一个网页登录账号密码即可</p><p>在安卓手机上安装 Moonlight，Moonlight 可以在 <a href="https://github.com/moonlight-stream/moonlight-qt/releases">GitHub</a> 上下载apk安装包<br>安装完成后，打开 Moonlight，里面可以看到内网中存在的 Sunshine 服务器，选择连接后，可以看到联机请求的 PIN 码<br><img src="/img/2025-4-25-1.jpg"><br>在 Sunshine 的网页设置中，输入这个 PIN 码，即可在内网中操控电脑了<br><img src="/img/2025-4-25-2.png"></p><h1 id="实现在公网远程操控电脑"><a href="#实现在公网远程操控电脑" class="headerlink" title="实现在公网远程操控电脑"></a>实现在公网远程操控电脑</h1><p>只使用 Tailscale 是最简单的方案，只需要被控电脑和控制设备都安装 Tailscale，使用官方的服务器即可完成<br>不过我选择了自建 Headscale 服务器和 Derper 服务器，搭建方法在我以前的<a href="/2024/01/05/tailscale-headscale-derper-acme%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F">文章</a>中已经完成了，按照其中的方案进行操作即可</p><p>搭建完成后，将被控电脑和控制设备都加入到 Headscale 网络中，这样在 Moonlight 中就可以看到被控设备了，至此，公网的远程控制电脑完成了</p><h1 id="无需域名搭建-Derper-服务器"><a href="#无需域名搭建-Derper-服务器" class="headerlink" title="无需域名搭建 Derper 服务器"></a>无需域名搭建 Derper 服务器</h1><p>现在的 Derper 服务端已经支持无需域名的搭建方式了，使用 <code>acme</code> 申请证书这一步可以替换为以下命令生成自签证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">DERP_IP= Derper服务器IP<br>openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -nodes -keyout $&#123;DERP_IP&#125;.key -out $&#123;DERP_IP&#125;.crt -subj &quot;/CN=$&#123;DERP_IP&#125;&quot; -addext &quot;subjectAltName=IP:$&#123;DERP_IP&#125;&quot;<br></code></pre></td></tr></table></figure><p>将生成的证书和私钥放入 <code>/opt/derper</code> 目录下，并更改 <code>/etc/systemd/system/derper.service</code>文件的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=Start Derper<br>After=network.target<br>Wants=network.target<br>[Service]<br>User=root<br>Restart=always<br>ExecStart=/opt/derper/derper -hostname Derper服务器IP -a :12150 -http-port 12151 -certmode manual -certdir /opt/derper<br>RestartPreventExitStatus=1<br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>Headscale 的配置文件 <code>/etc/headscale/derp.yaml</code> 也进行如下修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">regions:</span><br>  <span class="hljs-attr">901:</span><br>    <span class="hljs-attr">regionid:</span> <span class="hljs-number">901</span><br>    <span class="hljs-attr">regioncode:</span> <span class="hljs-string">DERP</span><br>    <span class="hljs-attr">regionname:</span> <span class="hljs-string">MYDERP</span><br>    <span class="hljs-attr">nodes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DERP_SERVER_1</span> <br>        <span class="hljs-attr">regionid:</span> <span class="hljs-number">901</span><br>        <span class="hljs-attr">hostname:</span> <span class="hljs-string">Derper服务器的IP地址</span><br>        <span class="hljs-attr">stunport:</span> <span class="hljs-number">3478</span><br>        <span class="hljs-attr">stunonly:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">derpport:</span> <span class="hljs-number">12150</span><br></code></pre></td></tr></table></figure><p>这样，就可以搭建不需要域名的 Derper 服务器了</p><hr><p>能够实现一个新的远程控制电脑的方案，非常的高兴ヾ(＾-＾)ノ<br>但是由于这个方案使用的是 Tailscale 打洞方案，所以在网络情况不佳的情况下，会比较不稳定，所以不能完全替代其他的远程方案，需要和其他的远程方案一起使用</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Tailscale</tag>
      
      <tag>Headscale</tag>
      
      <tag>Derper</tag>
      
      <tag>Sunshine</tag>
      
      <tag>Moonlight</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用Macvlan</title>
    <link href="/2025/04/22/Docker%E4%BD%BF%E7%94%A8Macvlan/"/>
    <url>/2025/04/22/Docker%E4%BD%BF%E7%94%A8Macvlan/</url>
    
    <content type="html"><![CDATA[<h1 id="学习到了个新技术"><a href="#学习到了个新技术" class="headerlink" title="学习到了个新技术"></a>学习到了个新技术</h1><p>为了完成导师布置给我的任务，需要实现内网中模拟多台设备，并且这些设备都要有IP地址和各自的MAC地址<br>刚开始，我想到了使用虚拟来实现这个任务，但是后来发现，这个方案不行，太消耗资源了，而且部署起来也不怎么灵活<br>找着找着，突然发现了Linux的Macvlan技术，这个技术可以实现内网中模拟多台设备，并且这些设备都要有IP地址和各自的MAC地址<br>经过实验后，成功的实现了要求，为此记录下这个新学习到的技术</p><span id="more"></span><h1 id="Macvlan简介"><a href="#Macvlan简介" class="headerlink" title="Macvlan简介"></a>Macvlan简介</h1><p>以下是 Macvlan的介绍:<br>Macvlan是一种虚拟局域网技术，当需要为同一网络接口分配多个 IP 地址时，即可使用该技术。其本质是将物理网络接口分割为多个拥有独立 IP 地址的子接口。系统会根据随机生成的 MAC 地址来分配对应的IP地址，Macvlan 网络类型允许预先配置连接实例到父接口的预设参数，通过这种方式，实例网卡只需简单地将网络选项设置为所连接的网络名称，而无需了解任何底层配置细节即可完成网络连接<br>简而言之，Macvlan 可以将一个网卡分成多个网卡，而且这些网卡是互相隔离的，在其他网络设备看来，这些网卡是独立的，它们拥有独立的 IP 地址和 MAC 地址</p><h1 id="Docker使用Macvlan"><a href="#Docker使用Macvlan" class="headerlink" title="Docker使用Macvlan"></a>Docker使用Macvlan</h1><p>做一个简单的实验，在一个网卡上生成三个网卡，在这些网卡上分别使用 Docker 搭建 Nginx 服务器来验证是否搭建成功<br>首先，验证设备是否支持 Macvlan</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检查内核是否加载了 macvlan 模块</span><br>lsmod | grep macvlan<br><br><span class="hljs-comment"># 如果没有输出，尝试加载模块</span><br><span class="hljs-built_in">sudo</span> modprobe macvlan<br>lsmod | grep macvlan  <span class="hljs-comment"># 再次检查</span><br></code></pre></td></tr></table></figure><p>如果设备支持，则继续</p><p>首先编辑在一个空目录中编辑 Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">22.04</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y nginx &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y curl &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>这 个Dockerfile 安装了 Nginx 和 curl，并设置了一个默认的端口映射，Nginx 是为了验证是否搭建成功，curl 是为了验证能否正常访问互联网</p><p>然后再编辑 docker-compose.yaml 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;233&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">phone1:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">phone1</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-attr">default_net:</span><br>      <span class="hljs-attr">macvlan_net:</span><br>          <span class="hljs-attr">ipv4_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.242</span><span class="hljs-number">.101</span>  <span class="hljs-comment"># 替换为可用IP</span><br>    <span class="hljs-attr">dns:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span><br><br>  <span class="hljs-attr">phone2:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">phone2</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-attr">default_net:</span><br>      <span class="hljs-attr">macvlan_net:</span><br>          <span class="hljs-attr">ipv4_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.242</span><span class="hljs-number">.102</span>  <span class="hljs-comment"># 替换为可用IP</span><br>    <span class="hljs-attr">dns:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span><br><br>  <span class="hljs-attr">phone3:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">phone3</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-attr">default_net:</span><br>      <span class="hljs-attr">macvlan_net:</span><br>          <span class="hljs-attr">ipv4_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.242</span><span class="hljs-number">.103</span>  <span class="hljs-comment"># 替换为可用IP</span><br>    <span class="hljs-attr">dns:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">default_net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br>  <span class="hljs-attr">macvlan_net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">macvlan</span><br>    <span class="hljs-attr">driver_opts:</span><br>      <span class="hljs-attr">parent:</span> <span class="hljs-string">ens33</span>  <span class="hljs-comment"># 替换为主机网络接口</span><br>    <span class="hljs-attr">ipam:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">subnet:</span> <span class="hljs-string">&quot;192.168.242.0/24&quot;</span><br>          <span class="hljs-attr">gateway:</span> <span class="hljs-string">&quot;192.168.242.1&quot;</span><br></code></pre></td></tr></table></figure><p>这个 docker-compose.yml 文件定义了两个网络，default_net 和 macvlan_net，default_net 是一个 bridge 网络，用于访问互联网，macvlan_net 是一个 macvlan 网络，也就是实验需要验证的网络<br>编辑完成后后，即可启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose up -d --build<br></code></pre></td></tr></table></figure><p>待容器创建完成后，可以通过命令查看容器是否正常启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><p>此时可以看到创建的三个容器已经在运行了，再通过命令查看 Docker 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>此时可以看到两个网络，default_net 和 macvlan_net，且 Driver 分别是 bridge 和 macvlan<br>使用另外一台同局域网的设备，浏览器分别访问 192.168.242.101、192.168.242.102 和 192.168.242.103，可以成功访问到三个 Nginx 服务器<br><img src="/img/2025-4-22-1.png"></p><p>随意选择一个容器，进入容器内部，使用 curl 命令访问外网，可以正常访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it phone1 /bin/bash<br><br>curl https://www.baidu.com<br></code></pre></td></tr></table></figure><hr><p>通过 Macvlan 技术，实现了内网中模拟多台设备，并且这些设备都要有IP地址和各自的MAC地址<br>如果应用到我自己的 NAS 上，可以解决我的多个 qBittorrent 下载器使用不同端口的问题，这样就可以解决端口冲突导致不得不更换使用其他端口的问题了<br>学到了新的技术并且可以解决实际问题，非常的高兴♫꒰･◡･๑꒱</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
      <tag>Macvlan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qBittorrent的Tracker未工作</title>
    <link href="/2025/03/24/qBittorrent%E7%9A%84Tracker%E6%9C%AA%E5%B7%A5%E4%BD%9C/"/>
    <url>/2025/03/24/qBittorrent%E7%9A%84Tracker%E6%9C%AA%E5%B7%A5%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="qBittorrent的Tracker持续一个月未工作了"><a href="#qBittorrent的Tracker持续一个月未工作了" class="headerlink" title="qBittorrent的Tracker持续一个月未工作了"></a>qBittorrent的Tracker持续一个月未工作了</h1><p>在家用自建的NAS玩PT做种，本来也挺佛系的，看到想看的番剧就会下下来放到硬盘里，虽然现在玩PT就是个仓鼠，但万一以后有时间了呢？<br>最近碰到的就是，一个种子下了一个月了，进度还是0%，但是在PT网站上看到是有人做种的，所以肯定不是死种<br>浴室我就看到了qBitTorrent的种子下面的Tracker一直是处于<strong>未工作</strong>的状态，刚开始以为PT网站正在维护，过几天就好了，但是过了一周也没有好，我开始怀疑是代理问题，更换了代理依旧没有得到解决，随后我再一些帖子下面找到了更换CloudFlare的IP地址的方法，尝试之后成功解决了Tracker的未工作状态</p><span id="more"></span><h1 id="优选IP"><a href="#优选IP" class="headerlink" title="优选IP"></a>优选IP</h1><p>首先得确定目标网站是否使用了CloudFlare作为CDN，如果是，则可以使用<a href="https://github.com/XIU2/CloudflareSpeedTest">CloudflareSpeedTest</a>进行IP优选<br>使用起来很方便，根据READEME.md里面的说明，照着做就好了</p><h1 id="更改hosts文件"><a href="#更改hosts文件" class="headerlink" title="更改hosts文件"></a>更改hosts文件</h1><p>获取了优选IP之后，更改系统的hosts文件，重启一下qBittorrent，问题就可以得到解决<br>Linux的可以直接修改&#x2F;etc&#x2F;hosts文件，在最下面添加一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs config">优选IPTracker的域名<br></code></pre></td></tr></table></figure><p>Tracker的域名可以在qBittorrent的种子下的<code>Tracker</code>中找到</p><p>使用 Docker 的可以先进入到容器中，再修改&#x2F;etc&#x2F;hosts文件即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it qbittorrent /bin/bash<br>echo &quot;优选IPTracker的域名&quot; &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><hr><p>看到一个月没有动一点的种子总算“复活”开始下载了，发现自己之前还是太懒了，不想去找解决方法，以为是会自动恢复的问题，到头来，还是得找方法解决，既没省力，还浪费了时间(一些番剧一直没下载，<del>当然就算下载了也不会立马去看</del>)</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
      <tag>qBittorrent</tag>
      
      <tag>Tracker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows11安装DGL</title>
    <link href="/2025/01/15/Windows11%E5%AE%89%E8%A3%85DGL/"/>
    <url>/2025/01/15/Windows11%E5%AE%89%E8%A3%85DGL/</url>
    
    <content type="html"><![CDATA[<p>为了学习使用OpenHGNN，需要安装DGL，但是按照<a href="https://www.dgl.ai/pages/start.html">官网</a>的方法安装就是无法正常运行，于是找了一天的方法，总算是解决了</p><span id="more"></span><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>我的环境是Windows11的系统，显卡是笔记本的4070显卡，所以安装了最新的驱动和CUDA12.6，CUDA的版本直接安装最新的即可，是向下兼容的<br>python 版本是<code>3.12.8</code>，注意目前最新的python版本不支持DGL，最高只支持<code>3.12</code>的版本</p><h1 id="报错原因"><a href="#报错原因" class="headerlink" title="报错原因"></a>报错原因</h1><p>报错信息我碰到的有如下两个</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">FileNotFoundError: Cannot find DGL C++ graphbolt library at D:\HGNN\code\.venv\Lib\site-packages\dgl\graphbolt\graphbolt_pytorch_2.4.1.dll<br></code></pre></td></tr></table></figure><p>这个报错的原因是DGL的安装包中缺少了<code>graphbolt_pytorch_2.4.1.dll</code>这个文件，而之所以缺少这个文件是因为DGL从2024年6月27日开始不支持Windows的最新版本更新了，所以这个文件在安装的时候就是不存在的，当然报错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ModuleNotFoundError: No module named &#x27;torchdata.datapipes&#x27;<br></code></pre></td></tr></table></figure><p>这个的原因是TorchData<a href="https://pypi.org/project/torchdata/">不再维护datapipes了</a>，所以如果没有碰到上面的报错，就可能碰到这个报错<br><img src="/img/2025-1-15-1.png"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法有两个</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><del>使用Linux，这样肯定不会有这个报错了，一劳永逸</del></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>安装老版本的DGL<br>为了安装老版本的DGL，pytorch的版本也需要降级，可以去<a href="https://pytorch.org/get-started/previous-versions/">pytorch官网</a>找到老版本安装，使用如下命令可以安装pytorch2.2.1版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install torch==2.2.1 torchvision==0.17.1 torchaudio==2.2.1 --index-url https://download.pytorch.org/whl/cu121<br></code></pre></td></tr></table></figure><p>然后使用如下命令安装DGL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install  dgl -f https://data.dgl.ai/wheels/cu121/repo.html<br></code></pre></td></tr></table></figure><p>安装完成后别急，还可能碰到TorchData的报错，解决方法是降级TorchData</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install torchdata==0.7.1<br></code></pre></td></tr></table></figure><p>安装完这些后还可能碰到缺少pydantic的问题，安装一下即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install pydantic<br></code></pre></td></tr></table></figure><p>至此，DGL就安装成功了，可以测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> dgl<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-built_in">print</span>(dgl.__version__)<br><span class="hljs-built_in">print</span>(torch.__version__)<br></code></pre></td></tr></table></figure><p>输出可以看到正常的版本信息</p><hr><p>搞了一下午，刚开始还以为很简单的，按照官网的方法安装很快就可以安装好的，没想到还是碰到了各种各样的问题<br>希望以后能别再遇到这样的问题了，记录下来以备以后需要</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows11</tag>
      
      <tag>DGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu搭建OpenVPN服务器</title>
    <link href="/2024/12/10/Ubuntu%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2024/12/10/Ubuntu%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>今天在 Ubuntu 的云服务器上搭建了一个 OpenVPN 服务器，并且使用 Windows 和 Linux 客户端加入到了这个 VPN 网络中，记录一下搭建的过程，以备以后查询</p><span id="more"></span><h1 id="生成证书和密钥"><a href="#生成证书和密钥" class="headerlink" title="生成证书和密钥"></a>生成证书和密钥</h1><p>Open VPN 服务器需要生成证书和密钥，这些可以使用 easy-rsa 来生成<br>首先在服务端下载并解压 easy-rsa</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/OpenVPN/easy-rsa/releases/download/v3.2.1/EasyRSA-3.2.1.tgz<br>tar -xzf EasyRSA-3.2.1.tgz<br><span class="hljs-built_in">cd</span> EasyRSA-3.2.1<br></code></pre></td></tr></table></figure><p>生成 CA 证书和服务端的私钥和证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">./easyrsa init-pki <span class="hljs-comment">#初始化</span><br>./easyrsa build-ca <span class="hljs-comment">#注意设置CA证书的密码</span><br>./easyrsa gen-req server nopass <span class="hljs-comment">#创建服务端证书的请求</span><br>./easyrsa sign-req server server <span class="hljs-comment">#签名服务端证书，第一个server是命令的参数，第二个server是证书的名字，可以自定义</span><br>./easyrsa gen-dh <span class="hljs-comment">#生成 Diffie-Hellman文件，在 Open Vpn 连接时使用 Diffie-Hellman 密钥交换算法</span><br></code></pre></td></tr></table></figure><p>生成客户端证书和密钥，在客户端上下载并解压 EasyRSA，并执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./easyrsa init-pki <span class="hljs-comment">#初始化</span><br>./easyrsa gen-req client nopass <span class="hljs-comment">#生成客户端证书的请求，client为证书名，可以自定义，nopass表示不需要设置密码</span><br></code></pre></td></tr></table></figure><p>将客户端的请求文件 <code>pki/reqs/client.req</code> 发送给服务端，服务段对请求文件进行签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./easyrsa import-req /path/to/client.req client <span class="hljs-comment">#导入客户端请求文件，client为导入的请求名</span><br>./easyrsa sign-req client client <span class="hljs-comment">#签名客户端证书，第一个client为参数，表示签发为客户端，第二个为上一条命令导入的请求名</span><br></code></pre></td></tr></table></figure><p>签发完成后，将服务端的 <code>pki/ca.crt</code> 和 <code>pki/issued/client.crt</code> 文件发送到客户端<br>至此，证书和密钥已经生成完毕，下面开始配置 openvpn 服务器</p><h1 id="配置-Open-VPN-服务器"><a href="#配置-Open-VPN-服务器" class="headerlink" title="配置 Open VPN 服务器"></a>配置 Open VPN 服务器</h1><p>安装 openvpn，Ubuntu 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install openvpn<br></code></pre></td></tr></table></figure><p>修改配置文件 <code>/etc/openvpn/server.conf</code>，如果没有，可以将 <code>/usr/share/doc/openvpn/examples/sample-config-files/server.conf</code> 复制到 <code>/etc/openvpn</code> 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server.conf<br></code></pre></td></tr></table></figure><p>修改配置文件的以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs conf">port 1194 #端口<br>proto udp #使用 UDP 协议<br>dev tun #使用 TUN 模式<br>ca /path/to/easy-rsa/pki/ca.crt #CA 证书<br>cert /path/to/easy-rsa/pki/issued/server.crt #服务端证书<br>key /path/to/easy-rsa/pki/private/server.key #服务端私钥<br>dh /path/to/easy-rsa/pki/dh.pem #Diffie-Hellman 文件<br>server 10.8.0.0 255.255.255.0 #服务器网段，第一个为网段，第二个为子网掩码<br>ifconfig-pool-persist /var/log/openvpn/ipp.txt #保存客户端 IP 地址池<br>client-config-dir ccd #客户端配置目录，如果需要固定客户端 IP 地址，可以在该目录下创建文件，文件名是客户端证书的名字，文件内容是客户端的 IP 地址<br>client-to-client #允许客户端之间互相访问<br>duplicate-cn #允许重复的 CN<br>keepalive 10 120 #保持连接，第一个参数为每10秒发送一次心跳包，第二个参数为如果120秒内没有收到心跳包，则断开连接<br>cipher AES-256-CBC #加密算法<br>comp-lzo #压缩算法<br>persist-key #VPN重启后保持密钥<br>persist-tun #VPN重启后保持隧道<br>status /var/log/openvpn/openvpn-status.log #状态日志文件<br>verb 3 #日志级别<br>explicit-exit-notify 1 #退出通知客户端<br></code></pre></td></tr></table></figure><p>改好配置后，启动服务端的 openvpn 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start openvpn@server<br></code></pre></td></tr></table></figure><h1 id="配置-Windows-客户端"><a href="#配置-Windows-客户端" class="headerlink" title="配置 Windows 客户端"></a>配置 Windows 客户端</h1><p>去<a href="https://openvpn.net/community-downloads/">官网</a>下载 openvpn 客户端，解压并安装<br>将创建好的客户端证书(client.crt)、私钥(client.key)和服务端的CA证书(ca.crt)放在 openvpn 安装目录的config目录下，例如 <code>C:\Users\NeroUMU\OpenVPN\config</code><br>再在config目录下创建一个客户端配置文件 <code>client.ovpn</code>，这里的client为openvpn识别的客户端可以自定义，内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs conf">client #这里表示客户端模式，不可自定义<br>dev tun<br>proto udp<br>remote 服务端IP 1194 #openvpn服务端的IP和端口号<br>resolv-retry infinite<br>nobind<br>ca ca.crt<br>cert client.crt<br>key client.key<br>verb 3<br>persist-key<br>comp-lzo<br></code></pre></td></tr></table></figure><p>配置完成后，启动 Open VPN，即可连接 openvpn 服务器</p><h1 id="配置-Linux-客户端"><a href="#配置-Linux-客户端" class="headerlink" title="配置 Linux 客户端"></a>配置 Linux 客户端</h1><p>我是在 Arch Linux 上配置的，Arch Linux 的大部分操作都与 Ubuntu 相似，但有几处命令不同，这里可以查询 <a href="https://wiki.archlinuxcn.org/wiki/OpenVPN">Arch Linux Wiki</a><br>安装 openvpn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S openvpn<br></code></pre></td></tr></table></figure><p>将创建好的客户端证书(client.crt)、私钥(client.key)和服务端的CA证书(ca.crt)放在 <code>/etc/openvpn/client</code> 下<br>再创建配置文件 <code>/etc/openvpn/client/.client.conf</code>，内容与 Windows 客户端相同，注意一定是<code>.client.conf</code>，不能是 <code>client.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs conf">client #这里表示客户端模式，不可自定义<br>dev tun<br>proto udp<br>remote 服务端IP 1194 #openvpn服务端的IP和端口号<br>resolv-retry infinite<br>nobind<br>ca ca.crt<br>cert client.crt<br>key client.key<br>verb 3<br>persist-key<br>comp-lzo<br></code></pre></td></tr></table></figure><p>如果是 Ubuntu，则都放在 <code>/etc/openvpn</code> 目录下，且配置文件名为 <code>client.conf</code></p><p>启动客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start openvpn-client@.client<br></code></pre></td></tr></table></figure><h1 id="固定客户端-IP-地址"><a href="#固定客户端-IP-地址" class="headerlink" title="固定客户端 IP 地址"></a>固定客户端 IP 地址</h1><p>如果想要固定客户端 IP 地址，可以在服务端 <code>/etc/openvpn/ccd</code> 目录下创建文件，文件名是客户端证书的名字(CN)，文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">ifconfig-push 客户端IP 对端IP<br></code></pre></td></tr></table></figure><p>注意客户端 IP 和 对端 IP 都是服务器网段的，并且同在一个 <code>255.255.255.252</code> 的网段内，比如 <code>10.8.0.2</code> 与 <code>10.8.0.1</code>，<code>10.8.0.50</code> 与 <code>10.8.0.49</code>都是一对合法的客户端 IP 和 对端 IP</p><hr><p>搭建 Open VPN 服务器看上去很复杂，但是一路搭建下来会发现脉络清晰，很简单的，在搭建过程中碰到的最大的问题可能就是最后固定IP了，那里一开始没有理解报错信息里的网段，导致浪费了一些时间，不过好在都解决了Ciallo～(∠・ω&lt; )⌒☆</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubnutn</tag>
      
      <tag>Open Vpn</tag>
      
      <tag>easy-rsa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows设置开机执行命令</title>
    <link href="/2024/11/23/Windows%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/11/23/Windows%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>等了10多天，我的天选5pro电脑终于到货了，开机检查没问题后就给她加了16g内存、1T的固态硬盘并换了一张AX210的网卡<br>电脑的硬件搞定了，为了让电脑使用得更加舒适，软件也得装好<br>首先要装的就是广告屏蔽器，AdGuardHome<br>但是这个软件下载下来后是一个 <code>exe</code> 文件，得用命令启动，而且启动后会有一个命令行的窗口不能关闭，于是我在网上找了好几种方法，总算设置好了开机启动并且隐藏这个命令行窗口<br>在此记录下这个方法，方便以后使用</p><span id="more"></span><h1 id="创建开机启动任务"><a href="#创建开机启动任务" class="headerlink" title="创建开机启动任务"></a>创建开机启动任务</h1><p>首先先将需要执行的程序放在一个方便找到的目录下，记好这个目录，使用 <code>Win + R</code> 快捷键，输入 <code>taskschd.msc</code> 打开 <code>任务计划程序</code><br>选择 <code>任务计划程序库</code>，在右边选择 <code>创建任务</code></p><ul><li>在 <code>常规</code> 选项中， <code>名称</code> 随意输入，勾选 <code>使用最高权限</code> 和 <code>隐藏</code>，配置选择 <code>Windows 10</code></li><li>在 <code>触发器</code> 选项中，选择新建，开始任务选择 <code>登录时</code></li><li>在 <code>操作</code> 选项中，选择新建，操作为 <code>启动程序</code>，<code>程序或脚本</code> 设置为 <code>powershell.exe</code>，并添加参数为</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs config">-WindowStyle Hidden -Command &quot;Your Command&quot;<br></code></pre></td></tr></table></figure><p>其中 <code>Your Command</code> 为需要执行的命令<br>设置完成后，点击 <code>确定</code> 创建一个任务<br>在右边可以点击 <code>运行</code> 来查看是否能正常运行</p><p>重启电脑，验证需要执行的命令是否已正常执行</p><hr><p>等了10多天，我的天选5pro总算到货了，<del>终于可以在实验室摸鱼打游戏了</del><br>咳咳，当然不会天天在实验室打游戏的啦，还是要学习和做科研的(º﹃º)<br><del>这篇博客就是拿新电脑写的</del></p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>AdGuardHome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker搭建ANI-RSS</title>
    <link href="/2024/11/16/Docker%E6%90%AD%E5%BB%BAANI-RSS/"/>
    <url>/2024/11/16/Docker%E6%90%AD%E5%BB%BAANI-RSS/</url>
    
    <content type="html"><![CDATA[<p>今天不知道为什么 Auto-Bangumi 的 Docker 容器无法启动了，正想着花些时间看日志排查一下是什么问题，突然想起之前关注的一个项目 ANI-RSS，看文档感觉搭建起来也不困难，而且功能也很好的满足了我的追番需求，于是就尝试搭建了一下<br>最终是搭建成功了，使用起来非常简单而且功能强大，故记录下搭建过程，方便以后参考</p><span id="more"></span><h1 id="编辑-docker-compose-yml-文件并启动容器"><a href="#编辑-docker-compose-yml-文件并启动容器" class="headerlink" title="编辑 docker-compose.yml 文件并启动容器"></a>编辑 docker-compose.yml 文件并启动容器</h1><p>创建一个目录 <code>ani-rss</code>，在该目录下编辑 <code>docker-compose.yaml</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ani-rss<br><span class="hljs-built_in">cd</span> ani-rss<br><span class="hljs-built_in">cat</span> &gt; docker-compose.yaml &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">version: &quot;0721&quot;</span><br><span class="hljs-string">services:</span><br><span class="hljs-string">    ani-rss:</span><br><span class="hljs-string">        container_name: ani-rss</span><br><span class="hljs-string">        volumes:</span><br><span class="hljs-string">        - /path/to/ani/config:/config</span><br><span class="hljs-string">        ports:</span><br><span class="hljs-string">        - 7789:7789</span><br><span class="hljs-string">        environment:</span><br><span class="hljs-string">        - PORT=7789</span><br><span class="hljs-string">        - CONFIG=/config</span><br><span class="hljs-string">        - TZ=Asia/Shanghai</span><br><span class="hljs-string">        restart: always</span><br><span class="hljs-string">        image: wushuo894/ani-rss</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p><code>volumes</code> 中之所以相较于官方文档中少了一条 <code>/Media</code> 的路径，是因为在启动后是可以手动设置的，这里设置反而容易因为路径映射搞混，不如不填，在容器启动后再设置</p><p>然后就可以启动容器了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose up -d <br></code></pre></td></tr></table></figure><p>待镜像下载完成，容器创建完成后，可以查看容器是否正常运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps | grep ani-rss<br></code></pre></td></tr></table></figure><h1 id="设置-ANI-RSS"><a href="#设置-ANI-RSS" class="headerlink" title="设置 ANI-RSS"></a>设置 ANI-RSS</h1><p>浏览器打开<code>服务器IP:7789</code>，进入登录页面，默认账号密码 <code>admin:admin</code><br>在设置中找到下载设置，下载工具使用 qBittorent，填写好 qBittorent的配置，点击测试查看是否可以连接成功<br>保存位置就是服务器的路径位置，想存在哪里，直接填写绝对路径即可<br>这样 ANI-RSS 就已经可以使用了，如果还需要设置其他的功能可以参考<a href="https://docs.wushuo.top/add-rss.html">官方文档</a></p><hr><p>本来想排除一下 Auto-Bangumi 的错误继续使用的，不过搭建了 ANI-RSS，并使用了一段时间后，发现 ANI-RSS 在实现了 Auto-Bangumi 的所有功能的基础上，实现了更多好用的功能，于是就干脆切换到 ANI-RSS 了|･ω･)</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSS</tag>
      
      <tag>Docker</tag>
      
      <tag>ANI-RSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更换了新的域名</title>
    <link href="/2024/11/13/%E6%9B%B4%E6%8D%A2%E4%BA%86%E6%96%B0%E7%9A%84%E5%9F%9F%E5%90%8D/"/>
    <url>/2024/11/13/%E6%9B%B4%E6%8D%A2%E4%BA%86%E6%96%B0%E7%9A%84%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>moe这个顶级域名太棒了，它来自于日语“萌え”（萌），这可真是太适合我了<br>原来的域名还有几个月就过期了，本想着再过一段时间更换的，但是没想到今天发现现在这个域名正在打折，直接半价购入，于是光速下单并修改了DNS解析到博客上面来了<br>在此记录一下更换域名的步骤，不过以后应该是不会用到了</p><span id="more"></span><h1 id="修改DNS"><a href="#修改DNS" class="headerlink" title="修改DNS"></a>修改DNS</h1><p>我是在<a href="https://porkbun.com/">Porkbun</a>上购买的域名，但是我更习惯使用Cloudflare，所以域名到手的第一件事就是将域名解析到Cloudflare上<br>在Cloudflare的账户主页点击添加域，输入需要更改的域名，然后点击继续，按照自己的需求选择计划<br>更改nameservers时需要在 Porkbun 的域名管理中修改为 Cloudflare 的 nameservers<br><img src="/img/2024-11-13-1.png" alt="需要更改的cloudflare的nameservers"></p><p>在Porkbun的域名管理中将nameservers改为Cloudflare的nameservers<br><img src="/img/2024-11-13-2.png" alt="点击修改nameservers为cloudflare的nameservers"><br>等待一段时间后，域名就被交由cloudflare管理了<br>然后再将原来域名的 DNS 解析全部复制到新域名上就完成了</p><h1 id="修改GitHub的域名地址"><a href="#修改GitHub的域名地址" class="headerlink" title="修改GitHub的域名地址"></a>修改GitHub的域名地址</h1><p>由于博客是搭建在GitHub Pages上，所以需要同时更改GitHub Pages的域名地址<br>在博客目录下的 <code>source</code> 中找到 <code>CNAME</code>(这个在搭建博客的时候就已经创建了) 文件，将里面的内容改为新的域名，然后重新更新一次博客就可以了<br>如果需要 HTTPS 的支持，可以在博客的项目的 <code>Settings</code> 下的 <code>Pages</code> 找到 <code>Custom domain</code>，将域名填写进去，然后等GitHub验证完成后，勾选 <code>Enforce HTTPS</code>，这样 HTTPS 就应用到了新的博客上面了<br><img src="/img/2024-11-13-3.png"></p><hr><p>有一段时间每更新博客了，这么久的一次更新还是因为更换了域名<br>应该是读研期间的时间安排比本科更紧了，都没什么时间折腾了，以后还是得挤一点时间出来写几篇博客啊__φ(．．;)</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
      <tag>GitHub</tag>
      
      <tag>moe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于最近摔跤受伤的思考</title>
    <link href="/2024/09/23/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E6%91%94%E8%B7%A4%E5%8F%97%E4%BC%A4%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2024/09/23/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E6%91%94%E8%B7%A4%E5%8F%97%E4%BC%A4%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>距离骑自行车摔跤受伤已经过去了两周多了，这次受伤的部位主要集中在脸部，身体的其他部位都没什么大碍<br>脸上受的都是皮外伤，但是嘴里面缝了三针，线已经在受伤后一星期拆掉了，目前恢复的很好，没有留疤，生活也差不多回到了受伤前的状态<br>在这次受伤之后，从治疗到后期的恢复经历的一些事，让我有了些想法</p><span id="more"></span><h1 id="受伤原因的思考"><a href="#受伤原因的思考" class="headerlink" title="受伤原因的思考"></a>受伤原因的思考</h1><p>这次受伤的原因是因为骑自行车的时候，和一辆电动车相撞，我骑的自行车翻车导致脸着地，而对方没有任何受伤<br>之所以相撞，是因为对方一边骑车一边看手机，并且在马路上逆行，而我又避让不及，导致最后的相撞<br>也是经过了这次的撞车，我在路上走路都会格外注意道路上一边骑车一边看手机的人，发现这个现象十分普遍，十个骑车的就有至少六个在看手机<br>也是有了吃过这方面的亏，我现在骑车都格外注意道路上骑车看手机的行为，一方面是告诉自己如果要看手机，一定要把车完全停稳了保证安全的情况下再看，另一方面，也是小心那些骑车看手机的人，这也叫君子不立于危墙之下嘛<br>对于骑车看手机的现象，对于自己只做到自己不做的同时远离做出这种危险行为的人</p><h1 id="受伤治疗后的思考"><a href="#受伤治疗后的思考" class="headerlink" title="受伤治疗后的思考"></a>受伤治疗后的思考</h1><p>在刚受伤在医院治疗的过程中，我才知道，与我相撞的人年龄比我还要小，大学刚毕业，来到这个城市在自己的姐姐家帮忙做生意<br>在缝完针离开医院后，商量后续理赔的时候，对方的姐夫紧抓着我的自行车是二手这个问题，死咬着不愿意多理赔500元，最后还是对方的姐姐直接理赔了要求的数额后离开<br>这件事不是我在处理，是我的妈妈帮忙处理的，在与撞我的人分开后就说到，亲人还是比外人亲<br>确实，由于对方的姐夫与对方没有血缘关系，所以在赔偿的金额上不愿意多承担一点，也就是不愿多帮助他一些<br>而姐姐看着是自己弟弟闯得祸，更愿意出手帮助，最后答应了理赔的金额<br>两个人在理赔上的态度完全不同，这就让我想到，在外面，亲人尤其是兄弟姐妹这种血缘关系十分亲密的人，永远是比外人更关心自己的</p><h1 id="受伤恢复阶段的思考"><a href="#受伤恢复阶段的思考" class="headerlink" title="受伤恢复阶段的思考"></a>受伤恢复阶段的思考</h1><p>受伤的前几天要去医院打消炎针，防止伤口发炎，由于治疗的医院距离家比较远，所以前两天在那打了破伤风和消炎针后，自己把药带回到家，后两天在家附件的诊所注射<br>而在家附近的诊所注射消炎针的过程中，护士看到我脸上的血渍后问我，是不是骑车摔跤了，我回答道在骑车过程中被人撞了<br>护士直接问道，那个人跑了吗<br>我立马回答到，没跑，怎么可能让他跑了，如果真的跑了，我肯定是要报警的<br>护士还有点惊讶的说，那这个人还挺负责的，要是别的人撞了，他肯定就跑了<br>虽然对话很短，但我注意到了，在护士多年的工作经验中，和电动车撞车后，对方大概率是会直接逃离现场的<br>这也导致她对于撞到我之后却没逃离现场的人感到意外，因为在她的认知中，电动车撞车就等于肇事者逃逸<br>后来也和旁边的人聊了聊，发现这种现象是普遍存在的，让我对社会的认识有了一些改变<br>仔细思考了一下，发现，如果那天撞我的人真的跑了，我也确实没什么办法，即使发生撞车事故的地点有监控摄像头，因为按照当时的情况，我第一件要做的事情不是抓到肇事者不让他跑(甚至我还没从地上爬起来，他就可能直接跑了)，而是首先去医院处理伤口，这一切的事情都得我自己处理，等到伤口处理完成，我才有精力去报警找到肇事者，即使最后找到了肇事者，赔偿了钱之后，我浪费的精力和赔偿都是不对等的<br>而在对方的角度看来，肇事逃逸反而是利益最大化的做法，因为如果最后没有被抓到，那么他的损失就是零，不用承担任何责任。即使最后被抓到，也不过是赔偿一定的钱就草草了事<br>这样的社会现象确实让人意外，撞了人的第一反应不是承担责任救助伤者，而是逃避责任直接逃逸，并且人们还认为这种做法是一种常态</p><hr><p>闲话就说这么多，这也是我的一点思考，也算是记录一下我的思想的转变吧</p>]]></content>
    
    
    <categories>
      
      <category>闲话</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cliche</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows使用蓝牙耳机声音很闷</title>
    <link href="/2024/09/18/Windows%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E8%80%B3%E6%9C%BA%E5%A3%B0%E9%9F%B3%E5%BE%88%E9%97%B7/"/>
    <url>/2024/09/18/Windows%E4%BD%BF%E7%94%A8%E8%93%9D%E7%89%99%E8%80%B3%E6%9C%BA%E5%A3%B0%E9%9F%B3%E5%BE%88%E9%97%B7/</url>
    
    <content type="html"><![CDATA[<p>今天网上买了个麦克风好和朋友联机开麦打游戏，但是当我将麦克风连上我的电脑后，我的蓝牙耳机突然出现了问题<br>具体表现为:开启游戏后，语音软件的声音会听不见，应该是直接没了，其次游戏的声音会比较闷(有点难解释，但是就是听着不对劲)<br>到网上找了这个问题也没有什么解决方啊，最后在一个讨论其他问题的论坛帖子中，偶然找到了解决方法</p><span id="more"></span><h1 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h1><p>很显然是 Windows 的又一个 Bug，在处理蓝牙耳机的时候，会默认这个蓝牙耳机自带麦克风，即使我的蓝牙耳机没有麦克风<br>解决方法就是禁用这个不存在的麦克风，这样就可以使用自己的麦克风而不会产生干扰</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>打开控制面板，找到 <code>声音</code> 设置选项<br><img src="/img/2024-09-18-1.png"></p><p>在 <code>播放</code> 选项中会找到两个耳机，后缀为 <code>Hands-Free AG Audio</code> 的为有麦克风耳机，后缀为 <code>Stereo</code> 的为普通的耳机<br>在此将 Windows 认为的有麦克风的耳机禁用掉，即可解决游戏声音很闷的问题<br><img src="/img/2024-09-18-2.png"></p><p>解决了游戏声音很闷的问题，还有进入游戏后语音交流软件没有声音的问题没解决<br>同样是在 <code>声音</code> 设置中，找到 <code>通信</code> 选项，将这里设置为 <code>不执行任何操作</code>，这样就可以解决进入游戏后，语音软件没有声音的问题了<br><img src="/img/2024-09-18-3.png"></p><hr><p>新到的麦克风刚插上就突然出现了问题，弄得我还以为我买到的麦克风是坏的，不过还好没事，将设置设置好后就好了<br><del>Windows就是不行，加入Arch Linux吧</del> ε&#x3D;ε&#x3D;ε&#x3D;ε&#x3D;┌(;￣▽￣)┘</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>Bluetooth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>i7-14700k玩游戏闪退</title>
    <link href="/2024/08/01/i7-14700k%E7%8E%A9%E6%B8%B8%E6%88%8F%E9%97%AA%E9%80%80/"/>
    <url>/2024/08/01/i7-14700k%E7%8E%A9%E6%B8%B8%E6%88%8F%E9%97%AA%E9%80%80/</url>
    
    <content type="html"><![CDATA[<h1 id="玩Steam游戏闪退"><a href="#玩Steam游戏闪退" class="headerlink" title="玩Steam游戏闪退"></a>玩Steam游戏闪退</h1><p>最近用刚配的电脑打游戏，有一些游戏总是玩着玩着就突然闪退到桌面了，而且没有任何报错信息<br>总结了一下，目前碰到的闪退的游戏比如求生之路2(L4D2)，巫师1(Witcher1)，都是十几年前的老游戏了，虽然最近爆出了 Intel CPU 的13代和14代处理器出现了问题，虽然目前没有碰到什么比较严重的问题，比如经常蓝屏什么的，但玩游戏老是冷不丁的闪退也很烦人，所以尝试解决这个问题</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>这次是碰到了鬼泣4特别版(Devil May Cry 4 Special Edition)打不开的问题，不是玩一半闪退，而是打开游戏后，弹了个游戏窗口瞬间闪退回桌面，而且也没有任何报错信息<br>在尝试了网络上和Steam讨论区里的解决方案后，都无法打开游戏<br>于是只能尝试从 CPU 上找解决方法</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我的主板是华硕的吹雪板，所以这个解决方法对于华硕主板来说是可能有用的<br>开机时，按 F2 键进入BIOS，按 F7 进入高级模式，找到 ASUS Multicore Enhancement，将其改为 Disabled，保存并重启<br>尝试打开游戏<br><img src="/img/2024-8-1-1.png" alt="游戏启动成功"></p><h1 id="问题原因猜测"><a href="#问题原因猜测" class="headerlink" title="问题原因猜测"></a>问题原因猜测</h1><p>我猜测可能是因为老游戏和 CPU 不适配，CPU 的频率太高，导致的游戏崩溃，关闭 MCE 就好了<br>当然也可能是老游戏是32位的，而 CPU 是64位的，Windows10 的兼容不好导致的<br>希望此番设置，机魂可以大悦</p><hr><p>最近和朋友玩求生之路2，老是玩着玩着就闪退了，经过这个设置的修改，希望以后可以不要闪退了ヽ(ー_ー )ノ</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU</tag>
      
      <tag>crash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux搭建tModLoader服务器并添加mod</title>
    <link href="/2024/07/12/Linux%E6%90%AD%E5%BB%BAtModLoader%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E6%B7%BB%E5%8A%A0mod/"/>
    <url>/2024/07/12/Linux%E6%90%AD%E5%BB%BAtModLoader%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E6%B7%BB%E5%8A%A0mod/</url>
    
    <content type="html"><![CDATA[<h1 id="泰拉瑞亚mod服务器"><a href="#泰拉瑞亚mod服务器" class="headerlink" title="泰拉瑞亚mod服务器"></a>泰拉瑞亚mod服务器</h1><p>塔拉瑞亚原版服务器不支持添加mod，所以如果想要自建一个泰拉瑞亚的mod服务器的话，就需要使用开源的<a href="https://github.com/tModLoader/tModLoader">tModLoader</a>来实现</p><span id="more"></span><h1 id="自建tModLoader服务器"><a href="#自建tModLoader服务器" class="headerlink" title="自建tModLoader服务器"></a>自建tModLoader服务器</h1><p>首先下载tModloader的源代码，在 GitHub 的 Releases 里下载最新的版本，并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/tModLoader/tModLoader/releases/download/v2024.05.3.3/tModLoader.zip<br><br>unzip -d tModLoader tModLoader.zip<br></code></pre></td></tr></table></figure><p>安装 tmux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S tmux<br></code></pre></td></tr></table></figure><p>创建一个 tmux 会话，并进入到 tModLoader 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux new -s tModLoader<br>cd tModLoader<br></code></pre></td></tr></table></figure><p>启动 tModLoader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash start-tModLoaderServer.sh<br></code></pre></td></tr></table></figure><p>然后根据输出的提示，创建新世界，运行创建好的世界，设置服务器的端口和密码，然后用快捷键 <code>Ctrl + b</code>，<code>d</code> 让 tmux 在后台运行<br>要联机的玩家通过客户端的 tModLoader 就可以进入到服务器中一起玩耍了</p><p>至此，一个纯净的、无mod的泰拉瑞亚服务器就搭建完成了</p><h1 id="添加mod"><a href="#添加mod" class="headerlink" title="添加mod"></a>添加mod</h1><p>为了让所有人都可以运行mod，服务器端和客户端都要安装相同的 mod 才可以正常游玩<br>首先在 Steam 上进入到 tModLoader 的创意工坊，订阅自己想要的 mod，等待 mod 安装完成后，找到游戏 mod 的安装路径，这个路径可以进入游戏中，在管理 mod 中找到<br>此处会找到两个目录，一个是存储 mod 文件的目录，一个是设置是否运行 mod 的配置文件路径(enabled.json文件)</p><p>将需要安装到服务器端的 mod 上传到服务器的 <code>$HOME/.local/share/Terraria/tModLoader/Mods/</code> 目录下，注意 mod 是以 <code>.tmod</code> 为后缀的<br>将 <code>enabled.json</code> 文件的内容拷贝到服务器的 <code>$HOME/.local/share/Terraria/tModLoader/Mods/enabled.josn</code> 文件中<br>如果服务器端和客户端要运行的 mod 是一样的，则不需要修改，若不一样，则修改为需要在服务器端运行的 mod 即可</p><p>设置完成后，重新运行 tModLoader，如果在启动过程中的日志中看到了加载 mod 的输出，则说明 mod 安装成功，可以愉快的游玩了</p><p>enjoy it~</p><hr><p>总体来说，自建泰拉瑞亚服务器和自建 Minecraft 服务器都差不多，配置好服务器端，然后服务器端和客户端都安装相同的 mod，然后就可以一起联机游玩了<br>当然这些都要感谢那些为此贡献了开源代码的开源项目，不然自建服务器也不会这么简单就实现了__φ(．．;)</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Server</tag>
      
      <tag>Terraria</tag>
      
      <tag>tModLoader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组装了一台电脑</title>
    <link href="/2024/06/24/%E7%BB%84%E8%A3%85%E4%BA%86%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91/"/>
    <url>/2024/06/24/%E7%BB%84%E8%A3%85%E4%BA%86%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91/</url>
    
    <content type="html"><![CDATA[<h1 id="618-的时候自己组装了一台电脑"><a href="#618-的时候自己组装了一台电脑" class="headerlink" title="618 的时候自己组装了一台电脑"></a>618 的时候自己组装了一台电脑</h1><p>大学期间，一直有自己组装一台电脑的想法，所以一直有存钱的想法，但是钱要么是有什么突发状况需要用钱，导致一次清空，要么就是为了其他更重要的东西而付钱，导致一直没能存下多少钱，所以这个想法一直没能实现<br>就这样一直到了大四毕业，我的电脑还是停留在想象阶段<br>都已经大学毕业了，怎么一台性能可以满足我基本的游戏需求的电脑都没有呢？于是我找了各种方法扣钱出来，其中还包括考上研究生的奖学金，变卖了一个手办(不是尼禄的，尼禄的手办怎么能卖呢!)总算凑齐了足够的钱，可以开始配置我的电脑了</p><span id="more"></span><h1 id="配置选取"><a href="#配置选取" class="headerlink" title="配置选取"></a>配置选取</h1><p>主要还是靠微信小程序的装机助手完成的，不过一开始我就已经有显卡用4070，CPU用i7-14700k，主板用z790的想法了，所以配置选择起来就很快，再加上平时在B站上看的测评视频，配置很快就选好了，这里罗列一下我的配置</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">CPU: i7-14700k<br>主板: ROG/STRIX Z790-A GAMING WIFI S 吹雪主板<br>GPU: 七彩虹/iGame RTX 4070 Super Ultra<br>内存: 七彩虹/32GB DDR5 6400<br>硬盘: 三星990 Pro 1TB SSD + 希捷1TB SSD<br>电源: 七彩虹/CF-850W 全模组电源<br>散热: 利民/AQUA ELITE 360 水冷散热<br>机箱: 爱国者海景房<br>机箱风扇: 爱国者极光Z12<br>显示器: 联想/Y27q-30<br>硅脂: 利民/TF9<br>贴纸: 尼禄贴纸(由于预算不够，就没有选择定制机箱，用贴纸代替吧)<br></code></pre></td></tr></table></figure><h1 id="配置组装"><a href="#配置组装" class="headerlink" title="配置组装"></a>配置组装</h1><p>从下单到配件全齐也就用了两到三天，开始着手安装吧<br>由于是第一次装机，没有什么经验，所以安装了一下午，装机的每一步都是按照B站UP主<a href="https://www.bilibili.com/video/BV1BG4y137mG/?share_source=copy_web&vd_source=80011aac86bf19cbb77445c06a6d2e4b">硬件茶谈的视频</a>来操作的<br>从CPU的安装到最后的第一次点亮，都是靠着这个视频来操作的，最终一次点亮，开机自动进入到了主板的BIOS界面<br>来看看我的主机吧(￣∇￣)<br><img src="/img/2024-6-24-1.jpg" alt="尼禄真是太可爱了{*≧∀≦}"><br><img src="/img/2024-6-24-2.jpg" alt="吹雪姬也很可爱(o^∀^)"></p><p>不过电脑组装起来不难，难的是怎么理线让机箱看起来好看，光理线这一步就用了我一个多小时，风扇是拆了装装了拆，好几个线的的接口也是换了又换，最终才达到了我想要的效果</p><h1 id="系统选择"><a href="#系统选择" class="headerlink" title="系统选择"></a>系统选择</h1><p>其实一开始是有装 Arch Linux 的想法的，但是考虑到 Nvidia 的驱动问题，所以就放弃了(So, Nvidia F*ck You!)<br>装Windows就太简单了，我装了个 Windows 10的系统，毕竟用 Windows 系统也少，用的最多的也就是 Windows 10了<br>直接去微软的官网下载<a href="https://www.microsoft.com/zh-cn/software-download/windows10">启动盘制作器</a>制作一个启动盘就好了，当然也可以用 <a href="https://github.com/ventoy/Ventoy">Ventoy</a> 来安装，这个更简单更方便</p><hr><p>安装好系统，就可以安装游戏，开始我的游戏之旅了ヽ(´▽｀；)&#x2F;♪<br>多年未实现的梦想，总算在今天实现了，感慨万分，于是我激动的用我新配的电脑启动了第一个游戏———————–<br>《魔女的夜宴》─&#x3D;≡Σ ﾍ( ´Д&#96;)ﾉ</p>]]></content>
    
    
    <categories>
      
      <category>闲话</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PC</tag>
      
      <tag>cliche</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 搭建Minecraft服务器并添加Mod</title>
    <link href="/2024/05/18/Linux-%E6%90%AD%E5%BB%BAMinecraft%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E6%B7%BB%E5%8A%A0Mod/"/>
    <url>/2024/05/18/Linux-%E6%90%AD%E5%BB%BAMinecraft%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E6%B7%BB%E5%8A%A0Mod/</url>
    
    <content type="html"><![CDATA[<h1 id="应各群友要求，搭建一个Minecraft服务器"><a href="#应各群友要求，搭建一个Minecraft服务器" class="headerlink" title="应各群友要求，搭建一个Minecraft服务器"></a>应各群友要求，搭建一个Minecraft服务器</h1><p>最近群友们突然想玩 Minecraft 了，刚好最近 Minecraft 也在打折，所有有一起联机的打算<br>纯净版的 Minecraft 很快就会玩腻来，所以要搭服务器，当然是直接搭一个 Forge 服务器啦</p><span id="more"></span><h1 id="服务器搭建"><a href="#服务器搭建" class="headerlink" title="服务器搭建"></a>服务器搭建</h1><p>服务端搭建起来很简单，首先服务器的官方配置要求是2核4G内存，自己去各大云服务场商那里买就好了</p><h2 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h2><p>Minecraft 默认的端口是25565，所以需要修改一下防火墙，允许从外部连接这个端口<br>或者自行设置端口，防火墙开启对应的端口即可</p><h2 id="下载-Forge"><a href="#下载-Forge" class="headerlink" title="下载 Forge"></a>下载 Forge</h2><p>首先去 <a href="https://files.minecraftforge.net/net/minecraftforge/forge/">Forge</a> 下载想要的 Minecraft 版本的 Forge<br>这里我下载的是 1.7.10 版本 Minecraft 的 Forge<br><img src="/img/2024-5-18-1.png"></p><h2 id="安装-Forge"><a href="#安装-Forge" class="headerlink" title="安装 Forge"></a>安装 Forge</h2><p>首先在服务器上安装 Java</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt update &amp;&amp; apt upgrade -y &amp;&amp; apt install openjdk-8-jre<br></code></pre></td></tr></table></figure><p>验证安装是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure><p>如果输出了 Java 版本，则表示安装成功</p><p>在服务器上创建一个目录，然后把下载的 Forge 的 jar 包上传到这个目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/minecraft-server<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp forge-1.7.10-10.13.4.1614-1.7.10-installer.jar User@IP:/path/to/minecraft-server/<br></code></pre></td></tr></table></figure><p>服务器上安装 Forge</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar forge-1.7.10-10.13.4.1614-1.7.10-installer.jar --installServer<br></code></pre></td></tr></table></figure><p>等待安装好后，运行服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar forge-1.7.10-10.13.4.1614-1.7.10-universal.jar --nogui<br></code></pre></td></tr></table></figure><p>第一次运行肯定会安装失败，因为这回生成一份协议，要求阅读后方可继续<br>修改 <code>eula.txt</code> 文件，将其中的 <code>eula</code> 的值修改为 <code>true</code></p><p>这样就可以再次启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar forge-1.7.10-10.13.4.1614-1.7.10-universal.jar --nogui<br></code></pre></td></tr></table></figure><p>等待世界生成完成后，就可以开始与群友们一起联机了</p><h2 id="安装-Mod"><a href="#安装-Mod" class="headerlink" title="安装 Mod"></a>安装 Mod</h2><p>Mod 的安装非常简单，只需要把需要的 Mod 的 jar 文件放在服务器的 <code>mods</code> 目录下即可<br>Mod 文件可以在 <a href="https://www.mcmod.cn/modlist.html">MC百科</a> 中下载</p><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>安装 <code>tmux</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install tmux<br></code></pre></td></tr></table></figure><p>运行 tmux，直接在命令行输入 <code>tmux</code> 即可<br>打开 tmux 后，开始运行服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar forge-1.7.10-10.13.4.1614-1.7.10-universal.jar --nogui<br></code></pre></td></tr></table></figure><p>运行完成后，<code>Ctrl</code> + <code>b</code> 后再输入 <code>d</code> 即可使该窗口后台执行，关闭ssh连接后也可以继续运行</p><h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><p>网上大都是教如何在 Windows 上使用 Mod，我这里就演示个讲的比较少的，如何在 Linux 上使用 Mod 吧(Windows 连接同理，只有小部分不一样)<br>由于服务端使用了 Forge，所以客户端也需要安装 Forge，下载地址和上面一样，都是<a href="https://files.minecraftforge.net/net/minecraftforge/forge/">Forge</a>，版本要和服务端一致</p><p>下载好后，运行命令，或者直接双击安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar forge-1.7.10-10.13.4.1614-1.7.10-installer.jar<br></code></pre></td></tr></table></figure><p>选择安装 client 即可<br><img src="/img/2024-5-18-2.png"></p><p>将 Mod 的 jar 包放到安装目录下的 <code>mods</code> 目录下</p><p>打开 Minecraft-launcher，配置选择刚才安装的 Forge<br><img src="/img/2024-5-18-3.png"></p><p>然后就可以愉快的开始游戏了<br>enjoy it~</p><hr><p>因为之前搭建过泰拉瑞亚的服务器，所以觉得 Minecraft 服务器搭建起来不会很难<br>果不其然，搭建起来十分顺畅，没有碰到什么障碍<br>会不会是我的技术能力提高了呢 －＝≡ヘ(*・ω・)ノ</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Server</tag>
      
      <tag>Forge</tag>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KDE 磁盘占用高</title>
    <link href="/2024/05/11/KDE-%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E9%AB%98/"/>
    <url>/2024/05/11/KDE-%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E9%AB%98/</url>
    
    <content type="html"><![CDATA[<h1 id="KDE-磁盘占用高"><a href="#KDE-磁盘占用高" class="headerlink" title="KDE 磁盘占用高"></a>KDE 磁盘占用高</h1><p>昨天拿 Linux 玩游戏(当然拿 Linux 玩游戏有点强人所难，Linux 拿 wine 玩玩 galgame 就够了)，发现游戏运行地异常慢，电脑也非常烫手<br>所以我看了一下电脑的各项数据，发现了磁盘占用过高，于是尝试解决，最终找到的罪魁祸首就是 Baloo<br><img src="/img/2024-5-11-1.png" alt="磁盘高速运行"></p><span id="more"></span><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>我先查看了 <code>htop</code>，调到 IO 项查看，发现有一个进程的 IO 特别高<br><img src="/img/2024-5-11-2.png" alt="htop"></p><p>由于一开始不知道这是什么进程，不敢随意乱关闭，不过一开始也没过它是病毒，比较它的路径里有 kf6 的字样，那应该就是 KDE 的问题了<br>于是去 <a href="https://wiki.archlinuxcn.org/wiki/Baloo">wiki</a> 上查了一下这个进程，发现这只是个文件检索功能，用来快速搜索文件<br>比如打开 Dolphin 时为了展示文件，会需要用到它，krunner 也是<br>所以可以放心关闭它，除了使用过程中一些功能不能用到，其他功能都可以正常使用</p><p>关闭 baloo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">balooctl6 disable<br></code></pre></td></tr></table></figure><p>启动 baloo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">balooctl6 enable<br></code></pre></td></tr></table></figure><p>禁用 baloo 后，磁盘的占用就下降了<br><img src="/img/2024-5-11-3.png"></p><h1 id="添加排除路径"><a href="#添加排除路径" class="headerlink" title="添加排除路径"></a>添加排除路径</h1><p>后面我去看了一下 KDE <a href="https://community.kde.org/Baloo/Configuration">官方的文档</a>，发现了一个更好的方法解决方法，就是添加排除路径<br>编辑 <code>~/.config/baloofilerc</code> 文件，在 <code>[General]</code> 下添加配置</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">exclude folders[$e]=$HOME/FolderA,$HOME/FolderB<br></code></pre></td></tr></table></figure><p>然后重启一下 Baloo 就好了</p><h1 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h1><p>前面说了，这是个文件搜索工具，所以它需要扫描整个文件系统，我猜测，以前没有发生这种问题的原因应该是系统中的文件数量少，所以它很快就完成了工作<br>但是由于最近在做毕业设计，用到了 YOLO 来训练模型，电脑里面存了大量的图片，所以它在扫描整个文件系统上花费了大量的时间<br>解决 Baloo 占用过高的问题，可以尝试减少系统中的文件数量</p><hr><p>博客有一年多没有怎么好好更新了，去年是准备考研，最近录取结果出来了，成功上岸<br>最近半年也是在准备考研复试和毕业设计，所有又没时间，现在终于有时间好好的学点自己想学的东西了<br>不过今年放假想配一台电脑打游戏，不知道还会不会腾出时间来呢 ε&#x3D;ε&#x3D;┌( &gt;_&lt;)┘</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArchLinux</tag>
      
      <tag>KDE</tag>
      
      <tag>Baloo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jetson tx2安装Ubuntu18.04踩坑记录</title>
    <link href="/2024/02/25/Jetson-tx2%E5%AE%89%E8%A3%85Ubuntu18-04%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/02/25/Jetson-tx2%E5%AE%89%E8%A3%85Ubuntu18-04%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="珍爱生命，远离tx2"><a href="#珍爱生命，远离tx2" class="headerlink" title="珍爱生命，远离tx2"></a>珍爱生命，远离tx2</h1><p>最近为了毕设入了块 NVIDIA 的 Jetson tx2<br>刚到手就开始刷机，因为之前借别人的 Jetson tx1 的 Ubuntu 版本的是 16.04，这个版本太老了，有很多依赖问题，所以想着刷个 Ubuntu 18.04 到这块板子上<br>于是跟着网上找的别人的博客和官方文档，踩了两天的坑，总算是完成安装了<br>因此写下此篇博客以记录如何解决已经碰到的问题</p><span id="more"></span><h1 id="配置虚拟机"><a href="#配置虚拟机" class="headerlink" title="配置虚拟机"></a>配置虚拟机</h1><p>为了方便，我用的虚拟机，如果是直接用 PC 那更好</p><p>虚拟机要求如下:</p><ul><li>VMware (一定要 VMware，用 VirtualBox 会卡在刷系统的步骤)</li><li>网络类型为桥接(bridged)</li><li>Ubuntu 18.04 (因为要在 tx2 上安装ubuntu 18，所以虚拟机的版本也要是18的)</li><li>内存 &gt;&#x3D;8GB</li><li>存储 &gt;&#x3D; 100GB</li></ul><h1 id="安装-SDK-Manager"><a href="#安装-SDK-Manager" class="headerlink" title="安装 SDK Manager"></a>安装 SDK Manager</h1><p>安装好虚拟机后，首先更换软件源为<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华软件源</a>，并更新软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update &amp;&amp; sudo apt upgrade<br></code></pre></td></tr></table></figure><p>然后下载 <a href="https://developer.nvidia.com/sdk-manager">SDK Manager</a>，将下载到的 deb 包传输到虚拟机中，安装该软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo dkpk --install sdkmanager_&lt;VERSION&gt;_amd64.deb<br></code></pre></td></tr></table></figure><p>如果碰到以下报错，说明是缺少了依赖</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">dpkg: dependency problems prevent configuration of sdkmanager:<br> sdkmanager depends on libgconf-2-4; however:<br>  Package libgconf-2-4 is not installed.<br> sdkmanager depends on libcanberra-gtk-module; however:<br>  Package libcanberra-gtk-module is not installed.<br></code></pre></td></tr></table></figure><p>安装所需的软件即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install libcanberra-gtk-module<br></code></pre></td></tr></table></figure><p>如果继续出错</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">You might want to run &#x27;apt --fix-broken install&#x27; to correct these.<br>The following packages have unmet dependencies:<br> libcanberra-gtk-module : Depends: libcanberra-gtk0 (&gt;= 0.2) but it is not going to be installed<br> sdkmanager : Depends: libgconf-2-4 but it is not going to be installed<br>E: Unmet dependencies. Try &#x27;apt --fix-broken install&#x27; with no packages (or specify a solution).<br></code></pre></td></tr></table></figure><p>则继续修复即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt --fix-broken install<br></code></pre></td></tr></table></figure><p>然后重新安装即可</p><h1 id="给-Jetson-tx2-刷机"><a href="#给-Jetson-tx2-刷机" class="headerlink" title="给 Jetson tx2 刷机"></a>给 Jetson tx2 刷机</h1><p>打开 SDKManager，登陆 NVIDIA 账号，使用 Micro USB 连接电脑与 Jetson tx2<br>此时 SDKManager 会自动识别到开发板，按照下图全部都勾选上<br><img src="/img/2024-2-25-1.png"></p><p>如果没有识别，可以使开发板进入恢复模式:</p><ul><li>先给开发板断电</li><li>按下开发板电源键</li><li>按住 RECOVER 键</li><li>按一下 RESET 键</li><li>松开 RECOVER 键</li></ul><p>如果还是没有识别到，先在电脑上查看是否连接到了开发板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsusb<br></code></pre></td></tr></table></figure><p>查看是否有如下字样</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">NVIDIA Corp. T186 [TX2 Tegra Parker] recovery mode<br></code></pre></td></tr></table></figure><p>如果有，则参考 <a href="https://wiki.archlinux.org/title/VMware#USB_devices_not_recognized">Arch Wiki</a>，开启 VMware 的 USB 功能即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vmware-usbarbitrator #开启<br><br>sudo vmware-usbarbitrator --kill #关闭<br></code></pre></td></tr></table></figure><p>然后设置虚拟机的 USB 即可<br><img src="/img/2024-2-25-2.png"></p><p>SDKManager 识别到 Jetson tx2 后，下一步开始安装即可<br><img src="/img/2024-2-25-3.png"></p><p>刷写过程中，会提示设置新系统的用户名和密码，别忘了</p><p>在系统刷写完成后，此时开发板与虚拟机的连接已经可以断开，后面安装 CUDA 等组件可以通过网络来安装<br>在开始安装组件之前，先给开发板连接屏幕和键鼠，用刚刚设置的密码登陆近系统，查看一下开发板的 IP 地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br></code></pre></td></tr></table></figure><p>查看是否有自动分配的 <code>IP</code> 地址 <code>192.168.55.1</code>，如果有，则继续安装剩下的组件</p><p>经过一段时间的等待，系统及组件成功安装，重启开发板，关闭虚拟机就大功告成了</p><p>开发板重启后，登陆开发板，查看 Ubuntu 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsb_release -a<br></code></pre></td></tr></table></figure><p>Ubuntu 18 系统安装完成</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">Distributor ID: Ubuntu<br>Description:    Ubuntu 18.04.6 LTS<br>Release:        18.04<br>Codename:       bionic<br></code></pre></td></tr></table></figure><hr><p>为了给这个开发板安装系统，熬了一个晚上，天气还冷，躺在被窝里一个多小时才暖和起来，差点以为人要没了(x_x)⌒☆<br>不过这块开发板的 SD 卡可以正确识别，相较于借来的 Jetson tx1 来说，算是捡到宝了，毕竟是从咸鱼上买的二手的(★≧▽^))★☆</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Jetson tx2</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决pip3安装依赖时SSL问题</title>
    <link href="/2024/01/12/%E8%A7%A3%E5%86%B3pip3%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E6%97%B6SSL%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/12/%E8%A7%A3%E5%86%B3pip3%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E6%97%B6SSL%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="踩了个巨坑"><a href="#踩了个巨坑" class="headerlink" title="踩了个巨坑"></a>踩了个巨坑</h1><p>今天开始学习 PyTorch，在安装环境的时候，需要用到 <code>pip3</code> 安装 PyTorch<br>本来是一件很简单的事，一条命令就可以搞定，没想到碰到了如下报错</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;SSLError(&quot;Can&#x27;t connect to HTTPS URL because the SSL module is not available.&quot;)&#x27;: /whl/cu90/torch/<br></code></pre></td></tr></table></figure><p>意思是说因为 SSL 错误导致安装无法进行下去，没办法，只好开始Google之旅，找了中文的英文的解决方法，要么是复制粘贴的，要么是无法解决的，最后花了几个小时，终于解决了，于是写一篇踩坑记录记录下来</p><span id="more"></span><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>之所以会碰到 PyTorch 安装失败，有几个原因</p><ul><li>OpenSSL 版本过低，Linux自带的版本是1.0.1的版本，需要至少1.1.1的版本</li><li>Python 版本，需要在3.8-3.11之间</li><li>未正确将SSL编译进Python</li></ul><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>如果不是必要，保留 Linux 自带的 OpenSSL，否则可能出现各种依赖问题<br>首先要编译 OpenSSL，下载 OpenSSL 安装包，并解压，进入解压后的目录内</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.openssl.org/source/openssl-1.1.1w.tar.gz<br>tar -xvzf openssl-1.1.1w.tar.gz<br>cd openssl-1.1.1w<br></code></pre></td></tr></table></figure><p>编译并安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./config --prefix=/usr/local/ssl --openssldir=/usr/local/ssl no-zlib<br>make install<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/ld.so.conf</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;/usr/local/ssl/lib&quot; &gt;&gt; /etc/ld.so.conf<br>ldconfig -v<br></code></pre></td></tr></table></figure><p>重命名原来的OpenSSL文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv -f /usr/bin/openssl /usr/bin/openssl.old<br></code></pre></td></tr></table></figure><p>修改软链，指向新版本的OpenSSL路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/local/ssl/bin/openssl /usr/bin/openssl<br></code></pre></td></tr></table></figure><p>可以测试一下是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl version<br></code></pre></td></tr></table></figure><p>重新编译 Python，如果要安装 PyTorch，Python 的版本要在3.8-3.11之间<br>下载源码包，并解压缩，进入解压后的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.python.org/ftp/python/3.8.18/Python-3.8.18.tar.xz<br>tar -xvf Python-3.8.18.tar.xz<br>cd Python-3.8.18<br></code></pre></td></tr></table></figure><p>编辑 <code>Modules/Setup</code> 文件(很重要)，修改如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs conf"># Socket module helper for socket(2)<br>_socket socketmodule.c # 取消注释<br><br># Socket module helper for SSL support; you must comment out the other<br># socket line above, and possibly edit the SSL variable:<br>SSL=/usr/local/ssl # 修改为编译 OpenSSL 时设置的目录<br>_ssl _ssl.c \<br>        -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \<br>        -L$(SSL)/lib -lssl -lcrypto<br></code></pre></td></tr></table></figure><p>编译 Python</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>编译 <code>make</code> 之后，输出信息里面可能出现 <code>_ctypes</code> 模块编译失败，这可能会导致后面引入 <code>PyTorch</code> 时出现错误，所以可以安装 <code>libffi-dev</code> 后，重新编译并安装一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs `shell">apt install libffi-dev<br></code></pre></td></tr></table></figure><p>这样就可以愉快的安装 PyTorch 了，注意版本到官网上去找对应的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu90<br></code></pre></td></tr></table></figure><hr><p>今天真的是踩了个大坑，本来还想从今天开始学习 PyTorch 呢，没想到搭建环境这一关就给我来了个下马威 ＼(º □ º l|l)&#x2F;<br>今天把环境搭建起来了，明天再开始学习 PyTorch，开始准备毕设吧─&#x3D;≡Σ((( つ＞＜)つ</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>OpenSSL</tag>
      
      <tag>pip3</tag>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VirtualBox无法识别U盘</title>
    <link href="/2024/01/08/VirtualBox%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABU%E7%9B%98/"/>
    <url>/2024/01/08/VirtualBox%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABU%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="VirtualBox无法识别U盘"><a href="#VirtualBox无法识别U盘" class="headerlink" title="VirtualBox无法识别U盘"></a>VirtualBox无法识别U盘</h1><p>今天想着在U盘中安装一个 Ubuntu 系统的，但是没有额外的U盘，所以不能直接用启动盘安装<br>于是找到了用 VirtualBox 安装的方法<br>但是不知道为什么，VirtualBox 一直无法识别到U盘，导致无法进行下去<br>最后还是在仔细阅读 wiki 后才把问题解决</p><span id="more"></span><h1 id="VirtualBox-增强版"><a href="#VirtualBox-增强版" class="headerlink" title="VirtualBox 增强版"></a>VirtualBox 增强版</h1><p>VirtualBox 识别 USB 的功能不是自带的，需要安装第三方的增强包才能使用<br>而 aur 中已经有现成的包，可以直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay virtualbox-ext-oracle<br></code></pre></td></tr></table></figure><p>安装好后，重启系统 <code>reboot</code>，再打开 VirtualBox 就可以正确识别到插入的U盘了<br><img src="/img/2024-1-8-1.png"></p><h2 id="可能碰到的报错"><a href="#可能碰到的报错" class="headerlink" title="可能碰到的报错"></a>可能碰到的报错</h2><p>我在安装后想要插入U盘到虚拟机中时，遇到了依然无法识别的问题，仔细看报错信息是 <code>Error: VERR_PDM_NO_USB_PORTS</code><br>这是因为 USB 的控制器选择不对的问题，修改为 <code>USB 3.0 Controller</code> 即可<br><img src="/img/2024-1-8-2.png"></p><hr><p>开始准备毕设了，第一步先把环境搭建好吧(&#x2F;・・)ノ</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArchLinux</tag>
      
      <tag>VirtualBox</tag>
      
      <tag>USB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tailscale+headscale+derper+acme内网穿透</title>
    <link href="/2024/01/05/tailscale-headscale-derper-acme%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2024/01/05/tailscale-headscale-derper-acme%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="内网穿透的方法更改"><a href="#内网穿透的方法更改" class="headerlink" title="内网穿透的方法更改"></a>内网穿透的方法更改</h1><p>之前一直是用 <code>frp</code> 作为内网穿透的工具，用起来的有一些不方便的地方，但是总比没有强<br>最近研究生考试刚结束，期末考试也结束了，留在学校没事干，就用 <code>frp</code> 内网穿透看放在家里的 NAS 上的番剧<br>就这么看了几天，突然脑子转过来了，查了一下用作中转服务的服务器的流量，这不看不知道，一看吓一跳，短短几天用掉了100-200G的流量，这我怎么受得了<br>于是我就找到了之前看到过的 <code>ZeroTier</code>，在一个国内的服务器上搭建后，虽然内网穿透是实现了，但是走的是中转流量，这不还是要用掉大量的流量看番吗？？？<br>随即放弃 <code>ZeroTier</code> 方案，于是就找到了 <code>tailscale</code><br><code>tailscale</code> 用起来挺不错的，只是它的服务器搭建在国外，国内没有，所以速度会很慢，于是就想着自己搭建一个国内的管理器</p><span id="more"></span><h1 id="前提知识储备"><a href="#前提知识储备" class="headerlink" title="前提知识储备"></a>前提知识储备</h1><p>tailscale的工作由协调服务器和中转服务器完成，协调服务器用于让已验证的tailscale客户端建立p2p连接，中转服务器用于保证连接的正常进行<br>在网络通畅的情况下，协调服务器会让两个tailscale客户端完成p2p连接的建立，两台客户端建立连接完成后，就可以愉快的进行数据交换了，没有中转服务器的事，但是问题就是出在这，如果p2p连接建立失败，那么就需要中转服务器进行中转，以达到连接建立的目的<br>如果直接使用tailscale官方的服务，那么什么都不需要搭建，安装好tailscale客户端执行登录命令就可以连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tailscale up<br></code></pre></td></tr></table></figure><p>但是，如果不想使用tailscale官方的服务，那么就需要自己搭建了<br>此处搭建的中转服务器就是DERP服务，协调服务器就是headscale服务器</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>我用的方案是最简单的方案，一台derper服务器，一台headscale，分别搭建在两个VPS上，这样不容易产生端口冲突的问题(因为我碰到了这样的问题)，于是先准备如下材料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs item">域名*1   derper搭建时需要<br>VPS*2   一台用作搭建derper，一台用作搭建headscale<br>Linux客户端   用作tailscale客户端<br></code></pre></td></tr></table></figure><p>域名可以在<a href="https://www.namesilo.com/">namesilo</a>上购买，一个 <code>.top</code> 的域名也就1、2美元一年<br>并创建一个 <code>A</code> 记录指向用于搭建derper的服务器的IP地址</p><p>搭建derper的服务器放行 <code>3478(UDP)</code> 端口，放行任意一个高位 <code>TCP</code> 端口(此处我使用的是12150端口)<br>搭建headscale服务器放行任意一个高位 <code>TCP</code> 端口(此处我用的是37125端口)</p><h1 id="搭建derp服务"><a href="#搭建derp服务" class="headerlink" title="搭建derp服务"></a>搭建derp服务</h1><p>derper服务需要使用域名，虽然有不使用域名的方案，但是我还没用，先要域名解析到derper服务器</p><h2 id="acme-申请证书"><a href="#acme-申请证书" class="headerlink" title="acme 申请证书"></a>acme 申请证书</h2><p>安装acme.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl  https://get.acme.sh | sh<br></code></pre></td></tr></table></figure><p>安装 socat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt update &amp;&amp; apt upgrade &amp;&amp; apt install socat -y<br></code></pre></td></tr></table></figure><p>使用acme申请letsencrypt免费证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/.acme.sh/acme.sh --issue -d 域名 --standalone -k ec-256 --server letsencrypt<br></code></pre></td></tr></table></figure><p>创建 <code>/opt/derper</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /opt/derper<br></code></pre></td></tr></table></figure><p>并导出证书到此处</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/.acme.sh/acme.sh --installcert -d 域名 --fullchainpath /opt/derper/域名.crt --keypath /opt/derper/域名.key --ecc<br></code></pre></td></tr></table></figure><h2 id="安装golang"><a href="#安装golang" class="headerlink" title="安装golang"></a>安装golang</h2><p>按照 <a href="https://go.dev/">go.dev</a> 官网的方法，安装最新的golang<br>下载最新的golang包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://go.dev/dl/go1.24.2.linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>删除可能残留的golang并安装最新的golang</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.24.2.linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p>将golang添加到环境变量中，可以将下列语句添加到 <code>/etc/profile</code> 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$PATH:/usr/local/go/bin<br></code></pre></td></tr></table></figure><p>如果添加了，source一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure><p>查看是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go version<br></code></pre></td></tr></table></figure><h2 id="安装derp"><a href="#安装derp" class="headerlink" title="安装derp"></a>安装derp</h2><p>首先将derp项目拉到本地，同时会把已将编译好的二进制也拉过来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go install tailscale.com/cmd/derper@main<br></code></pre></td></tr></table></figure><p>将编译好的derp放到 <code>/opt/derper</code> 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp ~/go/bin/derper /opt/derper<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/systemd/system/derper.service</code> 文件，写入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=Start Derper<br>After=network.target<br>Wants=network.target<br>[Service]<br>User=root<br>Restart=always<br>ExecStart=/opt/derper/derper -hostname 域名 -a :12150 -http-port 12151 -certmode manual -certdir /opt/derper<br>RestartPreventExitStatus=1<br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>其中 <code>ExecStart</code> 中的 <code>-a</code> 后面的参数就是derper服务器防火墙需要放行的端口，而 <code>-http-port</code> 仅为了防止端口冲突，随便设置一个就好了，如果这个服务器是一个人用的，可以追加 <code>--verify-clients</code> 参数，只允许验证过的客户端使用这个derper服务器</p><p>启动并设置开机启动derp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable --now derper.service<br></code></pre></td></tr></table></figure><p>浏览器访问 <code>域名:12150</code> 可以看到derper搭建完成<br><img src="/img/2024-1-5-1.png"></p><h1 id="搭建headscale"><a href="#搭建headscale" class="headerlink" title="搭建headscale"></a>搭建headscale</h1><p>headscale是用于连接建立的服务器，流量要求比较小，搭建的headscale可以顺便安装一个ui，不过用处不大，命令行足够了</p><h2 id="安装headscale服务"><a href="#安装headscale服务" class="headerlink" title="安装headscale服务"></a>安装headscale服务</h2><p>在<a href="https://github.com/juanfont/headscale/releases">headscale release</a>中找到适合的deb包，下载到服务器上</p><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/juanfont/headscale/releases/download/v0.25.1/headscale_0.25.1_linux_amd64.deb<br>dpkg --install headscale_0.25.1_linux_amd64.deb<br></code></pre></td></tr></table></figure><p>设置开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable headscale.service<br></code></pre></td></tr></table></figure><h2 id="修改headscale配置文件"><a href="#修改headscale配置文件" class="headerlink" title="修改headscale配置文件"></a>修改headscale配置文件</h2><p>编辑 <code>/etc/headscale/config.yaml</code> 文件，修改如下配置，端口记得防火墙放行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yamml">server_url: http://本服务器IP地址:37125<br></code></pre></td></tr></table></figure><h2 id="设置反向代理"><a href="#设置反向代理" class="headerlink" title="设置反向代理"></a>设置反向代理</h2><p>安装nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt update &amp;&amp; apt upgrade &amp;&amp; apt install nginx -y<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/nginx/sites-available/default</code> 文件，添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs conf">map $http_upgrade $connection_upgrade &#123;<br>        default keep-alive;<br>        &#x27;websocket&#x27;     upgrade;<br>        &#x27;&#x27;      close;<br>&#125;<br><br>server &#123;<br>        listen 37125;<br>        listen [::]:37125;<br>        server_name 本服务器的IP地址;<br>        location / &#123;<br>                proxy_pass http://127.0.0.1:8080;<br>                proxy_http_version 1.1;<br>                proxy_set_header Upgrade $http_upgrade;<br>                proxy_set_header Connection $connection_upgrade;<br>                proxy_set_header Host $server_name;<br>                proxy_buffering off;<br>                proxy_set_header X-Real-IP $remote_addr;<br>                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>                proxy_set_header X-Forwarded-Proto $http_x_forwarded_proto;<br>                add_header Strict-Transport-Security &quot;max-age=15552000; includeSubDomains&quot; always;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以启动nginx和headscale了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart nginx<br>systemctl restart headscale<br></code></pre></td></tr></table></figure><h2 id="headscale使用自己搭建的derp服务器"><a href="#headscale使用自己搭建的derp服务器" class="headerlink" title="headscale使用自己搭建的derp服务器"></a>headscale使用自己搭建的derp服务器</h2><p>编辑 <code>/etc/headscale/derp.yaml</code> 文件，添加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">regions:</span><br>  <span class="hljs-attr">901:</span><br>    <span class="hljs-attr">regionid:</span> <span class="hljs-number">901</span><br>    <span class="hljs-attr">regioncode:</span> <span class="hljs-string">DERP</span><br>    <span class="hljs-attr">regionname:</span> <span class="hljs-string">MYDERP</span><br>    <span class="hljs-attr">nodes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DERP_SERVER_1</span> <br>        <span class="hljs-attr">regionid:</span> <span class="hljs-number">901</span><br>        <span class="hljs-attr">hostname:</span> <span class="hljs-string">derper服务器的域名</span><br>        <span class="hljs-attr">stunport:</span> <span class="hljs-number">3478</span><br>        <span class="hljs-attr">stunonly:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">derpport:</span> <span class="hljs-number">12150</span><br><br></code></pre></td></tr></table></figure><p>再编辑 <code>/etc/headscale/config.yaml</code> 文件，修改如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 将官方的json配置注释掉，有自己的derp服务器就不用官方的了</span><br><span class="hljs-attr">urls:</span> []<br><span class="hljs-comment"># 使用刚才写好的配置</span><br><span class="hljs-attr">paths:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">/etc/headscale/derp.yaml</span><br></code></pre></td></tr></table></figure><p>重启headscale服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart headscale<br></code></pre></td></tr></table></figure><h1 id="tailscale客户端加入headscale中"><a href="#tailscale客户端加入headscale中" class="headerlink" title="tailscale客户端加入headscale中"></a>tailscale客户端加入headscale中</h1><p>headscale先创建用户，以便tailscale客户端注册验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">headscale user create &lt;username&gt;<br></code></pre></td></tr></table></figure><p>tailscale客户端执行如下命令加入headscale协调服务器中，并验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo tailscale up --login-server http://headscale的服务器的IP地址:37125<br></code></pre></td></tr></table></figure><p>这回跳出一个网址，复制该网址到浏览器打开，会获得一串验证密钥<br><img src="/img/2024-1-5-2.png"></p><p>在headscale端执行验证命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">headscale nodes register --user &lt;username&gt; --key &lt;key-string&gt;<br></code></pre></td></tr></table></figure><p>连接完成后，可以通过命令查看连接的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tailscale status<br>tailscale netcheck<br></code></pre></td></tr></table></figure><h1 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h1><p>如下是我碰到的几个问题以及它们的解决方案</p><h2 id="derper无法连接的问题"><a href="#derper无法连接的问题" class="headerlink" title="derper无法连接的问题"></a>derper无法连接的问题</h2><p>首先先看一下是否正确搭建了derper服务，如果都没问题，看看是否在搭建derper服务时，添加了 <code>--verify-clients</code> 参数<br>如果是因为添加了 <code>--verify-clients</code> 参数的原因导致的，那么 derper 服务器也安装 tailscale 并注册到 headscale 中就可以了</p><h2 id="DNS-覆盖-overwriting-问题"><a href="#DNS-覆盖-overwriting-问题" class="headerlink" title="DNS 覆盖(overwriting)问题"></a>DNS 覆盖(overwriting)问题</h2><p>目前只出现在了 Arch Linux 的 tailscale 客户端上，原因是 <code>dhcpcd</code> 服务器会修改 DNS 的配置导致的，所有做如下修改即可<br>不允许dhcpcd修改resolve.conf配置，修改 <code>/etc/dhcpcd.conf</code> 文件，添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">nohook resolv.conf<br></code></pre></td></tr></table></figure><p>重启dhcpcd服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart dhcpcd<br></code></pre></td></tr></table></figure><p>不允许NetworkManager修改resolve.conf配置，修改 <code>/etc/NetworkManager/NetworkManager.conf</code> 文件，添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">[main]<br>dns=none<br></code></pre></td></tr></table></figure><p>重启服务NetworkManager服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart NetworkManager<br></code></pre></td></tr></table></figure><p>让systemd-resolved来管理resolve.conf配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">ln -rsf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf<br>systemctl enable --now systemd-resolved<br></code></pre></td></tr></table></figure><p>重启tailscale服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart tailscaled<br></code></pre></td></tr></table></figure><hr><p>考完研了，又有大把的时间可以折腾了(ゝ∀･)b<br>该说折腾了个tailscale是省了流量吗，毕竟为了搭建tailscale用了整整3天，踩了好多的坑，做梦都在敲命令(☍﹏⁰)<br>然后折腾着折腾着，我已经到家了，不需要内网穿透，直接用内网就能不用流量开看了(｡ŏ_ŏ)<br>嘛，至少我有学会了个新技能不是吗<br>不过这个假期也不能全拿来折腾了，还得准备考研复试和毕业设计呢( º﹃º )</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>acme</tag>
      
      <tag>Tailscale</tag>
      
      <tag>Headscale</tag>
      
      <tag>Derper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新年第一篇博客</title>
    <link href="/2024/01/01/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/01/01/%E6%96%B0%E5%B9%B4%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="2024年到了"><a href="#2024年到了" class="headerlink" title="2024年到了"></a>2024年到了</h1><p>新的一年，新的生活，去年一年都在准备考研，博客都没怎么更了</p><span id="more"></span><h1 id="新年想法"><a href="#新年想法" class="headerlink" title="新年想法"></a>新年想法</h1><p>今年也是大学最后一年了，去年12月份参加了研究生考试，成绩还没出，不知道能不能成为一名研究生，让学生卡续期呢 ｡ﾟヽ(ﾟ´Д&#96;)ﾉﾟ｡</p><p>当然万一没考试，肯定得找工作啦，啃老是不可能的 ( •́ὤ•̀)</p><p>当然还得趁着过年放寒假这段时间学习毕设需要的知识，准备好毕业了呢，新年的事真多啊</p><p>虽然没什么人看我的博客，那就在这给自己说一声新年快乐吧~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Discord添加代理</title>
    <link href="/2023/10/27/Discord%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%90%86/"/>
    <url>/2023/10/27/Discord%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="桌面应用不走代理"><a href="#桌面应用不走代理" class="headerlink" title="桌面应用不走代理"></a>桌面应用不走代理</h2><p>最近在 Discord 聊天聊得很快乐，但是仅限于网页版，安装了客户端却一直无法打开，系统代理设置了还是不行<br>这里还得点名批评 Discord，居然没有设置代理的选项，所以找了别的方法成功进入了 Discord 客户端</p><span id="more"></span><h2 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h2><p>给 Discord 还是很简单的，进入目录 <code>usr/share/applications </code><br>编辑 <code>discord.desktop</code> 文件，修改 <code>Exec</code> 配置</p><p>在 <code>Exec</code> 后面添加一条代理命令 <code>--proxy-server=127.0.0.1:2020</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Desktop Entry]<br>Name=Discord<br>StartupWMClass=discord<br>GenericName=Internet Messenger<br>Exec=/usr/bin/discord --proxy-server=127.0.0.1:2020<br>Icon=discord<br>Type=Application<br>Categories=Network;InstantMessaging;<br>Path=/usr/bin<br></code></pre></td></tr></table></figure><p>这样在启动 Discord 的时候就会设置走代理，可以愉快的使用客户端了</p><hr><p>最近复习考研，学习新东西的精力全都放在了上面，博客也就这么停了好几个月<br>等考试结束了，再回到以前的折腾吧</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux蓝牙连接后立刻断开</title>
    <link href="/2023/07/01/Arch-Linux%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E5%90%8E%E7%AB%8B%E5%88%BB%E6%96%AD%E5%BC%80/"/>
    <url>/2023/07/01/Arch-Linux%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E5%90%8E%E7%AB%8B%E5%88%BB%E6%96%AD%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝牙耳机无法连接"><a href="#蓝牙耳机无法连接" class="headerlink" title="蓝牙耳机无法连接"></a>蓝牙耳机无法连接</h1><p>就在今天早上，我用我的蓝牙耳机连接上我的电脑打算开始学习，没想到我的耳机一连接到电脑就会断开<br>起初我以为是我的蓝牙耳机出现了问题，所以我尝试用手机连接发现没有问题，于是我就猜测肯定是电脑蓝牙驱动出现了问题<br>在这里先感谢论坛 <a href="https://bbs.archlinuxcn.org/">archlinuxcn</a> 的大佬们</p><span id="more"></span><h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><p>出现了问题先看日志，判断是出现在哪里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">journalctl -l -f -u bluetooth.service                                                       <br></code></pre></td></tr></table></figure><p>执行命令后，再连接一次蓝牙耳机，在又一次连接失败后，看到了如下日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs log">Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/aptx<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/aptx<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/sbc<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/sbc<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/sbc_xq_453<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/sbc_xq_453<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/sbc_xq_512<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/sbc_xq_512<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/sbc_xq_552<br>Jul 01 09:56:36 Nero bluetoothd[4337]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/sbc_xq_552<br>Jul 01 09:56:44 Nero bluetoothd[4337]: profiles/audio/avctp.c:avctp_control_confirm() Control: Refusing unexpected connect<br>Jul 01 09:56:44 Nero systemd[1]: bluetooth.service: Main process exited, code=dumped, status=11/SEGV<br>Jul 01 09:56:44 Nero systemd[1]: bluetooth.service: Failed with result &#x27;core-dump&#x27;.<br>Jul 01 09:56:44 Nero systemd[1]: Starting Bluetooth service...<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Bluetooth daemon 5.67<br>Jul 01 09:56:44 Nero systemd[1]: Started Bluetooth service.<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Starting SDP server<br>Jul 01 09:56:44 Nero bluetoothd[4356]: src/plugin.c:plugin_init() System does not support csip plugin<br>Jul 01 09:56:44 Nero bluetoothd[4356]: src/plugin.c:plugin_init() System does not support vcp plugin<br>Jul 01 09:56:44 Nero bluetoothd[4356]: src/plugin.c:plugin_init() System does not support mcp plugin<br>Jul 01 09:56:44 Nero bluetoothd[4356]: src/plugin.c:plugin_init() System does not support bass plugin<br>Jul 01 09:56:44 Nero bluetoothd[4356]: src/plugin.c:plugin_init() System does not support bap plugin<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Bluetooth management interface 1.22 initialized<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Failed to set privacy: Rejected (0x0b)<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/ldac_hq<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/ldac_sq<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/ldac_mq<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/aptx_hd<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/aptx_hd<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/aptx<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/aptx<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/sbc<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/sbc<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/sbc_xq_453<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/sbc_xq_453<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/sbc_xq_512<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/sbc_xq_512<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSink/sbc_xq_552<br>Jul 01 09:56:44 Nero bluetoothd[4356]: Endpoint registered: sender=:1.58 path=/MediaEndpoint/A2DPSource/sbc_xq_552<br></code></pre></td></tr></table></figure><p>可以看到中间有连接失败的日志，可能是缺失了某个模块<br>于是我就通过这些报错信息尝试进行解决，无果<br>最后是在 <a href="https://bbs.archlinuxcn.org/">Arch Linux中文论坛</a> 中询问了大佬后，在 <a href="https://bbs.archlinux.org/">Arch Linux论坛</a>中找到了解决方法<br>这就是 <code>bluez</code>、 <code>bluez-libs</code>、 <code>bluez-utils</code> 5.67版本的 Bug，我没有能力去修复这个 Bug(因为我菜)，于是就先回退到上一个版本，等这个 Bug 修复了再更新</p><h1 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h1><p>回退版本只需要在 <a href="https://archive.archlinux.org/">Arch Linux Archive</a> 找到旧版本的包，也就是5.66版本，安装即可<br>所以执行如下命令降级这三个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -U https://archive.archlinux.org/packages/b/bluez/bluez-5.66-1-x86_64.pkg.tar.zst<br>sudo pacman -U https://archive.archlinux.org/packages/b/bluez-libs/bluez-libs-5.66-1-x86_64.pkg.tar.zst<br>sudo pacman -U https://archive.archlinux.org/packages/b/bluez-utils/bluez-utils-5.66-1-x86_64.pkg.tar.zst<br></code></pre></td></tr></table></figure><p>安装完旧包后，编辑 <code>/etc/pacman.conf</code> 文件，将这三个包添加到不更新的列表中，待下个版本更新后再移出即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">IgnorePkg   = bluez bluez-libs bluez-utils<br></code></pre></td></tr></table></figure><p>完成后重启蓝牙服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl restart bluetooth.service <br></code></pre></td></tr></table></figure><p>这样就可以继续愉快的 <code>-Syu</code>了 ヾ(*´▽‘*)ﾉ</p><hr><p>刚开始无法连接的时候我还以为我的耳机坏了呢，还好没坏，不然又是一笔开销呢  ( ｡ớ ₃ờ)ھ<br>这次确实要感谢论坛里面的大佬，不然我肯定不会这么快的解决这个问题 ε٩(๑&gt; ₃ &lt;)۶з</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArchLinux</tag>
      
      <tag>pacman</tag>
      
      <tag>bluez</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bilibili自动推流直播</title>
    <link href="/2023/06/05/Bilibili%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/"/>
    <url>/2023/06/05/Bilibili%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="自动推流B站直播"><a href="#自动推流B站直播" class="headerlink" title="自动推流B站直播"></a>自动推流B站直播</h1><p>最近刚了解到了新玩法，那就是24小时不间断直播，只要设置好直播需要的视频文件，就可以不断的像B站直播推流<br><del>这么直播个几个月能赚到几块钱吗</del> ﾚ(ﾟ∀ﾟ;)ﾍ&#x3D;3&#x3D;3&#x3D;3</p><span id="more"></span><h1 id="直播所需资源"><a href="#直播所需资源" class="headerlink" title="直播所需资源"></a>直播所需资源</h1><p>直播脚本需要的资源有三种：</p><ul><li>mp3音频+一张jpg图片<ul><li>只需要至少一个mp3文件和一张jpg文件拼合成一个视频，推送到B站直播</li></ul></li><li>mp3音频+多张jpg图片<ul><li>可以用多个mp3文件和多张jpg文件拼合成一个视频，推送到B站直播，图片名称需和音频名称相同，如1.mp3和1.jpg</li></ul></li><li>mp4视频<ul><li>需要至少一个mp4视频文件，推送到B站直播</li></ul></li></ul><p>做好推送的资源准备后，就可以准备开始直播了</p><h1 id="安装需要的软件"><a href="#安装需要的软件" class="headerlink" title="安装需要的软件"></a>安装需要的软件</h1><p>脚本需要的软件有tmux和ffmpeg<br>tmux可以直接通过包管理器安装，Arch Linux 的官方库里可以直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S tmux<br></code></pre></td></tr></table></figure><p>ffmpeg 也可以通过包管理器安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S ffmpeg<br></code></pre></td></tr></table></figure><p>或者去官方下载已经编译好的包，下载解压后，将二进制文件放到 <code>/usr/bin</code> 目录下<br><a href="https://www.johnvansickle.com/ffmpeg/old-releases/">https://www.johnvansickle.com/ffmpeg/old-releases/</a></p><h1 id="开始推流"><a href="#开始推流" class="headerlink" title="开始推流"></a>开始推流</h1><p>推流用到的脚本是我结合网上已有的代码和我自己的理解完成的<br>由于本人的能力有限，所以不能实现更多的功能，但是，有句话说的好——又不是不能用<br>用tmux创建一个窗口，名称为 <code>streamVideo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux new -s streamVideo<br></code></pre></td></tr></table></figure><p>运行如下命令，按提示输入所需信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash &lt;(wget -qO- -o- https://raw.githubusercontent.com/Nero-UMU/Bilibili-Live-Push/main/script.sh) <br></code></pre></td></tr></table></figure><p>设置好推流后，按下 <code>Ctrl+b</code>,<code>d</code> 快捷键组合使tmux后台运行，24小时不间断直播已开始</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>链接错误导致的推流失败<ul><li>有可能是链接中的 “&amp;” 符号导致的错误，尝试使用 Bash 运行此脚本</li></ul></li><li>读取目录错误<ul><li>有可能是文件中的空格导致的，不过理论上应该不会有这个问题</li></ul></li></ul><p>直播码由服务器地址和串流密钥拼接而成<br><img src="/img/2023-6-5-1.png"></p><h1 id="脚本使用测试"><a href="#脚本使用测试" class="headerlink" title="脚本使用测试"></a>脚本使用测试</h1><p>输入参数界面<br><img src="/img/2023-6-5-2.png"></p><p>实际播放效果<br><img src="/img/2023-6-5-3.png"></p><hr><p>虽然做一个这样的直播赚不到什么钱，但是反正闲着也是闲着，不如做一个直播 (′゜ω。‵)<br>万一因为做了一个这样的直播火了呢 <del>不就能捞钱了吗</del> 啊不对 <del>不就能出道成为偶像了吗</del></p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>shell</tag>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apache服务器搭建并添加SSL</title>
    <link href="/2023/05/24/Apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL/"/>
    <url>/2023/05/24/Apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%B9%B6%E6%B7%BB%E5%8A%A0SSL/</url>
    
    <content type="html"><![CDATA[<h1 id="学习了使用-Apache-搭建网站"><a href="#学习了使用-Apache-搭建网站" class="headerlink" title="学习了使用 Apache 搭建网站"></a>学习了使用 Apache 搭建网站</h1><p>在红帽上学习了用 Apache 搭建网站并添加了 SSL 证书<br>虽说之前也用过 Nginx 和 Apache 搭建过网站，但还是记录一下吧，这次着重学习了自签 SSL 证书和使用自签的 SSL 证书</p><span id="more"></span><h1 id="搭建一个最基本的网站"><a href="#搭建一个最基本的网站" class="headerlink" title="搭建一个最基本的网站"></a>搭建一个最基本的网站</h1><p>在给网站添加 SSL 证书之前，你得有一个简单的网页</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>红帽自带了openssl，可以通过命令查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl version<br></code></pre></td></tr></table></figure><p>安装 Apache 和 ssl 模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install httpd mod_ssl -y<br></code></pre></td></tr></table></figure><h2 id="创建一个网页"><a href="#创建一个网页" class="headerlink" title="创建一个网页"></a>创建一个网页</h2><p>Apache 的默认静态页面的目录是 <code>/var/www/html</code>，这里我就换一个根目录<br>创建网页的根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /web<br></code></pre></td></tr></table></figure><p>创建 <code>/web/index.html</code> 文件并编辑网页内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>你被骗了<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">font-family</span>: Arial, sans-serif;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">header</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#020202</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Never gonna give you up<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>gonna let you down<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Never gonna run around and desert you<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Never gonna make you cry<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Never gonna say goodbye<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Never gonna tell a lie and hurt you<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改目录的权限，添加可执行的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod a+x -R /web<br></code></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改 Apache 的配置文件 <code>/etc/httpd/conf/httpd.conf</code><br>设置监听端口为8080<br><img src="/img/2023-5-24-2.png"></p><p>设置如下的119行根目录<code>DocumentRoot</code> 和131行目录路径 <code>&lt;Directory&gt;</code>，保存并退出<br><img src="/img/2023-5-24-1.png"> </p><p>关闭防火墙、selinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop firewalld.service <br>setenforce 0<br>iptables -F<br></code></pre></td></tr></table></figure><p>启动 Apache 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start httpd<br></code></pre></td></tr></table></figure><p>此时客户端浏览器打开 <code>服务器IP:8080</code> 就可以看到刚才的静态页面了，最简单的静态网页搭建完成<br><img src="/img/2023-5-24-3.png"></p><h1 id="为网站添加-SSL-证书"><a href="#为网站添加-SSL-证书" class="headerlink" title="为网站添加 SSL 证书"></a>为网站添加 SSL 证书</h1><p>这里我是使用了自签的 SSL 证书，顺便又学了一次 openssl 的使用</p><h2 id="CA-服务器生产私钥和证书"><a href="#CA-服务器生产私钥和证书" class="headerlink" title="CA 服务器生产私钥和证书"></a>CA 服务器生产私钥和证书</h2><p>CA 服务器生成私钥，并修改其权限为 600</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048<br>chmod 600 /etc/pki/CA/private/cakey.pem<br></code></pre></td></tr></table></figure><p>修改 openssl.cnf 文件，红帽上的位置和之前 Arch Linux 和 Ubuntu 的路径相差比较大，它的路径为 <code>/etc/pki/tls/openssl.cnf</code><br>修改 <code>[ req_distinguished_name ]</code> 下的各信息，此处填写的是 CA 服务器的默认各种信息，在生成自签证书时直接使用这些默认设置即可，在后面 Apache 服务器生产申请请求文件时，这些信息要一致，否则无法生成自签证书<br><img src="/img/2023-5-24-4.png"></p><p>生成自签证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3650<br></code></pre></td></tr></table></figure><p>在生成证书的时候填写信息都直接回车使用默认即可，在设置 <code>Common Name</code> 时填写 CA 服务器的主机名<br><img src="/img/2023-5-24-5.png"></p><p>继续修改 <code>/etc/pki/tls/openssl.cnf</code> 文件，设置已签署的证书、证书序列号等文件的路径<br><img src="/img/2023-5-24-6.png"></p><p>创建这些目录和文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /etc/pki/CA/certs /etc/pki/CA/crl /etc/pki/CA/newcerts<br>touch /etc/pki/CA/index.txt<br>echo 01 &gt; /etc/pki/CA/serial<br></code></pre></td></tr></table></figure><p>如果原本就是设置好的，目录应该也是原本就存在的，只需要创建两个文件即可</p><h2 id="HTTP-服务器申请证书"><a href="#HTTP-服务器申请证书" class="headerlink" title="HTTP 服务器申请证书"></a>HTTP 服务器申请证书</h2><p>创建 SSL 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/httpd<br>mkdir ssl<br>cd ssl<br></code></pre></td></tr></table></figure><p>生成私钥并修改权限为600</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out httpd.key 2048<br>chmod 600 httpd.key<br></code></pre></td></tr></table></figure><p>用私钥生成请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -key httpd.key -out httpd.csr<br></code></pre></td></tr></table></figure><p>在生成请求文件的时候，注意与CA上的设置的参数要一致，<code>Common Name</code> 设置为要添加 SSL 的网站的域名<br><img src="/img/2023-5-24-7.png"></p><p>将证书发送给 CA 服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp httpd.csr CA服务器IP:/tmp<br></code></pre></td></tr></table></figure><h2 id="CA-服务器颁发证书"><a href="#CA-服务器颁发证书" class="headerlink" title="CA 服务器颁发证书"></a>CA 服务器颁发证书</h2><p>CA 服务器用如下命令颁发证书，证书有效时长为10年</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl ca -in /tmp/httpd.csr -out /tmp/httpd.crt -days 3650<br></code></pre></td></tr></table></figure><p>签发完成后，可以查看 <code>index.txt</code> 文件和 <code>serial</code> 文件，可以看到有签署的记录在里面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/pki/CA/index.txt<br>cat /etc/pki/CA/serial<br></code></pre></td></tr></table></figure><h2 id="HTTP-服务器添加-SSL"><a href="#HTTP-服务器添加-SSL" class="headerlink" title="HTTP 服务器添加 SSL"></a>HTTP 服务器添加 SSL</h2><p>将证书下载到 HTTP 服务器的 <code>/etc/httpd/ssl</code> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp CA服务器IP:/tmp/httpd.crt /etc/httpd/ssl<br></code></pre></td></tr></table></figure><h3 id="搭建虚拟主机"><a href="#搭建虚拟主机" class="headerlink" title="搭建虚拟主机"></a>搭建虚拟主机</h3><p>虚拟主机可以使不同的域名访问同一个IP下的不同目录，实现一台服务器上搭建多个网页的目的<br>编辑 <code>/etc/httpd/conf/httpd.conf</code> 文件，修改网站的根目录，注释掉即可<br><img src="/img/2023-5-24-8.png"></p><p>创建并编辑文件 <code>/etc/httpd/conf.d/virtualhost.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">&lt;VirtualHost *:8080&gt;<br>        ServerName hello.com<br>        DocumentRoot &quot;/web&quot;<br>&lt;/VirtualHost&gt;<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/httpd/conf.d/ssl.conf</code> 文件，大约从第56行开始，按实际情况修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs conf">&lt;VirtualHost *:443&gt;<br>    ServerName hello.com<br>    DocumentRoot &quot;/web&quot;<br>    SSLEngine on<br>    SSLCertificateFile /etc/httpd/ssl/httpd.crt<br>    SSLCertificateKeyFile /etc/httpd/ssl/httpd.key<br></code></pre></td></tr></table></figure><p>可以用如下命令测试配置是否正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">httpd -t<br></code></pre></td></tr></table></figure><p>重启 httpd 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart httpd<br></code></pre></td></tr></table></figure><p>客户端访问 <code>https://hello.com</code><br>如果无法访问可能是因为没有域名到IP的解析的原因，要么搭建一个 DNS 解析域名到 HTTP 服务器，要么添加一条 hosts </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;http服务器IP hello.com&quot; &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><p>然后浏览器再此打开 <code>https://hello.com</code> 就可以看到如下页面了<br><img src="/img/2023-5-24-9.png"></p><p>这说明 SSL 已经成功添加到 HTTP 的服务器中了，之所以出现这个页面是因为使用的是自签证书，被识别为不安全网站了，但是和网页直接的交互已经是加密了的<br><img src="/img/2023-5-24-10.png"></p><hr><p>以前虽然是用过 Apache 搭建过 http 服务的，但没有像这样一步一步的学习过来，每一步都知道在干什么<br>而且还又学习了一次自签 SSL 证书，并添加 SSL 证书到 HTTP 服务器中 &lt; (￣︶￣)&gt;</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Apache</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH关闭失效的连接</title>
    <link href="/2023/05/19/SSH%E5%85%B3%E9%97%AD%E5%A4%B1%E6%95%88%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/05/19/SSH%E5%85%B3%E9%97%AD%E5%A4%B1%E6%95%88%E7%9A%84%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="如何关闭失效的连接"><a href="#如何关闭失效的连接" class="headerlink" title="如何关闭失效的连接"></a>如何关闭失效的连接</h1><p>在使用 SSH 连接服务器的时候，难免会遭遇网络波动，这就有可能造成连接中断<br>有时候，连接虽然中断了，但是 SSH 的连接窗口却没有自动关闭，不论输入什么窗口都是无响应<br>通常这种情况我会直接杀死(kill)这个窗口<br>但这样做其实是很不好的一种习惯，但我一直没找到好的解决方法，今天正好碰到了这种情况的解决方案</p><span id="more"></span><h1 id="SSH-转义字符"><a href="#SSH-转义字符" class="headerlink" title="SSH 转义字符"></a>SSH 转义字符</h1><p>使用转义字符的方法很简单，按下回车后再输入一个 <code>~</code> 符号即可使用转义字符了<br>比如按下回车 + <code>~?</code>，就会输出帮助菜单</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">Supported escape sequences:<br> ~.   - terminate connection (and any multiplexed sessions)<br> ~B   - send a BREAK to the remote system<br> ~R   - request rekey<br> ~V/v - decrease/increase verbosity (LogLevel)<br> ~^Z  - suspend ssh<br> ~#   - list forwarded connections<br> ~&amp;   - background ssh (when waiting for connections to terminate)<br> ~?   - this message<br> ~~   - send the escape character by typing it twice<br>(Note that escapes are only recognized immediately after newline.)<br></code></pre></td></tr></table></figure><ul><li><code>~.</code> 终止会话</li><li><code>~B</code> 向远端系统发送 BREAK</li><li><code>~R</code> 请求重新加密连接</li><li><code>~V/v</code> 当写入错误写入到日志中时，下调&#x2F;上调日志的详细等级</li><li><code>~^Z</code> 挂起 ssh 连接，可以通过 <code>fg</code> 命令回到连接</li><li><code>~#</code> 列出转发的连接</li><li><code>~&amp;</code> 当等待 ssh 连接终止时，后台运行 ssh</li><li><code>~?</code> 打印帮助列表</li><li><code>~~</code> 当连接一台主机A后，用A主机连接B主机，向B主机发送一个 <code>~</code> 符号</li></ul><p>显然，当需要关闭失效的 ssh 连接窗口的时候，使用 <code>~.</code> 转义字符就可以关闭 ssh 连接的窗口了</p><hr><p>所以以后碰到连接无响应的时候，不用再杀死那个进程了，ssh 自带的功能就可以完成这一项任务，而且能更安全的断开这个假连接 (＠￣ー￣＠)<br>使用这些转义字符还能更好的使用 ssh 这个工具，学一学新东西何乐而不为呢 ( σ’ω’)σ </p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux自动封禁多次连接失败的IP</title>
    <link href="/2023/05/18/Linux%E8%87%AA%E5%8A%A8%E5%B0%81%E7%A6%81%E5%A4%9A%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%E7%9A%84IP/"/>
    <url>/2023/05/18/Linux%E8%87%AA%E5%8A%A8%E5%B0%81%E7%A6%81%E5%A4%9A%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5%E7%9A%84IP/</url>
    
    <content type="html"><![CDATA[<h1 id="封禁多次连接失败的-IP"><a href="#封禁多次连接失败的-IP" class="headerlink" title="封禁多次连接失败的 IP"></a>封禁多次连接失败的 IP</h1><p>最近几天多次看我的服务器有大量连接失败的日志，其中有大量的不同用户名的尝试连接失败的记录<br>虽然我已经更改了 SSH 的连接端口，并开启了唯密钥登录<br>虽然这样入侵成功的概率很低很低，但是它大量的尝试连接也是会占用我的带宽和 CPU，这也是一种 DDoS攻击，名为 CC (ChallengeCollapsar，挑战黑洞) 攻击<br>于是我就尝试禁止它们的连接</p><span id="more"></span><h1 id="编写-Shell-脚本"><a href="#编写-Shell-脚本" class="headerlink" title="编写 Shell 脚本"></a>编写 Shell 脚本</h1><p>为了获取到这些多次连接失败的 IP，地址，可以用如下的命令获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lastb | awk &#x27;&#123;print $3&#125;&#x27; | sort | uniq -c | sed &#x27;/[A-Z]/d&#x27; | awk &#x27;&#123;if($1&gt;3) print$2&#125;&#x27;<br></code></pre></td></tr></table></figure><p>命令 <code>lastb</code> 可以获取到连接失败的日志，后面从该日志中获取到重复次数超过3次的 IP 地址</p><p>文件 <code>/etc/hosts.deny</code> 是一个黑名单，在该名单中的主机将被拒绝连接<br>所以创建脚本文件 &#x2F;opt&#x2F;AutoBanIP.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch /opt/AutoBanIP.sh<br></code></pre></td></tr></table></figure><p>编写如下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>iplist=`lastb | awk &#x27;&#123;print $3&#125;&#x27; | sort | uniq -c | sed &#x27;/[A-Z]/d&#x27; | awk &#x27;&#123;if($1&gt;3) print$2&#125;&#x27;` # 获取需要封禁的 IP 地址列表<br>for ip in $iplist # 遍历该列表<br>do<br>        if (grep -q $ip /etc/hosts.deny) # 判断该 IP 地址是否已经存在于 /etc/hosts.deny 中<br>        then<br>                continue<br>        else<br>                echo &quot;sshd:$ip:deny&quot; &gt;&gt; /etc/hosts.deny # 添加该地址到黑名单中<br>        fi<br>done<br></code></pre></td></tr></table></figure><p>赋予执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x AutoBanIP.sh<br></code></pre></td></tr></table></figure><h1 id="定时运行脚本"><a href="#定时运行脚本" class="headerlink" title="定时运行脚本"></a>定时运行脚本</h1><p>为了定时运行该脚本，需要编写两个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch /etc/systemd/system/AutoBanIP.service /etc/systemd/system/AutoBanIP.timer<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/systemd/system/AutoBanIP.service</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=Auto ban IP<br><br>[Service]<br>ExecStart=/opt/AutoBanIP.sh<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/systemd/system/AutoBanIP.timer</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]  <br>Description=Run AutoBanIP.sh evey 1 hour  <br>  <br>[Timer]<br>OnBootSec=30m<br>OnUnitActiveSec=30m <br> <br>[Install]  <br>WantedBy=timers.target<br></code></pre></td></tr></table></figure><p><code>AutoBanIP.timer</code> 文件定义了每30分钟自动执行一次 <code>AutoBanIP.sh</code> 脚本</p><p>编写完成后，运行如下命令启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload <br>systemctl enable --now AutoBanIP.timer <br></code></pre></td></tr></table></figure><hr><p>屏蔽脚本编写完成后，希望能减少这些连接失败的日志 (ꐦ°᷄д°᷅)<br>不知道怎么回事就被人盯上了我的服务器，里面也没什么好东西啊，希望后面能停止这种攻击吧，CC 攻击我没什么好处 (ノ▼Д▼)ノ</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>systemd</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS服务器搭建</title>
    <link href="/2023/05/04/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/05/04/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="实验搭建-DNS-服务器"><a href="#实验搭建-DNS-服务器" class="headerlink" title="实验搭建 DNS 服务器"></a>实验搭建 DNS 服务器</h1><p>尝试搭建 DNS 服务器，中途碰到了些问题，解决后，将搭建的过程和步骤记录下来</p><span id="more"></span><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p>DNS 用到的软件是 bind，直接安装即可<br>Arch Linux 和 RHEL7 用的都一样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S bind<br></code></pre></td></tr></table></figure><p>RHEL7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install bind<br></code></pre></td></tr></table></figure><h1 id="最基本的配置"><a href="#最基本的配置" class="headerlink" title="最基本的配置"></a>最基本的配置</h1><p>编辑 <code>/etc/named.conf</code> 文件，修改以下两个配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">listen-on port 53 &#123; any; &#125;;<br>allow-query     &#123; any; &#125;;<br></code></pre></td></tr></table></figure><p>设置ipv4的监听地址为所有地址，允许查询的主机为任意主机</p><p>编辑 <code>/etc/named.rfc1912.zones</code> 文件，添加正向和反向的DNS解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs conf">zone &quot;hello.com&quot; IN &#123; #正向解析<br>        type master;<br>        file &quot;data/hello.com.zone&quot;;<br>&#125;;<br><br>zone &quot;10.16.172.in-addr.arpa&quot; IN &#123; #反向解析<br>        type master;<br>        file &quot;data/10.16.172.in-addr.arpa.zone&quot;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>保留权限的复制 &#x2F;var&#x2F;named&#x2F;named.empty 到 &#x2F;var&#x2F;named&#x2F;data&#x2F;hello.com.zone</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -p /var/named/named.empty /var/named/data/hello.com.zone<br></code></pre></td></tr></table></figure><p>编辑 <code>/var/named/data/hello.com.zone</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">$TTL 3H<br>@       IN SOA  @ jkmail.neroumu.top. (<br>                                        1       ; 序列号<br>                                        1D      ; 刷新时间<br>                                        1H      ; 重试时间<br>                                        1W      ; 过期时间<br>                                        3H )    ; 否定答案的TTL值<br>        NS      @<br>        A       172.16.10.10<br>world   IN      A       172.16.10.20<br>nihao   IN      A       172.16.10.30<br></code></pre></td></tr></table></figure><ul><li>@ 代表当前区域的域名</li><li>第一个 <code>@</code> 是当前区域的名字</li><li>SOA 表示资源类型为SOA</li><li>第二个 <code>@</code> 为主DNS的名称，表示下面哪一条资源记录是主 DNS </li><li>jkmail.neroumu.top. DNS服务器的管理员邮箱，@用点 <code>.</code> 来代替</li><li>IN 代表Internet</li><li><code>NS      @</code> 其中 NS 表示这是一条域名服务器记录，@ 表示当前区域的服务器是域名服务器</li><li><code>A       172.16.10.10</code> 表示当前区域的域名服务器的 IP 地址，也就是本机的 IP 地址</li></ul><p>同理复制一个反向解析文件 <code>data/10.16.172.in-addr.arpa.zone</code>，编辑如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs conf">$TTL 3H<br>@       IN SOA  @ jkmail.neroumu.top. (<br>                                        1       ; 序列号<br>                                        1D      ; 刷新时间<br>                                        1H      ; 重试时间<br>                                        1W      ; 过期时间<br>                                        3H )    ; 否定答案的TTL值<br>        NS      @<br>        A       127.0.0.1<br>10      IN      PTR     hello.com.<br>20      IN      PTR     world.hello.com.<br>30      IN      PTR     nihao.hello.com.<br></code></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart named<br></code></pre></td></tr></table></figure><p>客户端可以通过 <code>nslookup</code> 命令测试是否搭建完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">nslookup hello.com<br>nslookup nihao.hello.com<br><br>nslookup 172.16.10.10<br>nslookup 172.16.10.20<br></code></pre></td></tr></table></figure><h1 id="搭建从服务器"><a href="#搭建从服务器" class="headerlink" title="搭建从服务器"></a>搭建从服务器</h1><p>从服务器安装好 bind 后，同样的修改 <code>/etc/named.conf</code> 中的两个 any<br>编辑 <code>/etc/named.rfc1912.zones</code> 文件，增加一个正向解析和一个反向解析，并设置类型为slave</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">zone &quot;hello.com&quot; IN &#123;<br>        type slave;<br>        file &quot;slaves/hello.com.zone&quot;;<br>        masters &#123;172.16.10.10;&#125;; #主服务器IP地址<br>&#125;;<br><br>zone &quot;10.16.172.in-addr.arpa&quot; IN &#123;<br>        type slave;<br>        file &quot;slaves/10.16.172.in-addr.arpa.zone&quot;;<br>        masters &#123;172.16.10.10;&#125;; #主服务器IP地址<br>&#125;;<br></code></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart named<br></code></pre></td></tr></table></figure><p>此时在 <code>/var/named/slaves</code> 目录下可以看到正向和反向区域解析都已自动获取，配置完成</p><h1 id="搭建-DNS-子域委派"><a href="#搭建-DNS-子域委派" class="headerlink" title="搭建 DNS 子域委派"></a>搭建 DNS 子域委派</h1><p>编辑 <code>/etc/named.conf</code> 文件，将服务器之间的认证机制关闭，否则后续会导致无法认证以至于无法委派子域，父域和子域都要配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">dnssec-enable no;<br>dnssec-validation no;<br></code></pre></td></tr></table></figure><p>编辑子域服务器的 <code>/etc/named.rfc1912.zones</code> 文件，添加一个子域zone</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">zone &quot;sekai.hello.com&quot; IN &#123;<br>        type master;<br>        file &quot;data/sekai.hello.com.zone&quot;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>编辑 <code>/var/named/data/sekai.hello.com.zone</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs conf">$TTL 3H<br>@       IN SOA  @ jkmail.neroumu.top. (<br>                                        1       ; 序列号<br>                                        1D      ; 刷新时间<br>                                        1H      ; 重试时间<br>                                        1W      ; 过期时间<br>                                        3H )    ; 否定答案的TTL值<br>        NS      @<br>        A       172.16.10.11<br>kono    IN      A       172.16.10.40<br></code></pre></td></tr></table></figure><p>其实就是在子域服务器上搭建一个新的 DNS 服务器，它管理的域名是 hello.com 的一个子域 sekai<br>此时启动服务后，本服务器可以解析 sekai.hello.com 的资源<br>但此时父域服务器无法解析子域管理的域名，需要给它授权才能解析到子域管理的域名<br>编辑父域服务器的 <code>/var/named/data/hello.com.zone</code> 文件，添加子域服务器认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs conf">$TTL 3H<br>@       IN SOA  @ jkmail.neroumu.top. (<br>                                        1       ; 序列号<br>                                        1D      ; 刷新时间<br>                                        1H      ; 重试时间<br>                                        1W      ; 过期时间<br>                                        3H )    ; 否定答案的TTL值<br>        NS      @<br>        A       172.16.10.10<br>world   IN      A       172.16.10.20<br>nihao   IN      A       172.16.10.30<br><br>sekai   IN      NS      dns1 #添加子域服务器，它管理的是sekai子域<br>dns1    IN      A       172.16.10.11 #子域服务器的IP地址<br></code></pre></td></tr></table></figure><p>添加的两条解析的意思是如果碰到 sekai 这个域的域名解析，把它交给 dns1 所指向的服务器解析，dns1 指向的服务器为子域服务器的 IP 地址</p><p>重启 named 服务后，客户端将DNS服务器设置为父域服务器，并尝试解析子域服务器管理的域名，可以得到未经过认证的解析结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">nslookup sekai.hello.com<br>nslookup kono.sekai.hello.com<br></code></pre></td></tr></table></figure><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ol><li>忘记关闭防火墙导致子域服务器配置失败</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop firewalld<br>iptables -F<br></code></pre></td></tr></table></figure><ol start="2"><li><p>序列号不相同导致无法授权</p></li><li><p>认证机制未关闭，因为配置的时候没有配置认证，所以应该关闭认证，否则会无法授权<br>编辑 <code>/etc/named.conf</code> 文件的如下配置</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">dnssec-enable no;<br>dnssec-validation no;<br></code></pre></td></tr></table></figure><hr><p>总算是把 DNS 服务器配置出来了，尤其是子域配置，配置了很久<br>之所以能在子域卡这么久，就是因为很多博主在配置的时候，都没有提到过关闭认证机制，导致我一直配置不成功，关闭之后，一下就成功了<br>从大量的重复、真真假假的文章中找答案真是太难受了，还是直接读官方文档好啊 ( ′ 3&#96;) sigh~</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
      <tag>Linux</tag>
      
      <tag>bind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DHCP服务器搭建</title>
    <link href="/2023/04/28/DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/04/28/DHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="实验搭建DHCP服务器"><a href="#实验搭建DHCP服务器" class="headerlink" title="实验搭建DHCP服务器"></a>实验搭建DHCP服务器</h1><p>做了搭建 DHCP 服务器的实验，中途碰到了许多问题，踩了好几个坑<br>记录一下搭建过程</p><span id="more"></span><h1 id="安装-DHCP-服务器"><a href="#安装-DHCP-服务器" class="headerlink" title="安装 DHCP 服务器"></a>安装 DHCP 服务器</h1><p>Arch Linux 安装 DHCP 服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S dhcp<br></code></pre></td></tr></table></figure><p>RHEL 安装 DHCP 服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install dhcp<br></code></pre></td></tr></table></figure><p>Arch Linux 的 配置文件为 <code>/etc/dhcpd.conf</code>，而 RHEL 的配置文件为 <code>/etc/dhcp/dhcpd.conf</code></p><h1 id="搭建最简单的-DHCP-服务器"><a href="#搭建最简单的-DHCP-服务器" class="headerlink" title="搭建最简单的 DHCP 服务器"></a>搭建最简单的 DHCP 服务器</h1><p>编辑配置文件，写入一下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">default-lease-time 21600; #全局变量，默认租期时间<br>max-lease-time 43200; #最长租期时间<br>option domain-name-servers 172.16.10.10; #DNS 服务器<br>option subnet-mask 255.255.255.0; #子网掩码<br><br>subnet 172.16.10.0 netmask 255.255.255.0 &#123; #网段<br>range 172.16.10.50 172.16.10.100; #IP地址范围<br>option routers 172.16.10.10; #网关<br>default-lease-time 600;<br>max-lease-time 7200;<br>&#125;<br></code></pre></td></tr></table></figure><p>开启 DHCP 服务，搭建完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start dhcpd<br></code></pre></td></tr></table></figure><h1 id="搭建超级作用域"><a href="#搭建超级作用域" class="headerlink" title="搭建超级作用域"></a>搭建超级作用域</h1><p>超级作用域就是可以同时分配多个网段的IP地址，将他们作为一个整体进行管理<br>编辑配置文件，写入一下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs conf">default-lease-time 21600; #全局变量，默认租期时间<br>max-lease-time 43200; #最长租期时间<br>option domain-name-servers 172.16.10.10; #DNS 服务器<br>option subnet-mask 255.255.255.0; #子网掩码<br><br>shared-network 10And20 &#123; #超级作用域名字<br>    subnet 172.16.10.0 netmask 255.255.255.0 &#123; #网段<br>        range 172.16.10.50 172.16.10.100; #IP地址范围<br>        option routers 172.16.10.10; #网关<br>        default-lease-time 600;<br>        max-lease-time 7200;<br>    &#125;<br>    subnet 172.16.20.0 netmask 255.255.255.0 &#123; #网段<br>        range 172.16.20.50 172.16.20.100; #IP地址范围<br>        option routers 172.16.10.10; #网关<br>        default-lease-time 600;<br>        max-lease-time 7200;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在搭建的时候，这两个网段还是要在一个局域网下<br>如果实在 VMWare 下配置的，将地址网段设置为 172.16.0.0&#x2F;16 即可，还有就是在配置 DHCP 服务器的时候，记得把 VMWare 自带的 DHCP 关闭<br><img src="/img/2023-4-28-1.png"></p><p>配置完成后，重启 DHCP 服务即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart dhcpd<br></code></pre></td></tr></table></figure><h1 id="搭建-DHCP-中继代理"><a href="#搭建-DHCP-中继代理" class="headerlink" title="搭建 DHCP 中继代理"></a>搭建 DHCP 中继代理</h1><p>DHCP 中继代理很少直接拿服务器来搭建，大多数是搭建在路由器等交换设备上的，不过既然都尝试着搭建了一下，也做个记录吧</p><h2 id="DHCP-服务器"><a href="#DHCP-服务器" class="headerlink" title="DHCP 服务器"></a>DHCP 服务器</h2><p>编辑 DHCP 服务端的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">default-lease-time 21600; #全局变量，默认租期时间<br>max-lease-time 43200; #最长租期时间<br>option domain-name-servers 172.16.10.10; #DNS 服务器<br>option subnet-mask 255.255.255.0; #子网掩码<br><br>subnet 172.16.20.0 netmask 255.255.255.0 &#123;<br>range 172.16.20.50 172.16.20.100;<br>option routers 172.16.20.1; #网关，中继代理服务器在目标网段的网卡设置为这个 IP<br>default-lease-time 600;<br>max-lease-time 7200;<br>&#125;<br></code></pre></td></tr></table></figure><p>中继代理服务器设置两张网卡，一个网卡在 DHCP 服务器所在的网段，另一个在目标网段下<br>如果是在 VMWare 下配置的话，如下设置网卡<br><img src="/img/2023-4-28-2.png"></p><p>DHCP 服务器使用 vmnet1 网卡，中继代理服务器使用两张网卡，客户端使用 vmnet2 网卡，并将自动分配IP地址关闭，否则DHCP服务器将无法正确分配IP地址</p><p>DHCP 服务器添加一条从中继代理服务器到达目标网络的路由记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip route add 172.16.20.0/24 via 172.16.10.1<br></code></pre></td></tr></table></figure><h2 id="中继代理服务器"><a href="#中继代理服务器" class="headerlink" title="中继代理服务器"></a>中继代理服务器</h2><p>安装好 DHCP 服务后，开启路由转发功能</p><p>临时有效，重启后关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 1 &gt; /proc/sys/net/ipv4/ip_forward<br></code></pre></td></tr></table></figure><p>若需永久有效，编辑文件 <code>/etc/sysctl.conf</code>，修改如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">net.ipv4.ip_forward = 1<br></code></pre></td></tr></table></figure><p>立即生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl -p<br></code></pre></td></tr></table></figure><p>可以直接使用 <code>dhcrelay</code> 命令来启动中继代理服务，但是使用起来不太方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dhcrelay -d --no-pid 172.16.10.10 #DHCP 服务器地址<br></code></pre></td></tr></table></figure><p>所以编辑 <code>/etc/systemd/system/dhcrelay.service</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=DHCP Relay Agent Daemon<br>Documentation=man:dhcrelay(8)<br>Wants=network-online.target<br>After=network-online.target<br><br>[Service]<br>Type=notify<br>ExecStart=/usr/sbin/dhcrelay -d --no-pid 172.16.10.10<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>启动 dhcrelay 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl --system daemon-reload<br>systemctl restart dhcrelay<br></code></pre></td></tr></table></figure><p>至此，中继代理服务配置完成</p><hr><p>为了做这个实验，看了许多博客，途中翻到了大量复制粘贴的博客，顿时感到自己搭建这个博客是正确的，把有用的东西收集并整理，自己以后就可以很方便的回顾这些知识，而不需要再像大海捞针一般，从各种连错误一起复制的“镜像”博客中寻找需要的东西<br>系统的学习了 Linux 服务器后，才发现和我自己随便玩玩的差别还是很大的，学到了更多有用的知识 ✧٩(ˊωˋ*)و✧</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>DHCP</tag>
      
      <tag>dhcrelay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NFS服务器搭建</title>
    <link href="/2023/04/24/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/04/24/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="实验搭建了NFS服务器"><a href="#实验搭建了NFS服务器" class="headerlink" title="实验搭建了NFS服务器"></a>实验搭建了NFS服务器</h1><p>Samba 服务器可以用于 Linux 和 Windows 之间的文件共享，而 NFS 可以用于 Linux 之间的文件共享<br>以后肯定会用到的知识，做个笔记吧</p><span id="more"></span><h1 id="搭建-NFS-服务器"><a href="#搭建-NFS-服务器" class="headerlink" title="搭建 NFS 服务器"></a>搭建 NFS 服务器</h1><p><code>注意</code>: 为了客户端能够连接上服务器，记得防火墙方行或者关闭防火墙</p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>Arch Linux 只需要安装 nfs-utils</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S nfs-utils<br></code></pre></td></tr></table></figure><p>RHEL 需要 rpcbind, nfs-utils 两个软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install rpcbind nfs-utils<br></code></pre></td></tr></table></figure><h2 id="创建共享目录"><a href="#创建共享目录" class="headerlink" title="创建共享目录"></a>创建共享目录</h2><p>出于安全考虑，建议定义一个单独的目录为NFS根，这可以将用户限制在该挂载点中，绑定的挂载点(bind mounts)将文件系统上别处的目录与被分享的挂载点连接起来<br>此时就需要用到 <code>mount</code> 命令的 <code>bind</code>参数了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /music #共享目录<br>mkdir /movie #共享目录<br><br>mkdir /srv/nfs/music #NFS根目录<br>mkdir /srv/nfs/movie #NFS根目录<br><br>mount --bind /music /srv/nfs/music<br>mount --bind /movie /srv/nfs/movie<br></code></pre></td></tr></table></figure><p>自动挂载共享目录，编辑 <code>/etc/fstab</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">/music /srv/nfs/music  none   bind   0   0<br>/movie /srv/nfs/movie  none   bind   0   0<br></code></pre></td></tr></table></figure><h3 id="mount-bind-命令"><a href="#mount-bind-命令" class="headerlink" title="mount bind 命令"></a>mount bind 命令</h3><p>这也是我第一次知道这个参数的，在看了这个参数的描述后，发现这个方式来可以实现目录的”硬连接”，之所以硬链接打了引号，是因为目录不能做硬链接</p><p>众所周知，软连接可以对目录进行操作，但是软连接可以理解为 Windows 中的快捷方式，所以并不能实现从一个位置访问另外一个位置的文件的功能</p><p>但是，硬链接可以做到，然而硬链接只能对文件进行操作，不能对目录进行操作，当然，我们可以通过如下命令对一个目录下的所有的文件做硬链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -l -r /foo /bar<br></code></pre></td></tr></table></figure><ul><li>cp 复制</li><li>-l 硬链接复制</li></ul><p>虽然这样可以做到把一堆文件做到从 &#x2F;foo 硬链接到 &#x2F;bar 下，但是如果我对其中一个目录下的文件进行删除，或者创建新的文件，另外一个目录可以做到同步吗，答案是否定的，这时候 mount bind 就派上用场了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount --bind /foo /bar<br></code></pre></td></tr></table></figure><p>通过 <code>--bind</code> 参数，将 &#x2F;bar 目录作为 &#x2F;foo 目录的一个镜像目录<br>这就很容易理解了，名字描述的很清楚了，就是作为一个镜像，一个改变了，另外一个就跟着改变</p><p>这还不是 bind 的最好使用方法，在创建某一个目录的镜像后，它的挂载点中的文件就会被屏蔽掉，注意不是消失，而是被屏蔽了，消挂载后又会出现</p><p>通过这种方式，可以用来做测试操作，假如要对 &#x2F;etc 下某文件进行修改测试，但是又怕改错了导致服务崩溃，这时就可以用 mount bind 了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -a /etc /tmp/etc<br>mount --bind /tmp/etc /etc<br></code></pre></td></tr></table></figure><ul><li>-a 保留链接、文件属性，并复制目录下的所有内容</li></ul><p>此时对 &#x2F;etc 下的任何修改都不会影响的原来的配置，因为原来的配置都被屏蔽了，现在的操作都是对 &#x2F;tmp&#x2F;etc 的文件进行操作<br>测试结束后，取消挂载，原 &#x2F;etc 下的文件又会重新出现，没有做任何修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">umount /etc<br></code></pre></td></tr></table></figure><p>通过 mount bind 来挂载共享目录可以将 NFS 的所有共享目录都在一个根 NFS 目录下<br>这样可以让程序运行起来更加安全，而且资源也更容易管理</p><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>NFS 的配置文件为 <code>/etc/exports</code><br>配置的格式如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/共享目录 [主机或域(权限)]<br></code></pre></td></tr></table></figure><p>权限选项:</p><ul><li>rw：读写</li><li>ro：只读</li><li>sync：同步模式，内存数据实时写入磁盘</li><li>async：非同步模式，它会每隔一段时间才会将数据刷新到磁盘</li><li>no_root_squash：客户端挂载NFS共享目录后，root用户不受约束，权限很大</li><li>root_squash：客户端上的root用户受到约束，被限定成某个普通用户</li><li>all_squash客户端上所有用户（包括root用户）在使用NFS共享目录时都被限定为一个普通用户</li><li>anonuid：定义被限定用户的uid</li><li>anongid：定义被限定用户的gid</li></ul><p>example1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/srv/nfs/music  192.168.1.0/24(rw,sync)<br></code></pre></td></tr></table></figure><p>对于 <code>/srv/nfs/music</code> 目录，192.168.1.0&#x2F;24 这个网段下的主机拥有读写权限，且内存数据实时写入磁盘</p><p>example2:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/srv/nfs/movie 192.168.2.0/24(ro,all_squash) nero(rw,sync,all_squash,anonuid=65534,anongid=65534)<br></code></pre></td></tr></table></figure><p>对于 <code>/srv/nfs/movie</code> 目录，192.168.2.0&#x2F;24 这个网段的主机拥有只读权限，且所有用户（包括root用户）在使用NFS共享目录时都被限定为一个普通用户<br>而 nero 这台主机拥有读写权限，所有用户（包括root用户）在使用NFS共享目录时都被限定为一个普通用户，并指定该普通用户的uid为65534,gid为65534</p><h2 id="启用并运行服务"><a href="#启用并运行服务" class="headerlink" title="启用并运行服务"></a>启用并运行服务</h2><p>Arch Linux 运行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start nfs-server.service<br></code></pre></td></tr></table></figure><p>RHEL 运行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start rpcbind  <br>systemctl start nfs-server  <br>systemctl start nfs<br></code></pre></td></tr></table></figure><h2 id="客户端挂载-NFS-共享目录"><a href="#客户端挂载-NFS-共享目录" class="headerlink" title="客户端挂载 NFS 共享目录"></a>客户端挂载 NFS 共享目录</h2><p>安装客户端<br>Arch Linux 需要安装 nfs-utils</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S nfs-utils<br></code></pre></td></tr></table></figure><p>RHEL 也只需要安装 nfs-utils</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install nfs-utils<br></code></pre></td></tr></table></figure><p>挂载共享目录,假设服务器地址为 192.168.10.10&#x2F;24</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /music /movie<br>mount -t nfs 192.168.10.10:/srv/nfs/music /music<br>mount -t nfs 192.168.10.10:/srv/nfs/movie /movie<br></code></pre></td></tr></table></figure><p>这样共享目录就被挂载到了客户端</p><hr><p>两个文件共享系统都学了一些，这样以后的文件共享的方法又有了新的方式<br>对于一个仓鼠来讲，存储容量是一大要务，文件存储后的共享更是一大要务 ٩(ˊᗜˋ*)و </p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>NFS</tag>
      
      <tag>mount bind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux报错Bad message</title>
    <link href="/2023/04/19/Linux%E6%8A%A5%E9%94%99Bad-message/"/>
    <url>/2023/04/19/Linux%E6%8A%A5%E9%94%99Bad-message/</url>
    
    <content type="html"><![CDATA[<h1 id="发现有的文件无法被访问"><a href="#发现有的文件无法被访问" class="headerlink" title="发现有的文件无法被访问"></a>发现有的文件无法被访问</h1><p>前几天硬盘线路的余波，qBittorrent 的文件校验有几个错误的任务，重启校验有几个失败很正常<br>但是当我尝试去下载丢失的文件时，一直失败<br>所以我进到了那个任务的目录下，发现文件无法被查看，而且有如下报错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">ls: cannot access XXXXXXXXXX: Bad message<br>rm: cannot remove XXXXXXXXXX: Bad message<br></code></pre></td></tr></table></figure><span id="more"></span><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>先说结论：磁盘损坏<br>刚开始其实我就差不多知道答案，但我就是不相信，我尝试把这些损坏的文件删除了重新下载<br>但是这个文件不论是 <code>rm -rf</code> 还是 root 权限下的 <code>rm -rf</code>，都无法被删除，报错还都是一样的</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>解决方案也很简单，把硬盘先卸载，然后在 root 权限下执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fsck -t ext4 -v /dev/sdb<br></code></pre></td></tr></table></figure><ul><li>-t 给定档案系统的型式</li><li>-v 详细显示模式</li></ul><p>Linux fsck (file system check)命令用于检查与修复 Linux 档案系统，可以同时检查一个或多个 Linux 档案系统<br>然后按后续检查内容选择是否进行修复</p><hr><p>可恶啊（*థ౪థ），本以为解决了一个很早以前埋下的炸弹，没想到被炸了两次<br>被这炸弹炸了一次就算了，今天还来了个第二波，还好问题解决起来不难，只是刚开始无法接受，到最后还是接受了现实 (,,Ծ‸Ծ,, )<br>以后搭服务器，挂载硬盘的配置一定不会再轻易的编辑 <code>/etc/fstab</code> 文件了，如果觉得不稳定就用 <code>systemd</code> 吧 இдஇ</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>fsck</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fstab挂载失败导致Linux无法启动</title>
    <link href="/2023/04/17/fstab%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E5%AF%BC%E8%87%B4Linux%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
    <url>/2023/04/17/fstab%E6%8C%82%E8%BD%BD%E5%A4%B1%E8%B4%A5%E5%AF%BC%E8%87%B4Linux%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="小主机突然无法启动"><a href="#小主机突然无法启动" class="headerlink" title="小主机突然无法启动"></a>小主机突然无法启动</h1><p>就在今天，我放在家的小主机突然无法访问挂载的硬盘了，可能是接口松动的原因，我没有在意，重启一下就可以了<br>然而这是我犯的一个大错误，硬盘之所以无法成功挂载肯定是有它的原因的，又因为我把自动挂载写进了 <code>/etc/fstab</code> 文件中<br>于是。。。<br>小主机就无法启动了</p><span id="more"></span><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>Linux 在启动时会挂载 <code>/etc/fstab</code> 中的硬盘，如果因为写入错误或者其他什么原因导致挂载失败，那么系统启动时就会出现异常，导致启动失败<br>正是因为这个原因，我那个可能是线松动了的硬盘盒无法正确挂载到我的小主机上，导致了我的小主机启动失败，让我这个不在小主机身边的人与它失联了</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>有两种解决方案，本打算使用方案一的，但方案二更安全，所以进而换成了方案二</p><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>这个方法很简单，修改 <code>/etc/fstab</code> 文件，正确配置需要挂载的文件系统即可<br>但是我本身配置就没问题，所以不是配置错误的原因<br>我是因为外部设备由于各种各样的原因无法被访问导致无法挂载，在正常情况下是没问题的<br>为了解决这种情况，我查阅了 Arch Linux 的 wiki，看到这样一句话<br><code>除非使用 nofail 选项,否则在列表中出现但实际不存在的设备会导致错误</code><br>在 <code>/etc/fstab</code> 中添加 <code>nofail</code> 选项就可以了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">设备UUID    /disk   ext4    nofail,x-systemd.device-timeout=1ms 0   0<br></code></pre></td></tr></table></figure><ul><li>nofail 可以在启动时若设备不存在直接忽略它而不报错</li><li>x-systemd.device-timeout&#x3D;1s 设置超时时间，以防止网络资源不能访问的时候浪费时间</li></ul><h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>使用 <code>systemd</code> 开机挂载硬盘<br>由于我的硬盘是外接设备，不是直接连在主板上的，所以连接并不稳定，这就降低了系统的容错率<br>而当自动挂载硬盘的工作交给 <code>systemd</code>的话，系统启动就不会受到干扰，提高了系统的容错率</p><p>在 <code>/etc/systemd/system</code> 创建挂载单元<br><code>注意</code>:挂载单元必须以它控制的挂载目录命名，且以<code>.mount</code>结尾，比如挂载点为 <code>/home/disk</code>，那么它的挂载单元必须为<code>home-disk.mount</code></p><p>编辑单元文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">[Unit]<br>Description=Mount disk<br><br>[Mount]<br>What=/dev/disk/by-uuid/设备UUID<br>Where=/disk<br>Type=ext4<br>Options=rw,noatime<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ul><li>What 设备的绝对路径，注意 <code>/dev/disk/by-uuid</code> 是一个实际存在的目录，不要把他删了只留个UUID在那，会启动失败的  (ఠ్ఠ ˓̭ ఠ్ఠ)</li><li>Where 挂载点</li><li>Type 文件类型</li><li>Options 可选项 <ul><li>rw 读写</li><li>noatime 完全禁用每次读取文件时将文件访问时间写入驱动器</li></ul></li></ul><p>配置完成后，运行如下命令使配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable 挂载单元.mount --now<br></code></pre></td></tr></table></figure><hr><p>突然的无法连接，原来并不是真正的突如其来，是早就有“预谋”的<br>由于我的不正确的配置，导致了今天我的小主机无法应对突发情况，这都是我在家中没有配置好的我的小主机的错<br>以后肯定不能再犯这样的错误了  ᘳᗒ.ᗕᘰ</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>fstab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Samba服务器搭建</title>
    <link href="/2023/03/30/Samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/03/30/Samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="刚好学习了搭建-Samba"><a href="#刚好学习了搭建-Samba" class="headerlink" title="刚好学习了搭建 Samba"></a>刚好学习了搭建 Samba</h1><p>最近刚好学习了搭建 Samba 服务器,想起之前想搭建网络共享服务器时考虑过 Samba 服务器却没有成功,最后还是采用了别的方案<br>既然正好解决了之前碰到的问题,那就记录下搭建的过程吧</p><span id="more"></span><h1 id="搭建-Samba-服务器"><a href="#搭建-Samba-服务器" class="headerlink" title="搭建 Samba 服务器"></a>搭建 Samba 服务器</h1><p><code>注意</code>:为了使客户端可以连接上 Samba 服务器,记得把防火墙关了!</p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>服务端只需要安装 Samba 就可以了,Arch Linux 和 RHEL 都一样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S Samba<br></code></pre></td></tr></table></figure><p>RHEL 安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install samba<br></code></pre></td></tr></table></figure><h2 id="配置共享目录"><a href="#配置共享目录" class="headerlink" title="配置共享目录"></a>配置共享目录</h2><p>创建需要共享的目录,注意权限的设置<br>由于 Samba 的目录权限是取 Samba 的配置和实际目录的权限的交集,为了方便,我就设置为777的最高权限<br>实际情况按实际情况考虑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -m 777 /test<br></code></pre></td></tr></table></figure><p>创建 Samba 用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd test #创建用户组<br>useradd -g test test_user #创建用户<br>passwd test_user #设置密码<br></code></pre></td></tr></table></figure><p>添加 Samba 账户,需要该用户实际存在,否则无法添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smbpasswd -a test_user<br></code></pre></td></tr></table></figure><p>设置 ACL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setfacl -m g:test:rwx /test<br></code></pre></td></tr></table></figure><ul><li>设置 test_user 用户拥有该目录的所有权限,实际情况实际考虑</li></ul><p>查看是否设置成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">getfacl /test<br></code></pre></td></tr></table></figure><p>编辑 &#x2F;etc&#x2F;samba&#x2F;smb.conf 文件,Arch Linux 和 RHEL 的目录都一样,没有就新建一个<br>配置文件的详情可以查询 <a href="https://man.archlinux.org/man/smb.conf.5">Arch Linux Wiki</a></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">[test]<br>        comment = test<br>        path = /test<br>        public = no<br>        writable = yes<br>        browseable = yes<br></code></pre></td></tr></table></figure><ul><li>[test] 共享名,可以随便命名</li><li>comment 备注信息</li><li>public 是否允许匿名访问</li><li>writable 是否可写</li><li>browseable 是否可浏览该目录</li></ul><p>这是最简单的配置文件,如果需要更多的配置,可以去网上找别人的配置或查询 wiki</p><p>测试配置是否格式正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">testparm /etc/samba/smb.conf<br></code></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart smb.service <br>systemctl restart nmb.service <br></code></pre></td></tr></table></figure><p>关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop firewalld<br>setenforce 0<br>iptables -F<br></code></pre></td></tr></table></figure><h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><p>Arch Linux 的客户端 和 RHEL 用的软件一样,但名字不一样</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S smbclient cifs-utils<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install samba-client cifs-utils<br></code></pre></td></tr></table></figure><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><p>验证是否可以连接 Samba 服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smbclient -L &lt;IP/主机名&gt; <br></code></pre></td></tr></table></figure><p>此方法为匿名登录,不需要输入密码,如果连接成功会输出 Samba 服务器共享的目录</p><p>查看某用户的共享目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smbclient -L &lt;IP/主机名&gt; -U username[%password]<br></code></pre></td></tr></table></figure><h2 id="挂载共享目录"><a href="#挂载共享目录" class="headerlink" title="挂载共享目录"></a>挂载共享目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -t cifs //IP或主机名/共享目录名称 挂载点 -o user=&lt;username&gt;,password=&lt;password&gt;,uid=&lt;username&gt;,gid=&lt;group&gt;,workgroup=&lt;workgroup&gt;,ip=&lt;serverip&gt;,iocharset=utf8<br></code></pre></td></tr></table></figure><ul><li>user 用户名</li><li>password 密码</li><li>uid 挂载的uid</li><li>gid 挂载的gid<br><code>使用 uid 和 gid 挂载选项时,注意文件权限</code></li><li>workgroup 用户组</li><li>ip 设置目标 IP 地址,如果请求的 UNC 名称的服务器名称部分可以解析,则此选项会自动设置,因此用户很少需要指定</li><li>iocharset 用于将本地路径名与 Unicode 相互转换的字符集</li></ul><h2 id="自动挂载-Saamba-目录"><a href="#自动挂载-Saamba-目录" class="headerlink" title="自动挂载 Saamba 目录"></a>自动挂载 Saamba 目录</h2><p>编辑 &#x2F;etc&#x2F;fstab 文件,注意这个文件很重要,如果不小心打错了,容易开不了机</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">//IP或主机名/共享目录名称 挂载点 cifs username=&lt;username&gt;,password=&lt;password&gt;,file_mode=0755,dir_mode=0755 0 0<br></code></pre></td></tr></table></figure><p>使配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -a<br></code></pre></td></tr></table></figure><hr><p>算是解决了一个常年的困难吧 (´▽&#96;ʃƪ)<br>以后碰到需要文件共享的时候,也可以用 Samba 服务器了 （●´∀｀）ノ♡</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Samba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RHEL7自动挂载yum</title>
    <link href="/2023/03/28/RHEL7%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDyum/"/>
    <url>/2023/03/28/RHEL7%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BDyum/</url>
    
    <content type="html"><![CDATA[<h1 id="不记笔记的报应"><a href="#不记笔记的报应" class="headerlink" title="不记笔记的报应"></a>不记笔记的报应</h1><p>今天做 Linux 的实验时候,碰到要用 yum 来安装软件,由于习惯了 Arch Linux 的 pacman 包管理器,我竟一时忘了该怎么做<br>明明之前是做过挂载光盘的,但就是忘记了该怎么做,还刚好没有做笔记<br>于是又重新学了一遍 RHEL 挂载光盘安装软件了</p><span id="more"></span><h1 id="挂载一次光盘"><a href="#挂载一次光盘" class="headerlink" title="挂载一次光盘"></a>挂载一次光盘</h1><p>创建一个用于挂载ISO的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /yum<br></code></pre></td></tr></table></figure><p>编辑yum源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/yum.repos.d/local.repo<br></code></pre></td></tr></table></figure><p>编辑如下内容</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">[Local-Server]<br>name=local-server<br>baseurl=file:///yum<br>enabled=1<br>gpgcheck=0<br></code></pre></td></tr></table></figure><p>挂载光盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -t iso9660 -o loop /dev/cdrom /yum<br></code></pre></td></tr></table></figure><p>完成之后就可以使用 yum 命令来安装软件了,但是一旦重启,就得重新挂载一次<br>如果想要每一次开机都可以之间使用的话,需要设置开机自动挂载</p><h1 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h1><p>编辑 <code>/etc/fstab</code> 文件,注意这个文件很重要,一定要再三小心,不然会开不了机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/fstab<br></code></pre></td></tr></table></figure><p>添加如下配置</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">/dev/cdrom /yum iso9660 defaults 0 0<br></code></pre></td></tr></table></figure><p>使配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -a<br></code></pre></td></tr></table></figure><p>挂载完成后就可以愉快的用 yum 来安装软件了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install httpd<br></code></pre></td></tr></table></figure><hr><p>这就是没养成记笔记习惯的坏处<br>如果之前做的时候把笔记记在电脑上,也不至于现在要用的时候狼狈的浪费时间去重新学习 ｜−・;）</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>yum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Obsidian笔记方案</title>
    <link href="/2023/03/26/Obsidian%E7%AC%94%E8%AE%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2023/03/26/Obsidian%E7%AC%94%E8%AE%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="目前笔记方案"><a href="#目前笔记方案" class="headerlink" title="目前笔记方案"></a>目前笔记方案</h1><p>一个月前,还用着 Notion 作我的笔记,虽然 Notion 的功能十分强大,我也用了一年多了,但是我还是不得不放弃使用 Notion,转向现在正在用的 Obsidian<br>之所以不再使用 Notion 是因为它的一个致命的问题(至少对我来说) —— 它不支持本地保存<br>Notion 的每一次访问都要向它的服务器发送请求以获取笔记文件,本地没有任何缓存,如果我要查看我的笔记,而网络恰好不怎么流畅的时候,光加载出文字就已经很吃力了,在加载几张图片,那可是十分令人头疼的一件事<br>而且 Notion 的服务器是位于国外的,访问就慢了一道<br>万一哪天它出了什么问题,比如服务器崩溃了,删库跑路了,我的笔记可就再也会不来了<br>所以转移笔记迫在眉睫,于是我就转向了现在的 Obsidian 方案,到目前为止已经用了一个多月了,体验起来很不错</p><span id="more"></span><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>Arch Linux 官方库是有现成的包可以直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S obsidian <br></code></pre></td></tr></table></figure><p>手机上可以在 Play 商店里面直接安装<br><img src="/img/2023-3-26-1.jpg" alt="Play 商店直接搜索就有了"></p><h1 id="笔记同步及备份方案"><a href="#笔记同步及备份方案" class="headerlink" title="笔记同步及备份方案"></a>笔记同步及备份方案</h1><p>软件使用起来很简单,创建一个目录就可以开始记笔记了,可是如果仅仅止步于此的话,那么各个终端的笔记是不能共享的,而且万一丢失了,也是没有备份的,所以需要做好笔记的同步和备份</p><h2 id="使用-Github-备份"><a href="#使用-Github-备份" class="headerlink" title="使用 Github 备份"></a>使用 Github 备份</h2><p>首先在 GitHub 上创建一个项目,并拉取到本地,完成必要的初始化<br>Obsidian 设置根目录为该项目路径<br>然后在 Obsidian 中选择 <code>设置</code> -&gt; <code>第三发插件</code> -&gt; <code>社区插件市场</code> -&gt; <code>安装 Obsidian Git</code><br>第一次安装第三方插件时会提醒关闭安全模式,关闭即可<br>然后在第三方插件里面开启 Obsidian Git,重启软件,这样就可以把笔记同步到自己的 GitHub 的项目里面了</p><p>手机上的步骤类似,不过手机上设置 GitHub 账号用的不是 GitHub 的密码,而是 <code>Personal access tokens</code><br>可以在 GitHub 网页端 <code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>Personal access tokens</code> 中创建一个<br>然后在拉取镜像的时候按步骤填写信息就可以了<br>注意在拉取镜像的时候不能使用 SSH 链接(<a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#111;&#x6d;">git@github.com</a>:XXXX&#x2F;XXXX.git),而应该使用 HTTPS 链接(<a href="https://github.com/XXXX/XXXX.git">https://github.com/XXXX/XXXX.git</a>)</p><h2 id="使用-WebDAV-同步即备份"><a href="#使用-WebDAV-同步即备份" class="headerlink" title="使用 WebDAV 同步即备份"></a>使用 WebDAV 同步即备份</h2><p>我使用的 WebDAV 是我通过阿里云盘自建的,如果有其他的 WebDAV 资源可以跳过搭建</p><h3 id="Docker-搭建阿里云盘-WebDAV"><a href="#Docker-搭建阿里云盘-WebDAV" class="headerlink" title="Docker 搭建阿里云盘 WebDAV"></a>Docker 搭建阿里云盘 WebDAV</h3><p>GitHub 上刚好有项目可把阿里云盘当成 WebDAV 来使用,<a href="https://github.com/messense/aliyundrive-webdav">项目地址</a><br>而且还能用 Docker 搭建,特别方便<br>按照项目的 README 获取到 tocken 后执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=aliyundrive-webdav \<br>--restart=unless-stopped -p 28080:8080 \<br>-v /etc/aliyundrive-webdav/:/etc/aliyundrive-webdav/ \<br>-e REFRESH_TOKEN=&#x27;My_TOKENS&#x27; \<br>-e WEBDAV_AUTH_USER=Username \<br>-e WEBDAV_AUTH_PASSWORD=Password \<br>messense/aliyundrive-webdav<br></code></pre></td></tr></table></figure><ul><li>用户名和密码选项可以删除,即不需要账号和密码</li></ul><h3 id="安装并配置-Remotely-Save"><a href="#安装并配置-Remotely-Save" class="headerlink" title="安装并配置 Remotely Save"></a>安装并配置 Remotely Save</h3><p>在 Obsidian 中安装 Remotely Save 第三方插件<br>安装好后进行设置,选择远程服务设置为 WebDAV<br>服务器地址设置为 <code>http://IP-ADDRESS:28080/</code><br>填入用户名和密码就可以使用了</p><p>手机和电脑上设置同一个 WebDAV 服务器就可以在各终端间实现同步和数据备份了</p><hr><p>还好发现 Notion 的这一大缺点早,不然等以后用的多了,想把笔记迁移都困难<br>现在笔记都已经全部迁移到了 Obsidian 中,目前为止使用起来还是很顺手的 (´∀｀*)</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>syncthing设备间文件同步</title>
    <link href="/2023/02/26/syncthing%E8%AE%BE%E5%A4%87%E9%97%B4%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/02/26/syncthing%E8%AE%BE%E5%A4%87%E9%97%B4%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="发现了新的文件传输方案"><a href="#发现了新的文件传输方案" class="headerlink" title="发现了新的文件传输方案"></a>发现了新的文件传输方案</h2><p>本来是想搭建一个记笔记的平台的,但是一直无法解决同步问题,于是发现了 syncthing 这样一款文件同步软件<br>虽然这个并没有完美符合我对记笔记的备份需求,但是它本身的功能就很方便,可以一试</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Arch Linux 的官方库可以直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S syncthing<br></code></pre></td></tr></table></figure><p>手机上可以在 F-Droid 里面安装<br><img src="/img/2023-2-26-1.jpg"></p><h2 id="添加设备"><a href="#添加设备" class="headerlink" title="添加设备"></a>添加设备</h2><p>电脑直接运行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">syncthing<br></code></pre></td></tr></table></figure><p>这样就可以打开浏览器访问 <code>localhost:8384</code><br>在此获取到设备 ID<br><img src="/img/2023-2-26-4.jpg"></p><p>在此添加手机<br><img src="/img/2023-2-26-5.jpg"></p><p><img src="/img/2023-2-26-6.jpg"></p><p>手机上在这里获取设备 ID<br><img src="/img/2023-2-26-2.jpg" alt="点击这里复制标识码"></p><p>手机上在此添加电脑<br><img src="/img/2023-2-26-8.jpg"></p><h2 id="添加共享目录"><a href="#添加共享目录" class="headerlink" title="添加共享目录"></a>添加共享目录</h2><p>电脑上添加共享目录<br><img src="/img/2023-2-26-7.jpg"></p><p>手机上添加准备用来共享的文件夹<br><img src="/img/2023-2-26-3.jpg"></p><p>这样手机和电脑上的 syncthing 同时运行的时候,共享文件夹里面的文件就会自动同步了</p><hr><p>本来想要用来做同步笔记的,但是还是无法满足我的需求<br>虽然现在的记笔记方案不需要用 syncthing,但是用来电脑和手机间传文件还是蛮方便的 （・ω・&#x3D;）</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>syncthing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker搭建jellyfin并使用kodi播放</title>
    <link href="/2023/01/18/Docker%E6%90%AD%E5%BB%BAjellyfin%E5%B9%B6%E4%BD%BF%E7%94%A8kodi%E6%92%AD%E6%94%BE/"/>
    <url>/2023/01/18/Docker%E6%90%AD%E5%BB%BAjellyfin%E5%B9%B6%E4%BD%BF%E7%94%A8kodi%E6%92%AD%E6%94%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="还是回到了-Jellyfin"><a href="#还是回到了-Jellyfin" class="headerlink" title="还是回到了 Jellyfin"></a>还是回到了 Jellyfin</h2><p>一些插件只能Jellyfin用,果然还是应该拥抱开源啊,所以我从 Emby 跳回了 Jellyfin<br>之所以重新使用 Jellyfin,是因为 Emby 无法获取番剧的封面图,介绍等信息,也不是 Emby 不行,应该说是 Emby 可以用的插件对中文支持度不高<br>插件 <a href="https://github.com/kookxiang/jellyfin-plugin-bangumi">jellyfin-plugin-bangumi</a> 可以通过 <a href="https://bangumi.tv/">bangumi</a> 的 ID 来获取信息,而且国内可以直连,但是 Emby 不支持手动安装插件,所以无法使用,这也是为什么我又回到 Jellyfin 的原因</p><span id="more"></span><p><img src="/img/2023-1-18-1.png" alt="效果明显"><br><img src="/img/2023-1-18-2.png" alt="封面图自动获取"><br><img src="/img/2023-1-18-3.png" alt="剧集信息自动获取"></p><h2 id="搭建-Jellyfin"><a href="#搭建-Jellyfin" class="headerlink" title="搭建 Jellyfin"></a>搭建 Jellyfin</h2><p>很久以前我写过如何用 Docker 搭建 Jellyfin,这次我直接用 Docker-Compose 来搭建,可以直接替换自动追番里面的 Emby 配置<br>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull jellyfin/jellyfin:latest<br></code></pre></td></tr></table></figure><p>编辑 docker-compose.yaml 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;233&quot;</span><br><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">jellyfin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">jellyfin/jellyfin:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">jellyfin</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-number">1000</span><span class="hljs-string">:1000</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">&#x27;host&#x27;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/jellyfin-config:/config</span> <span class="hljs-comment"># Jellyfin 配置文件目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/jellyfin-cache:/cache</span> <span class="hljs-comment"># Jellyfin 缓存文件目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/disk:/media</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">&#x27;unless-stopped&#x27;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http_proxy=http://127.0.0.1:2333</span> <span class="hljs-comment"># 代理地址,如果没有则删除本行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">https_proxy=http://127.0.0.1:2333</span> <span class="hljs-comment"># 代理地址,如果没有则删除本行</span><br>    <span class="hljs-attr">extra_hosts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;host.docker.internal:host-gateway&quot;</span><br></code></pre></td></tr></table></figure><p>创建并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker compose up -d<br></code></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>容器创建好后,浏览器打开 <code>IP:8096</code><br>除了先不要导入媒体库以外,其他的按照自己需求设置就好了,设置完成后进入控制台,选择插件,添加插件库<br>仓库地址为 <code>https://jellyfin-plugin-bangumi.pages.dev/repository.json</code><br><img src="/img/2023-1-18-4.png"></p><p>这样就可以在列表里面找到 Bangumi 的插件了,此处由于网络原因可能要等一段时间,有条件的可以在创建容器的时候设置代理地址<br>选择并安装插件<br><img src="/img/2023-1-18-5.png"></p><p>插件安装完成后要重启一次 Jellyfin,直接重启 Docker 容器就好了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart jellyfin<br></code></pre></td></tr></table></figure><p>现在就可以添加媒体库了,因为是用来看番剧的,所以类型选择 Shows(电视节目)<br><img src="/img/2023-1-18-6.png"></p><p>元数据获取都把刚才安装的 Bangumi 放在第一位<br><img src="/img/2023-1-18-7.png"></p><p>然后扫描一遍媒体库就搞定了</p><h2 id="Kodi-安装-Jellyfin-插件"><a href="#Kodi-安装-Jellyfin-插件" class="headerlink" title="Kodi 安装 Jellyfin 插件"></a>Kodi 安装 Jellyfin 插件</h2><p>和 Emby 一样,如果通过浏览器直接观看,CPU 会直接跑满,所以我还是选择了用 Kodi 来观看番剧<br>添加 Jellyfin 文件源 <code>https://kodi.jellyfin.org/</code><br><img src="/img/2023-1-18-8.png"></p><p>从 Jellyfin 文件源中安装 <code>repository.jellyfin.kodi.zip</code><br><img src="/img/2023-1-18-9.png"></p><p>在新添加的 Jellyfin 库中安装 Jellyfin<br><img src="/img/2023-1-18-10.png"></p><p>安装完成后会自动弹出登陆窗口,输入用户名和密码后,导入剧集就完成了<br><img src="/img/2023-1-18-11.png"></p><p>外挂字幕可以正常使用,也没有乱码<br><img src="/img/2023-1-18-12.png" alt="还是用的幸运星做例子"></p><p>可以安装Kodi Sync Queue插件让 Kodi 自动同步 Jellyfin 的数据更改<br>安装后也要重启 Jellyfin<br><img src="/img/2023-1-18-13.png"></p><hr><p>用了一段时间的 Emby 后,我的剧集全是文件夹,哪有什么海报墙,应该叫文件夹墙<br>而改成了 Jellyfiin + Bangumi 插件后,才算是有了海报墙,令人赏心悦目 (つ´ω`)つ<br>到目前为止,也没有特别需要 Emby 的高级功能,能用就行,所以我就很丝滑的转 Jellyfin 了 ( •́ὤ•̀)</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Jellyfin</tag>
      
      <tag>Kodi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kodi播放Emby视频无法外挂字幕</title>
    <link href="/2023/01/08/Kodi%E6%92%AD%E6%94%BEEmby%E8%A7%86%E9%A2%91%E6%97%A0%E6%B3%95%E5%A4%96%E6%8C%82%E5%AD%97%E5%B9%95/"/>
    <url>/2023/01/08/Kodi%E6%92%AD%E6%94%BEEmby%E8%A7%86%E9%A2%91%E6%97%A0%E6%B3%95%E5%A4%96%E6%8C%82%E5%AD%97%E5%B9%95/</url>
    
    <content type="html"><![CDATA[<h2 id="找到了一个很棒的播放器"><a href="#找到了一个很棒的播放器" class="headerlink" title="找到了一个很棒的播放器"></a>找到了一个很棒的播放器</h2><p>在尝试了多个可以播放 Emby 视频的播放器后,还是选中了 Kodi<br>Kodi 可以在 Linux 上用,也可以在 Android 上用,而且配置起来一样<br>刚开始用 Kodi 时觉得功能都很不错,除了不能外挂 Emby 服务器上的字幕让我接受不来<br>学习了一段时间后,发现不是 Kodi 的问题,是我的问题 (。﹏。*)<br>Kodi 还是可以使用 Emby 端的外挂字幕的,记录一下解决过程,免得以后再次踩坑</p><span id="more"></span><h2 id="事先准备"><a href="#事先准备" class="headerlink" title="事先准备"></a>事先准备</h2><p>先安装 Kodi,Arch Linux 库里面有 Kodi,可以直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S kodi<br></code></pre></td></tr></table></figure><p>Kodi 可以设置中文,不过建议最后设置,否则会出现乱码的情况</p><h2 id="Kodi-添加-Emby-源"><a href="#Kodi-添加-Emby-源" class="headerlink" title="Kodi 添加 Emby 源"></a>Kodi 添加 Emby 源</h2><p>打开 Kodi,进入设置<br><img src="/img/2023-1-8-1.png"></p><p>选择文件管理<br><img src="/img/2023-1-8-2.png"></p><p>选择添加源<br><img src="/img/2023-1-8-3.png"></p><p>添加如下 Emby 源<br><img src="/img/2023-1-8-4.png"></p><h2 id="安装-Emby-插件"><a href="#安装-Emby-插件" class="headerlink" title="安装 Emby 插件"></a>安装 Emby 插件</h2><p>选择插件<br><img src="/img/2023-1-8-5.png"></p><p>从 zip 文件安装,如果第一次安装会提醒从 zip 安装不安全,需要设置允许安装<br><img src="/img/2023-1-8-6.png"></p><p>选择 Emby 源<br><img src="/img/2023-1-8-7.png"></p><p>安装第二个稳定版,第一个 beta 版是测试版,可能不稳定<br><img src="/img/2023-1-8-8.png"></p><p>然后再选择从库安装<br><img src="/img/2023-1-8-9.png"></p><p>选择刚才安装的 Emby 库<br><img src="/img/2023-1-8-10.png"></p><p>安装视频插件<br><img src="/img/2023-1-8-11.png"></p><p>安装第一个 Emby 插件<br><img src="/img/2023-1-8-12.png"></p><p>安装完成后会弹出是否安装需要的其他插件,选择 yes 安装即可<br>选择 Emby 的模式时,使用默认,即插件<br>此时会有登陆的弹窗,可以现在就登陆,如果选择不登陆,后面也可以登陆<br><img src="/img/2023-1-8-13.png"></p><h2 id="安装皮肤"><a href="#安装皮肤" class="headerlink" title="安装皮肤"></a>安装皮肤</h2><p>还是在 Emby 的库里面,选择界面外观<br><img src="/img/2023-1-8-14.png"></p><p>选择皮肤<br><img src="/img/2023-1-8-15.png"></p><p>安装里面唯一一个的皮肤<br><img src="/img/2023-1-8-16.png"></p><p>切换为这个皮肤<br><img src="/img/2023-1-8-17.png"></p><p>后面会请求是否要安装 EmbyCon,选择 yes,否则无法使用 Emby 服务端的外挂字幕<br>对,坑就是网上教的都是安装皮肤,但不说是否安装这个插件<br>按照网上的教程来做,如果正好选择了同意安装这个插件,那就不会遇到无法外挂字幕的问题,如果没有安装就得到 Emby 库中自行安装<br>不过这样也好,用 Emby 的皮肤来使用 Emby 更方便一点,所以大部分人就默认会安装插件了</p><h2 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a>设置中文</h2><p>中文在最开始就可以设置,网上的教程在一开始就设置为中文,但是在安装完皮肤后会使用默认的字符编码,导致中文乱码,想要设置回去就需要在一堆乱码中找到正确的按钮,所以建议设置完皮肤后再设置中文<br>选择设置<br><img src="/img/2023-1-8-18.png"></p><p>选择界面<br><img src="/img/2023-1-8-19.png"></p><p>设置字体<br><img src="/img/2023-1-8-20.png"></p><p>设置为 Arial<br><img src="/img/2023-1-8-21.png"></p><p>然后在区域中选择语言<br><img src="/img/2023-1-8-22.png"></p><p>设置为简体中文<br><img src="/img/2023-1-8-23.png"></p><h2 id="登陆-Emby"><a href="#登陆-Emby" class="headerlink" title="登陆 Emby"></a>登陆 Emby</h2><p>如果前面没有登陆,此时可以登陆了<br>选择插件<br><img src="/img/2023-1-8-24.png"></p><p>选择我的插件<br><img src="/img/2023-1-8-25.png"></p><p>视频插件<br><img src="/img/2023-1-8-26.png"></p><p>选择刚才安装的 Emby 插件<br><img src="/img/2023-1-8-27.png"></p><p>选择连接至服务器<br><img src="/img/2023-1-8-28.png"></p><h2 id="设置完毕"><a href="#设置完毕" class="headerlink" title="设置完毕"></a>设置完毕</h2><p>现在就可以在播放 Emby 的视频的时候使用服务端的外挂字幕,而不用客户端上传字幕文件了<br><img src="/img/2023-1-8-29.png" alt="还是用的幸运星来做演示"></p><hr><p>搭建好了视频下载和播放环境后,发现客户端不行<br>emmm… Android 端的 Emby for Android 倒是可以用,但是 Linux 端就一言难尽了 o(￣┰￣<em>)ゞ<br>Linux 端的播放器怎么说呢,就是不行,所以其实我是在寻找 Linux 端的播放器 (°ー°〃)<br>不过 Android 上也可以用 Kodi,设置步骤都是一样的 o(</em>￣▽￣*)ブ<br>网上都说用 Kodi,我一开始也是用了的,但就是踩了乱码和外挂字幕的坑,所以就搁置了 Kodi 的方案<br>没想到在我不服气的情况下再次尝试使用 Kodi 时,误打误撞的成功使用了 Emby 端的外挂字幕<br>这刚踩的坑还正好解决了,不记录下来怎么行,万一以后忘了呢 ( ﹁ ﹁ ) ~→</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emby</tag>
      
      <tag>Kodi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动找番追番</title>
    <link href="/2023/01/05/%E8%87%AA%E5%8A%A8%E6%89%BE%E7%95%AA%E8%BF%BD%E7%95%AA/"/>
    <url>/2023/01/05/%E8%87%AA%E5%8A%A8%E6%89%BE%E7%95%AA%E8%BF%BD%E7%95%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="整个过程完整记录"><a href="#整个过程完整记录" class="headerlink" title="整个过程完整记录"></a>整个过程完整记录</h1><p>刚把我的自自动追番搞定,回头看过来十分的繁琐,所以我写了个 docker-compose 来简化 Docker 容器的创建<br>顺便把整个流程走一遍,记录一下我的搭建过程<br>docker-compose 放在文章的最后</p><span id="more"></span><h1 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h1><p>将一个普通用户添加到 Docker 组中,最好不要使用 root 用户来运行 Docker<br>我直接用的第一个创建的普通用户,所以 uid 和 gid 均为 1000</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -a -G docker &lt;uername&gt;<br></code></pre></td></tr></table></figure><p>选择一个目录,我是直接挂载了一块硬盘到了根目录下的 <code>/disk</code> 目录<br>目录选择好后,在目录下创建需要的目录,比如各种媒体文件的分类和下载目录</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">disk<br>├── anime<br>├── downloads<br>├── movie<br>└── tv<br></code></pre></td></tr></table></figure><p>创建好后,更改整个目录的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R 1000:1000 /disk<br>chmod -R a=,a+rX,u+w,g+w /disk<br></code></pre></td></tr></table></figure><h1 id="Jackett-设置"><a href="#Jackett-设置" class="headerlink" title="Jackett 设置"></a>Jackett 设置</h1><p>添加 indexer 就不用说了,点击 Add indexer 寻找资源网站添加进来就可以了<br>Jackett 需要的就是每一行 indexer 的 <code>Copy Torznab Feed</code> 和右上角的 <code>API Key</code></p><p>如果有条件,可以在下面设置 Proxy(代理)和 FlareSolverr<br>代理不用说, FlareSolverr 是为了绕过一些网站的防 DDoS 的防火墙的, docker-compose 里面会有,如果选择不搭建 FlareSolverr,则不用填</p><h1 id="qBittorrent-设置"><a href="#qBittorrent-设置" class="headerlink" title="qBittorrent 设置"></a>qBittorrent 设置</h1><p>由于sonarr 和 Auto-Bangumi 对 qBittorrent 的设置要求有冲突,为了同时使用它们,所以需要搭建两个 qBittorrent<br>区别就是 Default Torrent Management Mode(默认种子管理模式) Auto-Bangumi 要求设置为 Manual(手动),sonarr 要求设置为 Automatic(自动)</p><p><img src="/img/2023-1-5-1.png" alt="Auto-Bangumi的qBittorrent设置"><br><img src="/img/2023-1-5-2.png" alt="sonarr的qBittorrent设置"></p><h1 id="sonarr-设置"><a href="#sonarr-设置" class="headerlink" title="sonarr 设置"></a>sonarr 设置</h1><h2 id="Media-Management"><a href="#Media-Management" class="headerlink" title="Media Management"></a>Media Management</h2><p>开启 Rename Episodes (重命名剧集),开启 Use Hardlinks instead of Copy(硬链接),和挂载硬盘<br><img src="/img/2023-1-5-3.png" alt="挂载除了downloads的其他分类目录"></p><h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><p>设置 any 为自己想要的资源清晰度,可以看情况是否开启 Upgrades Allowed(允许升级) 为某一目标清晰度<br><img src="/img/2023-1-5-4.png"></p><p>如果想要中文,则添加中文<br><img src="/img/2023-1-5-5.png"></p><h1 id="Indexers"><a href="#Indexers" class="headerlink" title="Indexers"></a>Indexers</h1><p>添加 Torznab<br><img src="/img/2023-1-5-6.png"></p><p>URL 为 Jackett 中的 <code>Copy Torznab Feed</code>, API Key 为右上角的 <code>API Key</code></p><h1 id="Download-Clients"><a href="#Download-Clients" class="headerlink" title="Download Clients"></a>Download Clients</h1><p>添加 qBittorrent,注意添加的是给 sonarr 用的 qBittorrent 的地址和端口,用户名默认为 admin 密码默认为 adminadmin<br>Remote Path Mappings 中 Remote Path 设置为 qBittorrent 的下载目录和 sonarr 容器的下载目录<br><img src="/img/2023-1-5-7.png"></p><h1 id="emby-设置"><a href="#emby-设置" class="headerlink" title="emby 设置"></a>emby 设置</h1><p>设置中文,按照自己喜欢的配置来设置,除了添加媒体库的时候,内容类型选择电视节目<br>文件夹为 <code>/mnt/share1</code> 下的各个目录</p><h1 id="Auto-Bangumi"><a href="#Auto-Bangumi" class="headerlink" title="Auto-Bangumi"></a>Auto-Bangumi</h1><p>没什么需要配置的,创建容器后启动就可以了 (&#x3D;・ω・&#x3D;)</p><h1 id="创建并运行-Docker-容器"><a href="#创建并运行-Docker-容器" class="headerlink" title="创建并运行 Docker 容器"></a>创建并运行 Docker 容器</h1><p>所有的配置到这就差不多结束了,最后根据一些自己的习惯设置一下就完成了<br>这篇文章之所以这么简单,是因为前面的文章我都有细节的设置,这里只是做了一个总结<br>docker-compose 设置如下,里面一些东西根据自己的实际情况修改就可以了</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;233&quot;</span><br><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">jackett:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">linuxserver/jackett:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">jackett</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PUID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PGID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/jackett-config:/config</span> <span class="hljs-comment"># jackett 的配置文件目录</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">9117</span><span class="hljs-string">:9117</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br><br>  <span class="hljs-attr">qbittorrent-for-auto-bangumi:</span> <span class="hljs-comment"># Auto-Bangumi 使用的 qBittorrent</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">linuxserver/qbittorrent:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">qbittorrent-for-auto-bangumi</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PUID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PGID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">WEBUI_PORT=8080</span> <span class="hljs-comment"># WebUI 端口</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/qbittorrent-for-auto-bangumi-config:/config</span> <span class="hljs-comment"># qbittorrent-for-auto-bangumi 的配置文件目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/disk:/disk</span> <span class="hljs-comment"># 目录映射</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span> <span class="hljs-comment"># 此处端口映射必须和 WebUI 的端口一致</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">6881</span><span class="hljs-string">:6881</span> <span class="hljs-comment"># TCP 连接端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">6881</span><span class="hljs-string">:6881/udp</span> <span class="hljs-comment"># UDP 连接端口</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br><br>  <span class="hljs-attr">qbittorrent-for-sonarr:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">linuxserver/qbittorrent:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">qbittorrent-for-sonarr</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PUID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PGID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">WEBUI_PORT=18080</span> <span class="hljs-comment"># WebUI 端口</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/qbittorrent-for-sonarr-config:/config</span> <span class="hljs-comment"># qbittorrent-for-sonarr 的配置文件目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/disk:/disk</span> <span class="hljs-comment"># 目录映射</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">18080</span><span class="hljs-string">:18080</span> <span class="hljs-comment"># 此处端口映射必须和 WebUI 的端口一致</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">16881</span><span class="hljs-string">:16881</span> <span class="hljs-comment"># TCP 连接端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">16881</span><span class="hljs-string">:16881/udp</span> <span class="hljs-comment"># UDP 连接端口</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br><br>  <span class="hljs-attr">sonarr:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">linuxserver/sonarr:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">sonarr</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PUID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PGID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/sonarr-config:/config</span> <span class="hljs-comment"># sonarr 的配置文件目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/disk:/disk</span> <span class="hljs-comment"># 目录映射</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/disk/downloads:/downloads</span> <span class="hljs-comment"># 下载目录</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8989</span><span class="hljs-string">:8989</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br><br>  <span class="hljs-attr">emby:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">emby/embyserver:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">embyserver</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">UID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GIDLIST=1000,0</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">HTTP_PROXY=http://127.0.0.1:2333</span> <span class="hljs-comment"># 代理地址,如果没有则删除本行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">All_PROXY=http://127.0.0.1:2333</span> <span class="hljs-comment"># 代理地址,如果没有则删除本行</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/emby-config:/config</span> <span class="hljs-comment"># emby 的配置文件目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/disk:/mnt/share1</span> <span class="hljs-comment"># 映射媒体文件的目录</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8096</span><span class="hljs-string">:8096</span><br>    <span class="hljs-attr">devices:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/dev/dri:/dev/dri</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br><br>  <span class="hljs-attr">AutoBangumi:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">estrellaxd/auto_bangumi:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">AutoBangumi</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">7892</span><span class="hljs-string">:7892</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">qbittorrent-for-auto-bangumi</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/auto-bangumi-config:/config</span> <span class="hljs-comment"># Auto-Bangumi 的配置文件目录</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PUID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PGID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DOWNLOADER_HOST=192.168.2.33:8080</span> <span class="hljs-comment"># qbittorrent-for-auto-bangumi 的地址</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DOWNLOADER_USERNAME=admin</span> <span class="hljs-comment"># 默认用户名 admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DOWNLOADER_PASSWORD=adminadmin</span> <span class="hljs-comment"># 默认密码 adminadmin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_INTERVAL_TIME=3600</span> <span class="hljs-comment"># 解析器的运行间隔时间,单位为秒</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_RENAME_FREQ=20</span> <span class="hljs-comment"># 在一个运行周期内重命名频率</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_METHOD=Advance</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_GROUP_TAG=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_NOT_CONTAIN=720|繁体|CHT|JPTC|繁日|\d+-\d+|BIG5|简繁内封|CHS&amp;CHT</span> <span class="hljs-comment"># RSS 屏蔽规则</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DOWNLOAD_PATH=/disk/downloads/auto-bangumi</span> <span class="hljs-comment"># 文件下载的目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_RSS=https://mikanani.me/RSS/MyBangumi?token=</span> <span class="hljs-comment"># RSS 地址</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DEBUG_MODE=False</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_EP_COMPLETE=True</span> <span class="hljs-comment"># 历史番剧下载,开启后,将会下载已加入时之前的剧集</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_WEBUI_PORT=7892</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_RENAME=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_ENABLE_TMDB=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_LANGUAGE=zh</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_HTTP_PROXY=http://127.0.0.1:2333</span> <span class="hljs-comment"># 代理地址,如果没有则删除本行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_RSS_COLLECTOR=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_REMOVE_BAD_BT=True</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br><br>  <span class="hljs-attr">flaresolverr:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">ghcr.io/flaresolverr/flaresolverr:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">flaresolverr</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8191</span><span class="hljs-string">:8191</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LOG_LEVEL=info</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http_proxy=http://127.0.0.1:2333</span> <span class="hljs-comment"># 代理地址,如果没有则删除本行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">all_proxy=http://127.0.0.1:2333</span> <span class="hljs-comment"># 代理地址,如果没有则删除本行</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br><br>  <span class="hljs-attr">watchtower:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">containrrr/watchtower</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">watchtower</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--cleanup</span> <span class="hljs-string">--schedule</span> <span class="hljs-string">&#x27;0 0 4 * * *&#x27;</span> <span class="hljs-comment"># watchtower 命令</span><br></code></pre></td></tr></table></figure><p>设置完成后,运行命令,创建并运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker compose up -d<br></code></pre></td></tr></table></figure><p>这样以后就可以用 sonarr 补番,用 Auto-Bangumi 追番了</p><hr><p>这样以后在别的 Linux 主机上,我就可以很快速的搭建起我的追番方案了 (~￣▽￣)~<br>如果在用到过程中碰到了什么小细节忘了怎么设置的,还可以往前翻,很快就可以搞定的,不说了,该看番了 []~（￣▽￣）~*</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker Compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 搭建auto-bangumi</title>
    <link href="/2023/01/04/Docker-%E6%90%AD%E5%BB%BAauto-bangumi/"/>
    <url>/2023/01/04/Docker-%E6%90%AD%E5%BB%BAauto-bangumi/</url>
    
    <content type="html"><![CDATA[<h2 id="自动追番工具"><a href="#自动追番工具" class="headerlink" title="自动追番工具"></a>自动追番工具</h2><p>通过 auto-bangumi 可以实现自动下载,自动整理,重命名等工作,只需要在 <a href="https://mikanani.me/">Mikan Project</a> 上订阅想要追的番剧,就可以这样的全自动追番<br>部署起来也很简单,只是有一些小细节需要注意,否则会踩坑</p><span id="more"></span><h2 id="获取RSS地址"><a href="#获取RSS地址" class="headerlink" title="获取RSS地址"></a>获取RSS地址</h2><p>前往 <a href="https://mikanani.me/">Mikan Project</a> 注册一个账号<br>注册好后进入账号设置,开启高级订阅<br><img src="/img/2023-1-4-1.png"></p><p>订阅一些新番,这样就可以在 <code>我的字幕组订阅更新</code> 的右下角找到 RSS 地址了<br>复制下来,后面要用<br><img src="/img/2023-1-4-2.png"></p><h2 id="qBittorrent-设置"><a href="#qBittorrent-设置" class="headerlink" title="qBittorrent 设置"></a>qBittorrent 设置</h2><p>建议开启一个新的 qBittorrent 来使用,此处的设置与 sonarr 相冲突<br>qBittorrent 的默认下载模式设置为 Manual(手动)<br><img src="/img/2023-1-4-3.png"></p><h2 id="部署-Auto-Bangumi"><a href="#部署-Auto-Bangumi" class="headerlink" title="部署 Auto-Bangumi"></a>部署 Auto-Bangumi</h2><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull estrellaxd/auto_bangumi:latest<br></code></pre></td></tr></table></figure><p>官方给的 docker 命令行我尝试过了几次,总是会有各种各样的小毛病,索性用了另外一种方式,docker compose<br>Arch Linux 安装还是很简单的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S docker-compose<br></code></pre></td></tr></table></figure><p>创建一个存放 yaml 文件的目录,在里面创建 docker-compose.yaml 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir AutoBangumi<br>touch docker-compose.yaml<br></code></pre></td></tr></table></figure><p>按实际情况编辑如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">AutoBangumi:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">estrellaxd/auto_bangumi:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">AutoBangumi</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">7892</span><span class="hljs-string">:7892</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">qbittorrent</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">path-to-autobangumi-config:/config</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PUID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PGID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DOWNLOADER_HOST=ip:port</span> <span class="hljs-comment"># qBittorrent的地址</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DOWNLOADER_USERNAME=admin</span> <span class="hljs-comment"># 用户名,qbittorrent默认为admin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DOWNLOADER_PASSWORD=adminadmin</span> <span class="hljs-comment"># 密码,qbittorrent默认为adminadmin</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_INTERVAL_TIME=3600</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_RENAME_FREQ=20</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_METHOD=Advance</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_GROUP_TAG=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_NOT_CONTAIN=720|繁体|CHT|JPTC|繁日|\d+-\d+|BIG5</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DOWNLOAD_PATH=/disk/downloads/auto-bangumi</span> <span class="hljs-comment"># 下载地址</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_RSS=https://mikanani.me/RSS/MyBangumi?token=</span> <span class="hljs-comment"># RSS 地址</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_DEBUG_MODE=False</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_EP_COMPLETE=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_WEBUI_PORT=7892</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_RENAME=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_ENABLE_TMDB=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_LANGUAGE=zh</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_HTTP_PROXY=http://ip:port</span> <span class="hljs-comment"># 代理地址,没有则删除此行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_RSS_COLLECTOR=True</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AB_REMOVE_BAD_BT=True</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br></code></pre></td></tr></table></figure><p>编辑好后,在 AutoBangumi 目录下创建并运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker compose run -d<br></code></pre></td></tr></table></figure><p>运行成功后,可以打开浏览器进入 <code>服务器ip:7892</code>,可以进入 Auto-Bangumi 的 web 界面<br><img src="/img/2023-1-4-4.png" alt="可以看到我追的两部番剧已经被获取了"></p><p>查看日志,显示搭建完成<br><img src="/img/2023-1-4-5.png"></p><p>等待 qBittorrent 下载完成后,Auto-Bangumi 会自动整理重命名<br><img src="/img/2023-1-4-6.png"></p><p>最后在 emby 中添加 Auto-Bangumi 的目录即可</p><hr><p>终于,我计划了几个月的工程总算完成了 (((o(<em>ﾟ▽ﾟ</em>)o)))<br>以后看番不用再自己动手下载了,靠这些 docker 就可以自动帮我完成,我只需要看就可以了 (づ′▽&#96;)づ<br>不说了,看番去咯 _(:3 」∠ )_</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSS</tag>
      
      <tag>Docker</tag>
      
      <tag>qBittorrent</tag>
      
      <tag>AutoBangumi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker搭建emby播放器</title>
    <link href="/2023/01/03/Docker%E6%90%AD%E5%BB%BAemby%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2023/01/03/Docker%E6%90%AD%E5%BB%BAemby%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h2><p>前面搭建好了视频自动下载器,下载下来可以之间观看,但是我的这些番剧都是放在了我的小主机上的,观看起来还是比较麻烦的<br>于是,我尝试搭建了个 emby 来观看视频<br>其实刚开始我是搭建了 jellyfin 的,但是太多功能不能满足我的需求,所以我还是选择了 emby</p><span id="more"></span><h2 id="搭建emby"><a href="#搭建emby" class="headerlink" title="搭建emby"></a>搭建emby</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull emby/embyserver:latest<br></code></pre></td></tr></table></figure><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>官方在 docker hub 上面有命令可以直接用,但是有些情况不能直接拿来用,要进行修改<br>要根据情况自行删改<br>项目地址 <a href="https://hub.docker.com/r/emby/embyserver">https://hub.docker.com/r/emby/embyserver</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create \<br>--name embyserver \<br>--volume path-to-emby-config:/config \<br>--volume /disk:/mnt/share1 \<br>--net=host \<br>--device /dev/dri:/dev/dri \<br>--publish 8096:8096 \<br>--env UID=1000 \<br>--env GID=1000 \<br>--env GIDLIST=1000,0 \<br>emby/embyserver:latest<br></code></pre></td></tr></table></figure><p>其中 <code>--volume /disk:/mnt/share1</code> 后面的映射目录的格式不能变,只能是 share1,share2…<br>官方的命令里面包含 <code>--device /dev/vchiq:/dev/vchiq</code> 但是我没有加<br>可以通过查看 <code>/dev/vchiq</code> 是否存在来判断是否添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /dev/vchiq<br></code></pre></td></tr></table></figure><h3 id="配置-emby"><a href="#配置-emby" class="headerlink" title="配置 emby"></a>配置 emby</h3><p>容器启动后,浏览器访问 <code>IP:8096</code> 进入 emby<br>语言选择中文后配置起来很方便,按照自己喜欢来配置,除了要注意一个地方<br>在添加媒体库的时候,内容类型选择电视节目,这样重命名后的视频文件才可以被分类<br><img src="/img/2023-1-3-1.png" alt="①处选择电视节目,②处的挂载目录为&#x2F;mnt&#x2F;share1下的目录"></p><p>设置好媒体库后,扫描一下就好了,可以看到 sonarr 归类的视频都整整齐齐的在播放列表里面</p><h2 id="客户端播放"><a href="#客户端播放" class="headerlink" title="客户端播放"></a>客户端播放</h2><p>如果我的小主机再强一点就好了,但是不行,一旦emby播放视频,CPU 就会跑满<br><img src="/img/2023-1-3-2.png" alt="直接进入烤机模式"></p><p>所以我找了找其他的客户端,用流视频的方式播放,发现 CPU 的占用降低了许多<br>电脑上可以使用 jellyfin-media-player 来播放<br>项目地址 <a href="https://github.com/jellyfin/jellyfin-media-player">https://github.com/jellyfin/jellyfin-media-player</a><br>可以通过编译来安装,但是我发现 Arch Linux aur 里面有编译好了的二进制包,可以直接安装,很是方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay jellyfin-media-player <br></code></pre></td></tr></table></figure><p>使用体验和 web 客户端差不多<br><img src="/img/2023-1-3-3.png"><br><img src="/img/2023-1-3-4.png"><br><img src="/img/2023-1-3-5.png" alt="CPU的负担一下就减小了"></p><p>手机端可以下载 Emby For Android,使用起来也不烤机<br><img src="/img/2023-1-3-6.jpg"><br><img src="/img/2023-1-3-7.jpg"></p><hr><p>搭建好了播放器,下载的番剧就可以直接打开看了,不用做任何操作,点开即用 (σﾟ∀ﾟ)σ..:*☆<br>有了这么好的下载器和播放器,这个年可以过的很舒畅了 ( •́ὤ•̀)<br>…<br>话说,下这么多番剧看得完吗 (*ﾟーﾟ)</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Jellyfin</tag>
      
      <tag>emby</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker搭建自动下载器</title>
    <link href="/2022/12/26/Docker%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    <url>/2022/12/26/Docker%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="自动寻找并下载影视"><a href="#自动寻找并下载影视" class="headerlink" title="自动寻找并下载影视"></a>自动寻找并下载影视</h1><p>最近买的12TB的硬盘到手了,测试过后没问题就把它接到了我的小服务器上<br>于是立马开始搭建我期待已久的自动下载器<br>在用 Docker 搭建的过程中,也碰到了许多没碰到过的问题,最后也都解决了这些问题<br>把搭建的过程记录一下,这样以后也能少走点弯路,少踩点坑</p><span id="more"></span><h2 id="jackett-搭建"><a href="#jackett-搭建" class="headerlink" title="jackett 搭建"></a>jackett 搭建</h2><p>jackett 是一个索引器,它可以提供各种资源网站的检索 api,后面 sonarr 可以使用它提供的 api 去对应的资源网站寻找我们需要的资源<br>用 Docker 搭建起来也很简单,建议使用普通用户来使用 Docker,这样更方便和安全</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -a -G docker &lt;uername&gt;<br></code></pre></td></tr></table></figure><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull linuxserver/jackett:latest<br></code></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create \<br>--name=jackett \<br>-e PUID=1000 \<br>-e PGID=1000 \<br>-e TZ=Asia/Shanghai \<br>-p 9117:9117 \<br>-v path-to-jackett-config:/config \<br>--restart unless-stopped \<br>linuxserver/jackett:latest<br></code></pre></td></tr></table></figure><p>PUID 和 PGID 设置为用 Docker 权限的用户的 PUID 和 PGID,使用 <code>id</code> 命令就可以知道了<br><code>path-to-jackett-config</code>文件是 jackett 的配置文件映射,不做也行,但是容器更新的时候,配置也会重置,jackett 的更新特别频繁</p><p>创建好后,运行容器,浏览器打开 <code>服务器ip:9117</code><br>在打开的网页中,点击 <code>Add indexer</code> 来添加资源网站,我经常看番,所以我添加了dmhy(动漫花园)等番剧资源多的网站<br>如果有 pt 等网站的会员,也可以在里面寻找并添加进来<br><img src="/img/2022-12-26-1.png"></p><h2 id="qBittorrent-搭建"><a href="#qBittorrent-搭建" class="headerlink" title="qBittorrent 搭建"></a>qBittorrent 搭建</h2><p>搭建好 jackett 后,继续搭建下载器,这里我使用的是 qBittorrent<br>虽然可以直接用命令自动安装,但我在使用的过程中还是碰到了一些问题,最后我还是选择了用 Docker 搭建一个</p><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull linuxserver/qbittorrent:latest<br></code></pre></td></tr></table></figure><p>选择一个目录用来存放下载的文件,在里面新建一个 downloads 目录,别的名字也行,按个人喜好,我直接用挂载的硬盘来存放下载的文件<br>现在的目录结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">disk<br>└── downloads<br></code></pre></td></tr></table></figure><p>disk是我挂载的硬盘的位置,其实就是一个目录<br>记得将该目录所有者设置为拥有 Docker 权限的用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R 1000:1000 /disk<br>chmod -R a=,a+rX,u+w,g+w /disk<br></code></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create  \<br>--name=qbittorrent  \<br>-e WEBUI_PORT=8080  \<br>-e TZ=Asia/Shanghai \<br>-e PUID=1000 \<br>-e PGID=1000 \<br>-p 6881:6881  \<br>-p 6881:6881/udp  \<br>-p 8080:8080  \<br>-v path-to-qbittorrent-config:/config  \<br>-v /disk/downloads:/downloads  \<br>--restart unless-stopped  \<br>linuxserver/qbittorrent:latest<br></code></pre></td></tr></table></figure><p>启动容器后,浏览器打开 <code>服务器ip:8080</code> 默认账户 admin,密码 adminadmin<br>设置默认下载位置为 <code>/downloads</code> ,这里设置的是 Docker 容器里面的路径,不是真实的路径<br>如下所示<br><img src="/img/2022-12-26-2.png"></p><p><code>注意</code> 此处的默认 Torrent 管理模式要设置为 Automatic(自动)</p><h2 id="sonarr-搭建"><a href="#sonarr-搭建" class="headerlink" title="sonarr 搭建"></a>sonarr 搭建</h2><p>sonarr 如其名,声纳,是一个拿来搜索资源的工具,它可以用来寻找资源,找到后调用下载器下载,下载好后会自动整理文件,非常方便<br>这里也是我踩坑最多的地方,一个不小心就会碰到各种问题</p><p>在用来存放下载文件的目录的同级目录下,创建各种目录,这些目录是用来后面分类用到,随自己喜欢<br>我比较懒,分类就分了三个大类 anime(动画),tv(电视剧),movie(电影)<br>当前目录结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">disk<br>├── anime<br>├── downloads<br>├── movie<br>└── tv<br></code></pre></td></tr></table></figure><p><code>注意</code> 创建新的目录后,记得修改它的权限,否则可能会有无法挂载或无法移动文件的情况发生</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown -R 1000:1000 /disk<br>chmod -R a=,a+rX,u+w,g+w /disk<br></code></pre></td></tr></table></figure><ul><li>-R 递归修改,简单粗暴,一次性全部修改</li></ul><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull linuxserver/sonarr:latest<br></code></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker create \<br>--name=sonarr \<br>-e PUID=1000 \<br>-e PGID=1000 \<br>-e TZ=Asia/Shanghai \<br>-p 8989:8989 \<br>-v path-to-sonarr-config:/config \<br>-v /disk:/disk \<br>-v /disk/downloads:/downloads \<br>--restart unless-stopped \<br>linuxserver/sonarr:latest<br></code></pre></td></tr></table></figure><p>此处挂载了 <code>/disk</code> 后,又挂载了 <code>/disk/downloads</code> 不是错误,一定要挂载,这里我踩了个大坑,如果不挂载,会发生没有权限移动文件的错误,一定要挂载</p><p>启动容器后,浏览器打开 <code>服务器ip:8989</code>,开始配置一些必要的设置</p><h3 id="Media-Management"><a href="#Media-Management" class="headerlink" title="Media Management"></a>Media Management</h3><p>Settings -&gt; Media Management,开启重命名<br><img src="/img/2022-12-26-3.png"></p><p>开启硬链接,如果不开启硬链接,那么 downloads 下会有一份你下载的文件,分类的目录下也会有一份,相当于拷贝了一份过去<br><img src="/img/2022-12-26-11.png"></p><p>如果设置了硬链接,那么在分类的目录下就只是一个指向 downloads 中文件的指针,想了解更多,可以去看看 Linux 的硬链接<br><a href="https://www.runoob.com/note/29134">https://www.runoob.com/note/29134</a></p><p>挂载刚才创建各目录<br><img src="/img/2022-12-26-4.png"></p><h3 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h3><p>Profiles -&gt; Quality Profiles -&gt; Any 设置视频的清晰度,只有勾选了该清晰度,才会被下载<br>Upgrades Allowed 勾选后,如果视频有更高的清晰度时,是否自动更新<br>Upgrade Until 直到这个清晰度为止,都会尝试去升级清晰度<br><img src="/img/2022-12-26-5.png"></p><p>Language Profiles 添加中文<br><img src="/img/2022-12-26-6.png"></p><h3 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h3><p>点击添加,选择 Torznab<br><img src="/img/2022-12-26-7.png"></p><p>URL 是 jackett 那边提供的 indexer 地址<br><img src="/img/2022-12-26-8.png"></p><p>API Key 是 jackett 右上角的 API<br><img src="/img/2022-12-26-9.png"></p><p>Categories 选择想要的类型就可以了,如果不想选择,可以全都要</p><h3 id="Download-Clients"><a href="#Download-Clients" class="headerlink" title="Download Clients"></a>Download Clients</h3><p>添加 qBittorrent<br><img src="/img/2022-12-26-10.png"></p><p>Host 设置为服务器的 IP 地址<br>Port 设置为 8080<br>Username 如果没有修改 qBittorrent 的账户名就设置为 admin<br>Password 设置为 adminadmin</p><p>添加一个 Remote Path Mappings<br>Host 为 qBittorrent<br>Remote Path 为 <code>/downloads/</code><br>Local Path 为 <code>/disk/downloads/</code></p><ul><li>Remote Path 是 qBittorrent 的路径,把它看作 <code>qBittorrent的IP地址:/downloads</code> 就容易理解了,注意这里用的是 Docker 容器内的路径,不是真实的</li><li>Local Path 是 sonarr 的 docker 容器内的地址</li></ul><h2 id="开始找剧集"><a href="#开始找剧集" class="headerlink" title="开始找剧集"></a>开始找剧集</h2><p>搭建完成,可以开启自动找番剧了,最上方输入想要找的名字,英文的<br><img src="/img/2022-12-26-12.png"></p><p>搜索到后,选择并添加,动画的 Series Type 记得选择 Anime,否则可能找不到<br><img src="/img/2022-12-26-13.png"></p><p>添加后就可以在 Series 里面看到了,点击进去可以看到每一季的信息<br>点击放大镜是开始检索,旁边的人像是有多种选择的情况下,手动选择<br><img src="/img/2022-12-26-14.png"></p><p>运行成功的结果如下<br><img src="/img/2022-12-26-15.png" alt="找到了番剧并自动下载"></p><p><img src="/img/2022-12-26-16.png" alt="qBittorrent下载完成"></p><p><img src="/img/2022-12-26-17.png" alt="自动硬链接,可以看到disk的总大小等于anime和download,说明download和anime中文件只存储了一次"></p><h1 id="自动更新-Docker-镜像"><a href="#自动更新-Docker-镜像" class="headerlink" title="自动更新 Docker 镜像"></a>自动更新 Docker 镜像</h1><p>由于镜像会更新,而且有的更新的还很频繁,这就是为什么要把配置文件映射出来了,这样更新镜像的时候,配置不会消失<br>除了手动更新外,还可以自动更新</p><h2 id="Watchtower-搭建"><a href="#Watchtower-搭建" class="headerlink" title="Watchtower 搭建"></a>Watchtower 搭建</h2><p>Watchtower 可以自动检测镜像是否有更新,如果有就会自动拉取新的镜像</p><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull containrrr/watchtower<br></code></pre></td></tr></table></figure><p>运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>--name watchtower \<br>--restart unless-stopped \<br>-v /var/run/docker.sock:/var/run/docker.sock \<br>containrrr/watchtower \<br>--cleanup \<br>--schedule &#x27;0 0 4 * * *&#x27;<br></code></pre></td></tr></table></figure><ul><li>–cleanup 表示拉取新的镜像后删除旧的镜像</li><li>–schedule 使用 Cron 类似的配置,但是有六个参数(cron是5个) 分别代表 <code>秒 分 时 日 月 周</code></li></ul><p>这样所有的容器就会自动更新了 []~（￣▽￣）~*</p><p>如果等不及,可以直接运行一次 watchtower,更新完成后,这个容器会自动删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --rm \<br>-v /var/run/docker.sock:/var/run/docker.sock \<br>containrrr/watchtower -c \<br>--run-once<br></code></pre></td></tr></table></figure><hr><p>想搭建一个自动追番的工具很久了,但是苦于硬盘容量太小,搭不搭的意义不大,所以就搁置了<br>但现在不一样了,我的 12TB 硬盘到货了,可以搞起来了 (&#x3D;^-ω-^&#x3D;)<br>现在还只是搭建了一个下载器,再配一个播放器就大功告成了 ╮&#x2F;(＞▽&lt;)人(&gt;▽＜)╭</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>jackett</tag>
      
      <tag>qBittorrent</tag>
      
      <tag>sonarr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wine运行galgame无声音</title>
    <link href="/2022/12/12/wine%E8%BF%90%E8%A1%8Cgalgame%E6%97%A0%E5%A3%B0%E9%9F%B3/"/>
    <url>/2022/12/12/wine%E8%BF%90%E8%A1%8Cgalgame%E6%97%A0%E5%A3%B0%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="挺久没玩-galgame-了"><a href="#挺久没玩-galgame-了" class="headerlink" title="挺久没玩 galgame 了"></a>挺久没玩 galgame 了</h1><p>自从电脑的系统换成 Linux 之后,就很少玩游戏了,玩也是在 Steam 上下载下来玩,没有了曾经找游戏资源来玩的快乐了<br>加了很多游戏资源群都是安心当一个仓鼠,只收藏,不玩<br>今天心血来潮,下载了个 galgame 来玩,然后尝试用 wine 来玩,但碰到些问题,那就是没有声音<br>没有声音还玩个毛线 galgame 啊!</p><span id="more"></span><h1 id="Arch-Linux-玩-galgame"><a href="#Arch-Linux-玩-galgame" class="headerlink" title="Arch Linux 玩 galgame"></a>Arch Linux 玩 galgame</h1><p>安装 wine</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S wine<br></code></pre></td></tr></table></figure><p>将下载好的游戏全部解压缩到一个目录下,比如下面这样的<br><img src="/img/2022-12-12-1.png" alt="我下的是柚子社的魔女的夜宴（￣▽￣）~*"></p><p>这样就可以运行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wine 游戏运行程序.exe<br></code></pre></td></tr></table></figure><p>然后就可能碰到游戏没有声音的问题,刚开始我以为是游戏内没有开启,但设置了一通后,还是没有声音<br>所以我有理由怀疑是 wine 的问题<br>于是我到 Arch Linux wiki 上寻找解决方法,没想到居然找到了<br><a href="https://wiki.archlinux.org/title/wine">https://wiki.archlinux.org/title/wine</a></p><p>这里面讲到了 wine 可能会没有声音的原因是声音设备没有配置好,而 wine 安装的时候是不会安装声音的驱动的,所以需要自己安装<br><img src="/img/2022-12-12-2.png"></p><p>这里我是 PulseAudio,所以我安装了 lib32-libpulse</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S lib32-libpulse<br></code></pre></td></tr></table></figure><p>然后再次尝试运行游戏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wine 游戏运行程序.exe<br></code></pre></td></tr></table></figure><p>有声音了,截图就不放了,毕竟声音的无法截图嘛（￣ˇ￣）</p><hr><p>总算是想起来可以在电脑上玩 galgame 啊 （。_。）<br>每天都是在手机上玩游戏,清完体力就下线看漫画去了,果然还是在电脑上玩 galgame 更舒服一些啊（　・ˍ・）<br>谁让电脑屏幕比手机大,色彩还更鲜艳呢 （&gt;▽&lt;）</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>wine</tag>
      
      <tag>galgame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Context的使用</title>
    <link href="/2022/12/08/Go-Context%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/12/08/Go-Context%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="总算是理解了-Context"><a href="#总算是理解了-Context" class="headerlink" title="总算是理解了 Context"></a>总算是理解了 Context</h1><p>可以算是理解了 Go 的 Context 了吧,大概…<br>尝试做项目的时候,有时候会碰到 Context 这个东西,但对代码没有什么理解困难,所以就略过没管<br>但学知识怎么能知其然而不知其所以然呢?所以我今天就跟这个 Context 杠上了,一定要理解它到底是干什么的<br>学成归来就把现在的理解给记录下来,免得以后又忘了</p><span id="more"></span><h2 id="优雅地结束-gorouting"><a href="#优雅地结束-gorouting" class="headerlink" title="优雅地结束 gorouting"></a>优雅地结束 gorouting</h2><p>当一个 gorouting 需要结束时,可以使用 channel + select 来停止它,如下代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Select_chan</span><span class="hljs-params">()</span></span> &#123;<br>exit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">byte</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 创建一个 gorouting</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-exit: <span class="hljs-comment">// 当 exit 通道有数据传入时,执行此命令</span><br>fmt.Println(<span class="hljs-string">&quot;exiting...&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;goroutine is running...&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">10</span> * time.Second) <span class="hljs-comment">// 睡眠10秒,模拟程序运行了10秒</span><br>fmt.Println(<span class="hljs-string">&quot;done!&quot;</span>)<br>exit &lt;- <span class="hljs-string">&#x27;Y&#x27;</span> <span class="hljs-comment">// 程序执行完成,向exit传入信号以终止程序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果很明显,每隔2s就会输出一次 <code>goroutine is running...</code>,后在第10s时向 exit 这个 channel 中传入一个数据,select 中的 case 接受到后就会执行后面的代码,即输出 <code>exiting...</code> 并结束掉这个进程<br>利用 channel + select 可以很优雅的结束掉进程,这个场景下,也可以使用 Context 来实现</p><h2 id="使用-Context-优雅地结束-gorouting"><a href="#使用-Context-优雅地结束-gorouting" class="headerlink" title="使用 Context 优雅地结束 gorouting"></a>使用 Context 优雅地结束 gorouting</h2><p>这里使用 Context 很简答,只需要创建一个带结束的 Context,然后把 select 中 case 接受的 channel 改为 ctx.Done(),并在结束进程时调用cancel()就可以了</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Context_fun</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background()) <span class="hljs-comment">// 创建一个带结束的 Context,context.Background()返回一个空Context</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;exiting...&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;gorouting running...&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;(ctx)<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;done!&quot;</span>)<br>cancel()                <span class="hljs-comment">// 调用取消函数,结束掉 gorouting</span><br>time.Sleep(time.Second) <span class="hljs-comment">// 程序结束过快,还没执行到输出语句就结束了,所以睡眠1秒</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果和前面的一样</p><h2 id="多个-Context-的使用"><a href="#多个-Context-的使用" class="headerlink" title="多个 Context 的使用"></a>多个 Context 的使用</h2><p>Context 是一个树形结构的调用关系,每一个 Context 都有自己的父 Context,而根 Context 可以通过 context.Background() 来创建<br>类似于进程,当父进程结束时,它的子进程也要结束并回收资源<br>Context 也是如此,之所以需要使用 Context 是因为 gorouting 创建之后可能不受控制的无限进行下去,导致程序崩溃<br>使用 Context 可以设置在某一条件满足的情况下,结束掉它的父 Context,不管有多少个子 Context 都可以一次性给他结束掉<br>如下代码示例</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Multi_Context</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;one&quot;</span>)<br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;two&quot;</span>)<br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;three&quot;</span>)<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>cancel()<br>time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Just_run</span><span class="hljs-params">(ctx context.Context, name <span class="hljs-type">string</span>)</span></span> &#123; <span class="hljs-comment">// 当传入的参数中有 Context 时,把他放在第一位</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(name + <span class="hljs-string">&quot; has done!&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(name + <span class="hljs-string">&quot; is running!&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个带 cancel 的 Context,把它传给了三个进程,当父 Context 结束完成时,也就是10s后,执行一次 cancel() 结束掉这个 Context ,三个 gorouting 也就一起被结束掉了<br>程序的运行结果如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">one is running!<br>two is running!<br>three is running!<br>...<br>two has done!<br>one has done!<br>three has done!<br></code></pre></td></tr></table></figure><p>因为 gorouting 类似于操作系统中的进程调用,当有多个进程处于就绪态时,随机选取一个进程进入运行态,所以 one,two,three 的先后输出都是随机的</p><h2 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h2><p>Context 接口中有四个方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() <span class="hljs-type">error</span><br>Value(key any) any<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Deadline()</code> 需要配合设置了时间的 Context 来使用,返回这个 Context 应该被取消的时间,当 ok 为 false 时表示没有设置结束时间<br><code>Done()</code> 最常用的方法,结束掉此 Context<br><code>Err()</code> 返回 Context 被取消的原因,如果 Context 还没有 Done() 则返回 nil,如果被 Done() 了则返回原因,比如时间到了<br><code>Value()</code> 需要配合可以传值的 Context 来使用,在使用 Context 时可以顺便带个值进来</p><p>context.Background(),它是用来作为根 Context 来使用的,相当于操作系统中的0号进程<br>context.TODO(),当不知道使用哪个 Context 时可以使用它,我觉得可以作为叶子节点的 Context 来使用</p><h2 id="Context-的-With-方法"><a href="#Context-的-With-方法" class="headerlink" title="Context 的 With 方法"></a>Context 的 With 方法</h2><p>如过需要创建子 Context ,那么就需要用到这4个 With 方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCancel</span><span class="hljs-params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Context<br></code></pre></td></tr></table></figure><h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><p>这个方法前面已经多次使用了,就是创建一个带 cancel 的 Context,可以通过 cancel() 来结束这个 Context</p><h3 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h3><p>这个方法用来创建一个带结束时间的 Context,注意是结束时间,它用的参数是 time.Time,意思是在几点几分几秒结束掉这个 Context<br>示例代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Context_WithDeadline</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(<span class="hljs-number">20</span>*time.Second)) <span class="hljs-comment">// 创建一个可以随时取消的,20秒后自动结束的 Context</span><br><span class="hljs-keyword">defer</span> cancel()                                                                            <span class="hljs-comment">// 最后取消所有的 Context</span><br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;one&quot;</span>)<br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;two&quot;</span>)<br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;three&quot;</span>)<br>time.Sleep(<span class="hljs-number">4</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;done! do not run anymore!&quot;</span>)<br>cancel()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Just_run</span><span class="hljs-params">(ctx context.Context, name <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(name + <span class="hljs-string">&quot; has done!&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(name + <span class="hljs-string">&quot; is running!&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中创建了一个以现在时间为基准,20s后自动结束的 Context,然后把他传给三个 gorouting,但假设程序执行4s后就结束了,和 WithCancel 方法一样,调用 cancel 就可以直接结束掉这个 Context<br>如果把时间改为 &gt; 20s 那么 Context 会在20s时,无论程序是否执行完毕,都会自动取消</p><h3 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h3><p>这个方法和 WithDeadline 没什么区别,就是传入的时间不是一个时间点,而是一个 time.Duration 时间段,比如10s,20s<br>示例代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Context_WithTimeout</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">10</span>*time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;one&quot;</span>)<br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;two&quot;</span>)<br><span class="hljs-keyword">go</span> Just_run(ctx, <span class="hljs-string">&quot;three&quot;</span>)<br>time.Sleep(<span class="hljs-number">15</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;done!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Just_run</span><span class="hljs-params">(ctx context.Context, name <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(name + <span class="hljs-string">&quot; has done!&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(name + <span class="hljs-string">&quot; is running!&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码创建了一个持续时间为10s的 Context,然后把他传给三个 gorouting,假设程序需要15s 才鞥结束,但是10s后,Context 就会自动结束,如果在10s之前,就可以通过 cancel() 来结束掉这个 Context</p><h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><p>这个方法和前面三个不太一样,它可以创建一个带键值对的 Context,在使用这个 Context 时,可以从中取出来使用<br>示例代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> key = <span class="hljs-string">&quot;name&quot;</span> <span class="hljs-comment">// 定义一个键</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Context_WithValue</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background())<br>ctx2 := context.WithValue(ctx, key, <span class="hljs-string">&quot;one&quot;</span>) <span class="hljs-comment">// 创建一个带值的 Context</span><br>ctx3 := context.WithValue(ctx, key, <span class="hljs-string">&quot;two&quot;</span>)<br>ctx4 := context.WithValue(ctx, key, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-keyword">go</span> Always_run(ctx2)<br><span class="hljs-keyword">go</span> Always_run(ctx3)<br><span class="hljs-keyword">go</span> Always_run(ctx4)<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;all done!&quot;</span>)<br>cancel()<br>time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Always_run</span><span class="hljs-params">(ctx context.Context)</span></span> &#123; <span class="hljs-comment">// 这里的参数只用了 Context,前面能输出名字是因为传入了 name 参数</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(ctx.Value(key), <span class="hljs-string">&quot; has done!&quot;</span>)  <span class="hljs-comment">// 使用 ctx.Value() 来获取值</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println((ctx.Value(key)), <span class="hljs-string">&quot; is running!&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码,创建一个带取消的 Context,然后用 WithValue 来创建三个带键值的 Context<br>分别把三个 Context 传入三个 gorouting,这样每一个 gorouting 都可以输出不同的结果了<br>运行结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">three  is running!<br>one  is running!<br>two  is running!<br>...<br>all done!<br>three  has done!<br>two  has done!<br>one  has done!<br></code></pre></td></tr></table></figure><hr><p>总算是把 Context 这个给解决了 o(^▽^)o<br>之前就总是想为什么需要用到 Context 呢,经过了这段时间的学习,发现确实需要用到 Context<br>使用 Context 可以更优雅的创建和停止 gorouting,不至于创建了 gorouting 就不管了,这样系统占用就不会越来越多,最终导致崩溃<br>所以 Go 语言中使用这一机制是十分简单有效的,理解起来也不难 (๑¯∀¯๑)</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决无法拉取Github项目</title>
    <link href="/2022/12/06/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%8B%89%E5%8F%96Github%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/12/06/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%8B%89%E5%8F%96Github%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="GitHub-突然无法拉取和推送"><a href="#GitHub-突然无法拉取和推送" class="headerlink" title="GitHub 突然无法拉取和推送"></a>GitHub 突然无法拉取和推送</h1><p>今天开心的逛着 GitHub,看到一个项目想要拉取下来看看,但是把拉取命令打好后,一回车,没有像往常一样拉取到镜像,反而报了以下的错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh: connect to host github.com port 22: Connection refused<br>fatal: Could not read from remote repository.<br></code></pre></td></tr></table></figure><span id="more"></span><p>我连接不上 GitHub 的22端口了?前一天还能拉取项目,咋今天不行?<br>然后我尝试 ping 了一下 github.com</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">PING github.com (127.0.0.1) 56(84) bytes of data.<br>64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.017 ms<br>64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.028 ms<br>64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.028 ms<br>64 bytes from localhost (127.0.0.1): icmp_seq=4 ttl=64 time=0.030 ms<br></code></pre></td></tr></table></figure><p>emmm… 众所周知,127.0.0.1是一个本地回环地址,DNS 是将域名解析到公网 ip 上的,所以,问题只出在了一个地方—DNS 污染</p><h2 id="使用-HTTPS"><a href="#使用-HTTPS" class="headerlink" title="使用 HTTPS"></a>使用 HTTPS</h2><p>有可能是被防火墙给拦截了,而 GitHub 官方也给出了解决方法<br><a href="https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port">https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port</a><br>使用 SSH over the HTTPS port</p><p>可以尝试如下命令连接 GitHub,测试是否可以使用 SSH over the HTTPS port</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T -p 443 git@ssh.github.com<br></code></pre></td></tr></table></figure><p>如果提示如下信息,则说明可以使用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Hi USERNAME! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure><p>那么可以使用如下命令来拉取项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone ssh://git@ssh.github.com:443/YOUR-USERNAME/YOUR-REPOSITORY.git<br></code></pre></td></tr></table></figure><h2 id="设置所有拉取都使用-HTTPS"><a href="#设置所有拉取都使用-HTTPS" class="headerlink" title="设置所有拉取都使用 HTTPS"></a>设置所有拉取都使用 HTTPS</h2><p>如果想要让所有的与 <code>git@ssh.github.com</code> 的连接都使用 443 端口,也就是 HTTPS,那么就需要修改 ssh 的配置文件<br>修改 <code>~/.ssh/config</code> 文件,如果没有,则创建一个<br>然后加入如下配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Host github.com<br>Hostname ssh.github.com<br>Port 443<br>User git<br></code></pre></td></tr></table></figure><p>配置完成后,可以通过如下命令测试是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>成功会输出如下语句</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Hi USERNAME! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure><hr><p>今天开心的摸鱼,摸到了一天大鱼,想要拿来玩一玩,但是却被这个问题给挡住了 (´ﾟдﾟ&#96;)<br>为了解决这个问题,有时一番好找,总算是解决了问题,好端端的 GitHub 为什么会被解析到本地环回地址呢 (눈‸눈)<br>问题解决了就好,毕竟博客也是用的 GitHub Pages 嘛,也是用的 Git 来更新,这一问题解决了,也算是解决了一个博客可能不见的隐患 (ﾉ&gt;ω&lt;)ﾉ</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MX 记录学习</title>
    <link href="/2022/11/24/MX-%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/24/MX-%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="又摸鱼了"><a href="#又摸鱼了" class="headerlink" title="又摸鱼了"></a>又摸鱼了</h1><p>今天学信息安全数学基础写的头皮发麻,所以写完了就没有继续学 Go 了,所以又摸了一天的鱼 ( ´･ω)<br>但是看着时间还有蛮多的,所以随便翻了翻网页,看看博客<br>然后就看到了 namesilo 上的 <code>Email Forwarding</code><br>于是好奇的点了进去,看了看是个啥,然后看到它可以填写邮箱,然后查了一下这是个啥,然后就学到了个新东西 MX 记录</p><span id="more"></span><h1 id="这玩意可以干什么"><a href="#这玩意可以干什么" class="headerlink" title="这玩意可以干什么"></a>这玩意可以干什么</h1><p>MX record 也是 DNS 解析里的一种,它可以解析邮件地址,比如 <a href="mailto:&#120;&#x78;&#x78;&#64;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;">xxx@gmail.com</a><br>当某台主机想要发送邮件到另外一台主机时,肯定也要进行 DNS 解析的嘛,不然怎么发送过去的<br>所以 DNS 服务器会解析 @gmail.com 这个后缀,于是告诉发送方这封邮件要交给谷歌的邮件服务器来发送,于是就由谷歌邮件服务器来送达这封邮件,然后收件人就可以从谷歌邮件服务器那收到邮件了<br>而 MX record 就是可以自定义后缀,然后交由特定的邮件服务器来发送</p><p>也就是说,通过这个可以自定义邮箱地址,让自己的地址与众不同</p><h2 id="设置-MX-record"><a href="#设置-MX-record" class="headerlink" title="设置 MX record"></a>设置 MX record</h2><p>在 namesilo 中设置很简单,给域名添加三条 MX record 的记录就可以了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">mx1.emailowl.com<br>mx2.emailowl.com<br>mx3.emailowl.com<br></code></pre></td></tr></table></figure><p><img src="/img/2022-11-24-1.png" alt="结果"></p><p>然后就可以自定义邮箱了<br>进入 Email Forwarding<br><img src="/img/2022-11-24-2.png"></p><p>添加一条 Email 为 <code>自定义邮箱@域名</code> Forword to 谷歌邮箱地址的记录<br>submit 后就完成了<br><img src="/img/2022-11-24-3.png"></p><h2 id="设置谷歌邮箱"><a href="#设置谷歌邮箱" class="headerlink" title="设置谷歌邮箱"></a>设置谷歌邮箱</h2><p>首先开启 POP 下载和 IMAP 访问<br><a href="https://mail.google.com/mail/u/0/#settings/fwdandpop">https://mail.google.com/mail/u/0/#settings/fwdandpop</a><br>进入这个网址开启这两项</p><p>然后在谷歌中设置一个应用专用密码<br><a href="https://myaccount.google.com/apppasswords">https://myaccount.google.com/apppasswords</a><br>生成后复制它,这是一个一次性的密码,意思是只用这一次,所以没必要记住它</p><p>在账号和导入中选择添加其他电子邮箱<br><a href="https://mail.google.com/mail/u/0/#settings/accounts">https://mail.google.com/mail/u/0/#settings/accounts</a></p><p>添加的邮箱的名称就是别人看到的名字,取一个喜欢的,邮件地址就是刚才自定义的域名的地址<br><img src="/img/2022-11-24-4.png"></p><p>SMTP 服务器就设置为谷歌的服务器,用户名是谷歌邮箱,密码就是刚才生成的应用专用密码<br><img src="/img/2022-11-24-5.png"></p><p>这样别人就可以用我自定义的邮箱地址来给我发送邮件了 o(<em>￣▽￣</em>)ブ </p><hr><p>以后别人给我发邮件的时候,我就可以用以我博客的域名为后缀的邮箱地址给我发邮件了,着实显得和别人不一样 &lt;(￣︶￣)&gt;<br>写了很久的网络信息安全数学基础,写的头痛,所以摸鱼刷别人博客和网站,没想到还学到了新东西 ♪(^∇^*)<br>所以这鱼没白摸 (o゜▽゜)o☆</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
      <tag>MX record</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenSSL生成包含SAN的证书</title>
    <link href="/2022/11/20/OpenSSL%E7%94%9F%E6%88%90%E5%8C%85%E5%90%ABSAN%E7%9A%84%E8%AF%81%E4%B9%A6/"/>
    <url>/2022/11/20/OpenSSL%E7%94%9F%E6%88%90%E5%8C%85%E5%90%ABSAN%E7%9A%84%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="正好需要生成包含SAN的证书"><a href="#正好需要生成包含SAN的证书" class="headerlink" title="正好需要生成包含SAN的证书"></a>正好需要生成包含SAN的证书</h1><p>最近在学东西,发现 OpenSSL 生成的证书老是报错无法使用,到网上搜了一下,发现是 Golang 的原因,它需要用到包含 SAN 的证书而且还正好和我后面要学的 gRPC 有关<br>所以问题解决后就记录一下吧,可能到时候也会碰到这样的问题,刚好提前解决了</p><span id="more"></span><h1 id="Wiki介绍"><a href="#Wiki介绍" class="headerlink" title="Wiki介绍"></a>Wiki介绍</h1><p>主题备用名称(Subject Alternative Name，缩写SAN)是一项对X.509的扩展,它允许在安全证书中使用subjectAltName字段将多种值与证书关联,这些值被称为主题备用名称<br>简单说就是可以一个证书签多个域名和IP了,减少了一个域名一个证书的开销<br>不过我现在只需要自签证书,也不存在需要花钱的问题</p><h1 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h1><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>为了方便,可以把配置文件复制过来,修改复制过来的配置文件,这样以后别的什么问题需要修改配置文件的时候,不会影响到这边<br>Arch Linux 的配置文件在 &#x2F;etc&#x2F;ssl&#x2F;openssl.cnf,直接复制过来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /etc/ssl/openssl.cnf openssl.cnf<br></code></pre></td></tr></table></figure><p>然后根据如下修改 openssl.cnf 文件,修改要注意在谁的下面修改,别改错地方了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">[ CA_default ]<br>...<br>copy_extensions = copy # 取消注释<br>...<br><br>[ req ]<br>...<br>req_extensions = v3_req # 取消注释<br>...<br><br>[ v3_req ]<br>...<br>subjectAltName = @alt_names # 增加这一行<br>...<br><br>[alt_names] # 增加这一区块<br>IP.1 = &lt;IP address&gt; # 服务端 IP 地址<br>DNS.1 = *.org.example.com # 1号域名<br>DNS.2 = *.example.com # 2号域名<br></code></pre></td></tr></table></figure><ul><li>域名和IP按照实际情况修改,没有就不填</li></ul><h2 id="服务端-CA-生成密钥和CA证书"><a href="#服务端-CA-生成密钥和CA证书" class="headerlink" title="服务端(CA)生成密钥和CA证书"></a>服务端(CA)生成密钥和CA证书</h2><p>由于我是自签证书,所以我直接让服务器当CA了<br>生成服务端密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out server.key 2048<br></code></pre></td></tr></table></figure><ul><li>genrsa 生成的是RSA密钥</li><li>-out   输出的密钥</li><li>2048   RSA密钥的长度为2048bit</li></ul><p>服务端生成根CA证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -nodes \<br>-new -x509 \<br>-days 3650 \<br>-key server.key \<br>-out ca.crt<br></code></pre></td></tr></table></figure><ul><li>req     请求</li><li>-nodes  CA 的节点,因为 CA 认证是树形的,一个 CA 就是一个节点</li><li>-new    新建</li><li>-x509   使用X.509公钥证书格式标准</li><li>-days   证书有效期为10年</li><li>-key    使用的密钥,因为是自签CA证书,所以使用服务端的密钥</li><li>-out    输出的证书</li></ul><p>在生成证书和后面生成请求的时候,会要求输入各种信息,如国家,地区等,如果不想用这个交互界面来输入的话,可以使用 -subj 参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">-subj &quot;/C=CN/OU=myOrg/O=myComp/CN=myName&quot;<br></code></pre></td></tr></table></figure><p>这样就可以免去交互界面,直接填好信息</p><h2 id="客户端生成密钥和证书请求"><a href="#客户端生成密钥和证书请求" class="headerlink" title="客户端生成密钥和证书请求"></a>客户端生成密钥和证书请求</h2><p>生成客户端密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl genrsa -out client.key 2048<br></code></pre></td></tr></table></figure><p>和生成服务端密钥一样</p><p>生成证书请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -new -nodes \<br>-key client.key \<br>-out req.csr \<br>-config openssl.cnf \<br>-extensions v3_req<br></code></pre></td></tr></table></figure><ul><li>req          请求</li><li>-new         新建</li><li>-nodes       节点</li><li>-key         客户端密钥</li><li>-out         请求文件</li><li>-config      配置文件,就是用刚才修改过的文件</li><li>-extensions  使用配置文件中的哪一项,我在配置文件中 [ req ] 设置为了使用 v3_req ,而 v3_req 所设置需要为谁签名在 alt_names 中,alt_names 就是设置的 IP 和域名</li></ul><p>然后就会获得一个请求文件 req.csr,可以用命令查看生成的请求文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -noout -text -in req.csr<br></code></pre></td></tr></table></figure><h2 id="服务端签发证书"><a href="#服务端签发证书" class="headerlink" title="服务端签发证书"></a>服务端签发证书</h2><p>把客户端的请求文件req.csr拿过来,然后就可以签发客户端的证书了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -req \<br>-days 3650 \<br>-in req.csr \<br>-out client.crt \<br>-CA ca.crt \<br>-CAkey server.key \<br>-CAcreateserial \<br>-extfile openssl.cnf \<br>-extensions v3_req<br></code></pre></td></tr></table></figure><ul><li>-in               传入的请求文件</li><li>-out              输出的客户端证书</li><li>-CA               使用的CA证书</li><li>-CAkey            使用的密钥</li><li>-CAcreateserial   和上面的nodes差不多,创建一个节点</li><li>-extfile          使用的配置文件,这里还是用了修改后的配置文件,两边用的配置文件是一样的(自签证书不就是在一台主机上完成的吗 ॱଳॱ)</li><li>-extensions       同客户端生成请求</li></ul><p>查看证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl x509 -noout -text -in client.crt<br></code></pre></td></tr></table></figure><p>这样就获得了包含 SAN 的证书 client.crt,可以愉快的使用了 |•’-‘•) ✧</p><hr><p>忙里偷闲,在学 Go 的过程中摸鱼去玩别的东西去了,还碰到了错误无法解决,到头来还是 Go 的问题<br>emmm…<br>学 Go 摸鱼 -&gt; 碰到 Go 的问题 -&gt; 解决 Go 的问题 -&gt; 摸鱼摸回来了 (°⌓°)<br>弄完了这个继续当我的 GoGo人 (～￣▽￣)～</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenSSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Caller的使用</title>
    <link href="/2022/11/13/Go-Caller%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/13/Go-Caller%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="跟着书做项目碰到了不认识的函数"><a href="#跟着书做项目碰到了不认识的函数" class="headerlink" title="跟着书做项目碰到了不认识的函数"></a>跟着书做项目碰到了不认识的函数</h1><p>在边看书边敲代码的时候,碰到了一个不认识的函数,在学习 Golang 的基础的时候也没碰到过<br>但是网上一搜,感觉又特别重要,所以琢磨了一个多小时,总算是明白是拿来做什么的了<br>这个函数就是 runtime.Caller 及其他一起使用的函数</p><span id="more"></span><h2 id="获取函数信息"><a href="#获取函数信息" class="headerlink" title="获取函数信息"></a>获取函数信息</h2><p>在很多文章里, Caller 出现最多的就是在日志部分<br>因为它可以拿来获取调用者的各种信息,比如名称,行号等<br>比如如下函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>pc, _, _, _ := runtime.Caller(<span class="hljs-number">1</span>) <span class="hljs-comment">// 本函数向上推一层即可获取调用者的 program counter(程序计数器)</span><br><span class="hljs-keyword">return</span> runtime.FuncForPC(pc).Name()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printCallerName</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>&#123;<br>pc, _, _, _ := runtime.Caller(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> runtime.FuncForPC(pc).Name()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>printName()</code> 获取本函数名称<br><code>printCallerName()</code> 获取调用函数名称<br>runtime.Caller 需要传入一个 skip 参数,skip 是堆栈向前推几个的数量<br>因为函数的调用是压栈操作,0就表示本函数,1就表示向前推一个函数,printName()本身就是一个函数,所以往前推一个就是调用者了<br>printCallerName()是用来获取调用者的函数,0表示其本身,1表示调用者,2就表示调用者的调用者,也就是我们想获取的调用者</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>hello()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;我是 %s, %s 在调用我\n&quot;</span>, printName(), printCallerName())<br>world()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">world</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;我是 %s, %s 在调用我\n&quot;</span>, printName(), printCallerName())<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">我是 main.hello, main.main 在调用我<br>我是 main.world, main.hello 在调用我<br></code></pre></td></tr></table></figure><h2 id="目前碰到的几个函数的使用"><a href="#目前碰到的几个函数的使用" class="headerlink" title="目前碰到的几个函数的使用"></a>目前碰到的几个函数的使用</h2><h3 id="func-Caller-skip-int-pc-uintptr-file-string-line-int-ok-bool"><a href="#func-Caller-skip-int-pc-uintptr-file-string-line-int-ok-bool" class="headerlink" title="func Caller(skip int) (pc uintptr, file string, line int, ok bool)"></a>func Caller(skip int) (pc uintptr, file string, line int, ok bool)</h3><p>就是前面使用的函数,需要传入一个 skip 参数表示以本函数为0向前推几个函数<br>返回4个值,分别为</p><ul><li>pc 指向程序计数器的 uintptr 指针, uintptr 指针不是真正的指针,它不能指向对象,但它可以进行指针的加减,就跟 C 里面的指针一样,使用时需要把它转换为 Pointer,通过*操作来取值,赋值</li><li>file 字符串型,名称</li><li>line int型,行号</li><li>ok 布尔值,用来表示是否成功获取</li></ul><h3 id="func-Callers-skip-int-pc-uintptr-int"><a href="#func-Callers-skip-int-pc-uintptr-int" class="headerlink" title="func Callers(skip int, pc []uintptr) int"></a>func Callers(skip int, pc []uintptr) int</h3><p>将连续的程序计数器放到 pc 指针中,直到指针的空间放不下了为止,skip表示从谁开始,不过0表示 Callers() 函数本身,1才表示本函数,这里和Caller() 是有一点差别的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    trace()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">()</span></span> &#123;<br>pc := <span class="hljs-built_in">make</span>([]<span class="hljs-type">uintptr</span>, <span class="hljs-number">10</span>)   <span class="hljs-comment">// 生成一个指向10个空间的uintptr指针</span><br>n := runtime.Callers(<span class="hljs-number">0</span>, pc) <span class="hljs-comment">// 栈的program counter,放到pc这个指针中</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>f := runtime.FuncForPC(pc[i])   <span class="hljs-comment">// 把程序计数器地址对应的函数的信息获取出来</span><br>file, line := f.FileLine(pc[i]) <span class="hljs-comment">// 获取调用函数名称和行号</span><br>fmt.Printf(<span class="hljs-string">&quot;%s:%d %s\n&quot;</span>, file, line, f.Name())<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以看到一连串的程序调用列表了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">/usr/lib/go/src/runtime/extern.go:247 runtime.Callers<br>/usr/lib/go/src/runtime/extern.go:247 runtime.Callers<br>/home/nero/GoProgram/Caller-Learn/main.go:10 main.main<br>/usr/lib/go/src/runtime/proc.go:259 runtime.main<br>/usr/lib/go/src/runtime/asm_amd64.s:1595 runtime.goexit<br></code></pre></td></tr></table></figure><h3 id="func-CallersFrames-callers-uintptr-Frames"><a href="#func-CallersFrames-callers-uintptr-Frames" class="headerlink" title="func CallersFrames(callers []uintptr) *Frames"></a>func CallersFrames(callers []uintptr) *Frames</h3><p>Callers() 只是获取了程序计数器,使用 CallersFrames() 可以获取到整个栈的信息<br>意思大概就是 Callers 只是获取一个指针,需要的通过指针去寻找并获取,而 CallersFrames() 是把所有信息一次性全部拿过来了<br>CallersFrames() 将获取到的信息放到 callers 指针中,返回一个 pc 的切片指针</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    trace()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">()</span></span> &#123;<br>pc := <span class="hljs-built_in">make</span>([]<span class="hljs-type">uintptr</span>, <span class="hljs-number">10</span>)<br>n := runtime.Callers(<span class="hljs-number">0</span>, pc)<br>frames := runtime.CallersFrames(pc[:n]) <span class="hljs-comment">// 直接获取整个栈信息,放到pc中,返回一个pc切片指针</span><br><span class="hljs-keyword">for</span> &#123;<br>frame, more := frames.Next()<br><span class="hljs-comment">// 此处解析名字时就不需要使用 FuncForPC,直接调用</span><br>fmt.Printf(<span class="hljs-string">&quot;%s:%d %s\n&quot;</span>, frame.File, frame.Line, frame.Function)<br><span class="hljs-keyword">if</span> !more &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果一样</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">/usr/lib/go/src/runtime/extern.go:247 runtime.Callers<br>/home/nero/GoProgram/Caller-Learn/main.go:46 main.trace2<br>/home/nero/GoProgram/Caller-Learn/main.go:9 main.main<br>/usr/lib/go/src/runtime/proc.go:250 runtime.main<br>/usr/lib/go/src/runtime/asm_amd64.s:1594 runtime.goexit<br></code></pre></td></tr></table></figure><hr><p>敲代码敲着敲着突然卡壳了,不懂这里用的是什么函数,不知道是干什么的 (°ཀ°)<br>然后就去找这个函数是干什么的,于是一个多小时过去了,总算是大概懂了,也没算浪费时间吧,虽然学习项目的进度又慢了一点 (´Ａ｀。)<br>但学到了新东西就是好,一天学一点嘛 (ﾟ∀ﾟ)</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go flag包使用</title>
    <link href="/2022/11/01/Go-flag%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/01/Go-flag%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="用-flag-包做参数获取"><a href="#用-flag-包做参数获取" class="headerlink" title="用 flag 包做参数获取"></a>用 flag 包做参数获取</h1><p>刚开始学习用 Go 语言来做小工具,没想到就碰到了个大问题,就是后面有些难理解 (´;ω;&#96;)<br>使用 flag 包可以用来实现从命令行获取参数的效果<br>比如 <code>pacmman -S</code> 这样的效果</p><span id="more"></span><h2 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h2><p>普通用法就是最基本的实现,没有什么花里胡哨的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span><br>flag.StringVar(&amp;name, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Let&#x27;s go~~~&quot;</span>, <span class="hljs-string">&quot;help&quot;</span>)<br>flag.StringVar(&amp;name, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;Let&#x27;s go!!!&quot;</span>, <span class="hljs-string">&quot;help&quot;</span>)<br>flag.Parse()<br>fmt.Printf(<span class="hljs-string">&quot;name= %s\n&quot;</span>, name)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>flag.StringVar(&amp;name, &quot;name&quot;, &quot;Let&#39;s go~~~&quot;, &quot;help&quot;)</code> 参数注册,给变量 name 绑定了一个 name 的名字,第三个参数是它的默认值,第四个描述它是干什么的.有两行说明用参数 name 和 n 都可以找到变量 name</li><li><code>flag.Parse()</code> 用来解析并绑定命令行参数,必须在所有参数注册后,使用前调用</li></ul><p>命令行执行效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run main.go -name=nero // 结果: name= nero<br>go run main.go -n=nero // 结果: name= nero<br>go run main.go // 结果: name= Let&#x27;s go!!!<br></code></pre></td></tr></table></figure><h2 id="子命令用法"><a href="#子命令用法" class="headerlink" title="子命令用法"></a>子命令用法</h2><p>子命令就是给命令分级,一层一层的选择命令<br>比如 <code>go run</code> 和 <code>go get</code> run 和 get 就是两个子命令</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span><br>flag.Parse()<br>runCmd := flag.NewFlagSet(<span class="hljs-string">&quot;run&quot;</span>, flag.ExitOnError)<br>runCmd.StringVar(&amp;name, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;run run run&quot;</span>, <span class="hljs-string">&quot;help&quot;</span>)<br>dashCmd := flag.NewFlagSet(<span class="hljs-string">&quot;dash&quot;</span>, flag.ExitOnError)<br>dashCmd.StringVar(&amp;name, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;dash dash dash&quot;</span>, <span class="hljs-string">&quot;help&quot;</span>)<br><br>args := flag.Args()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">switch</span> args[<span class="hljs-number">0</span>] &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;run&quot;</span>:<br>_ = runCmd.Parse(args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;dash&quot;</span>:<br>_ = dashCmd.Parse(args[<span class="hljs-number">1</span>:])<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;name= %s\n&quot;</span>, name)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>flag.NewFlagSet(&quot;run&quot;, flag.ExitOnError)</code> 创建一个子命令集名为 run,异常情况会返回错误 os.Exit(2),详情查看 <a href="https://pkg.go.dev/flag#ErrorHandling">https://pkg.go.dev/flag#ErrorHandling</a></li><li><code>args := flag.Args()</code> 返回参数列表</li><li><code>runCmd.Parse(args[1:])</code> 原方法为 func (*FlagSet) Parse 表示从参数列表中解析标志定义,对解析方法的进一步封装,实际解析逻辑交由 parseOne</li></ul><p>命令执行效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run main.go run -name=nero // 结果: name= nero<br>go run main.go dash -n=nero // 结果: name= nero<br></code></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>flag 的运行逻辑大概是这样的:<br>flag.Parse 解析并绑定命令 –&gt; FlagSet.Parse 对解析方法的进一步封装,交由 FlagSet.parseOne 逻辑解析 –&gt; FlagSet.parseOne 先对参数的规则进行校验,没问题了就会使用该 flag 提供的 Value.Set 来实现对应的动作<br>注意是该 flag 的 Value.Set 方法,意思是说我们可以自定义这个方法<br>为了实现高级用法,就要我们自己实现 Value 接口里的所有方法:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">interface</span> &#123;<br>String() <span class="hljs-type">string</span><br>Set(<span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 String() 方法是运行中如果没有带参数,就会运行它,原文介绍 <a href="https://pkg.go.dev/flag#Value">https://pkg.go.dev/flag#Value</a><br>flag 包可以调用带有零值接收器的 String 方法,例如 nil 指针<br>而 Set() 方法就是碰到什么命令时该做什么<br>value 就是我们传入的参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Name <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i *Name)</span></span> String() <span class="hljs-type">string</span> &#123;<br>*i = <span class="hljs-string">&quot;Default is me~&quot;</span> <span class="hljs-comment">// 无参数时输出的值</span><br><span class="hljs-keyword">return</span> fmt.Sprint(*i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i *Name)</span></span> Set(value <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> value == <span class="hljs-string">&quot;hello&quot;</span> &#123; <span class="hljs-comment">// 当 -name=hello 时输出的值</span><br>*i = <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>*i = Name(<span class="hljs-string">&quot;Go tour hajimaliyo~ &quot;</span> + value) <span class="hljs-comment">// 当 -name=其他 时输出的值</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name Name<br>flag.Var(&amp;name, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;help&quot;</span>)<br>flag.Parse()<br>fmt.Println(name)<br>&#125;<br></code></pre></td></tr></table></figure><p>命令行执行效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run main.go // 结果: default is me~<br>go run main.go -name=nero // 结果: Go tour hajimaliyo~ <br>go run main.go -name=hello // 结果: world <br></code></pre></td></tr></table></figure><p>如此看来,如果想要用高级用法,只需要实现接收参数的变量的 Value 的结果就可以了</p><hr><p>看上去没多少,但是却花了为2个小时看文档,找实例用法,总算是理解了个大概 ( º﹃º )<br>算是解决了个问题吧,能睡个好觉了 ΩДΩ</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SysRq使用</title>
    <link href="/2022/10/30/SysRq%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/30/SysRq%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="电脑老是卡死"><a href="#电脑老是卡死" class="headerlink" title="电脑老是卡死"></a>电脑老是卡死</h1><p>最近电脑老是突然卡死,感觉像是爆内存了,找来找去也没什么解决办法<br>于是学到的了个新东西—SysRq<br>这东西可有用了,在电脑卡死的时候可以尝试让电脑恢复,如果无法恢复还能尝试正常关机,而不是按电源键<br>以后碰到系统卡死了可以用这种方法来不伤害内核的情况下重启电脑<br>Kernel panic 可不有意思 ,,Ծ‸Ծ,,</p><span id="more"></span><h2 id="开启-SysRq"><a href="#开启-SysRq" class="headerlink" title="开启 SysRq"></a>开启 SysRq</h2><p>Arch Linux 默认是不允许所有的 SysRq 命令的,所以要设置一下<br>将 1 写入到 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;sysrq 中就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo echo &quot;1&quot; &gt; /proc/sys/kernel/sysrq<br></code></pre></td></tr></table></figure><p>不过这只在本次开机有效,下次还是不行,所以可以设置为开机启动<br>将 <code>kernel.sysrq = 1</code> 写入到 <code>/etc/sysctl.d/99-sysctl.conf</code> 中就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo kernel.sysrq = 1 &gt; /etc/sysctl.d/99-sysctl.conf <br></code></pre></td></tr></table></figure><h2 id="SysRq-键"><a href="#SysRq-键" class="headerlink" title="SysRq 键"></a>SysRq 键</h2><p>一般键盘上都会有的,如果没有可能是没写,但它肯定存在<br>比如我的笔记本键盘上没有那个按键是写了 SysRq 的,但是我有 Print Screen 键(截图键)<br>其实 Print Screen 也是 SysRq 键</p><h2 id="有用的-SysRq-命令"><a href="#有用的-SysRq-命令" class="headerlink" title="有用的 SysRq 命令"></a>有用的 SysRq 命令</h2><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>Alt+SysRq+f</td><td>如果没有进程可关闭了,就使用 OOM(out-of-memory) killer</td></tr><tr><td>Alt+SysRq+R+ Unraw</td><td>从X收回对键盘的控制</td></tr><tr><td>Alt+SysRq+E+ Terminate</td><td>向所有进程发送SIGTERM信号，让它们正常终止</td></tr><tr><td>Alt+SysRq+I+ Kill</td><td>向所有进程发送SIGKILL信号，强制立即终止</td></tr><tr><td>Alt+SysRq+S+ Sync</td><td>将待写数据写入磁盘</td></tr><tr><td>Alt+SysRq+U+ Unmount</td><td>卸载所有硬盘然后重新按只读模式挂载</td></tr><tr><td>Alt+SysRq+B+ Reboot</td><td>重启</td></tr></tbody></table><p><code>Alt+SysRq+f</code>可以用来应对爆内存</p><p>一定要记住后面 6 个命令 –&gt; <code>REISUB</code><br>助记 <b>R</b>eboot <b>E</b>ven <b>I</b>f <b>S</b>ystem <b>U</b>tterly <b>B</b>roken<br>除非内核都卡住了,否则内核一定会接受 SysRq 命令,所以这六个命令可以用来安全的登出和注销系统</p><hr><p>最近电脑老是突然卡住,而且好几次在卡之前都看到很多内存被吃了,从开机到卡主内存越用越多<br>目前还没找到解决方法,只能先解决碰到了该怎么办吧 (,,•́ . •̀,,)</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SysRq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goroutine和channel</title>
    <link href="/2022/10/29/Goroutine%E5%92%8Cchannel/"/>
    <url>/2022/10/29/Goroutine%E5%92%8Cchannel/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-实现并发"><a href="#Golang-实现并发" class="headerlink" title="Golang 实现并发"></a>Golang 实现并发</h1><p>对于 Goroutine 和 channel 我是这么理解的:<br>Goroutine 就是用来实现并发的,而通过 channel 实现协程的调度</p><span id="more"></span><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数和 Python,Java 里面的匿名函数差不多,都是没有名字的函数,随写随用<br>理解起来也很简单,用法如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;()<br></code></pre></td></tr></table></figure><p>感觉在前面闭包里面碰到过,就是把函数赋值一个值,匿名函数也可以这样<br>把一个匿名函数赋值给了 a, 然后就可以使用a来调用匿名函数了</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang">a := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello world, 1&quot;</span>)<br>&#125;<br>a()<br></code></pre></td></tr></table></figure><p>匿名函数和普通函数的区别只是没有名字,所以它也可以带返回值</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang">a := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    fmt.Println(str)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fuck me&quot;</span><br>&#125;<br>x := a(<span class="hljs-string">&quot;hello world&quot;</span>)<br>fmt.Println(x)<br></code></pre></td></tr></table></figure><p>匿名函数也可以带参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang">b := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> &#123;<br>    fmt.Println(str)<br>&#125;<br>b(<span class="hljs-string">&quot;hello world, 3&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> &#123;<br>    fmt.Println(str)<br>&#125;(<span class="hljs-string">&quot;hello world, 4&quot;</span>)<br></code></pre></td></tr></table></figure><p>带参数的有两种情况<br>一种是如果匿名函数会被赋值给一个值,那么它结束后就不能带括号<br>另一种就是匿名函数不会被赋值给一个值,那么它结束就要带一个括号,里面放参数</p><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>Go 使用 go 关键字来创建 goroutine,我觉得 goroutine 虽然叫协程,但它的实际上就是一种轻量级的线程</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">go</span> 函数名(参数)<br></code></pre></td></tr></table></figure><p>使用示例:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">say</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(word)<br>time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> say(<span class="hljs-string">&quot;Hello&quot;</span>)<br>say(<span class="hljs-string">&quot;World&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 goroutine 不难理解,在函数调用前面加一个 go 关键字就可以了<br>难理解的是和 channel 一起用</p><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>信道要和 goroutine 一起使用才能发挥它的最大作用,所以单独讲信道很难懂,要结合 goroutine 一起来理解<br>信道就是一个管道,和 Linux 里面的管道很像,都是数据从一头放,从另一头出<br>信道使用 <code>&lt;-</code> 符号来发送或者接收</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">ch &lt;- v    <span class="hljs-comment">// 将 v 发送至信道 ch</span><br>v := &lt;-ch  <span class="hljs-comment">// 从 ch 接收值并赋予 v</span><br></code></pre></td></tr></table></figure><p>创建信道要使用 make</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>带缓冲的信道,就是在 make 的时候有第二个参数,那就是它的缓冲区大小</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>发送者可以使用 <code>close</code> 来关闭一个信道,表示没有数据要传送来</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-built_in">close</span>(c)<br></code></pre></td></tr></table></figure><p>接收者可以通过接受到的第二个参数来判断信道是否被关闭</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">v, ok := &lt;-ch<br></code></pre></td></tr></table></figure><p>select 语句可以让一个 goroutine 等待多个通信操作<br>select 会一直阻塞,直到某个信道传来数据为止,这时就会执行那个分支<br>当多个分支都准备好时会随机选择一个执行</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang">tick := time.Tick(<span class="hljs-number">100</span> * time.Millisecond) <span class="hljs-comment">// tick每100毫秒输出一次</span><br>boom := time.After(<span class="hljs-number">500</span> * time.Millisecond) <span class="hljs-comment">// boom每500毫秒输出一次</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-tick: <span class="hljs-comment">// tick有数据时匹配到这个分支</span><br>        fmt.Println(<span class="hljs-string">&quot;tick.&quot;</span>)<br>    <span class="hljs-keyword">case</span> &lt;-boom: <span class="hljs-comment">// boom有数据时匹配到这个分支</span><br>        fmt.Println(<span class="hljs-string">&quot;BOOM!&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        fmt.Println(<span class="hljs-string">&quot;    .&quot;</span>) <span class="hljs-comment">// 没有分支匹配到时,默认走这条分支</span><br>        time.Sleep(<span class="hljs-number">50</span> * time.Millisecond)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 select 中的其它分支都没有准备好时, default 分支就会执行,就跟 switch 里面的 default 一样</p><h2 id="goroutine-和-channel-一起使用"><a href="#goroutine-和-channel-一起使用" class="headerlink" title="goroutine 和 channel 一起使用"></a>goroutine 和 channel 一起使用</h2><p>前面的 goroutine 和 channel 概念都很飘,尤其是 channel,刚开始学的时候我都有点搞不懂这玩意有什么用<br>但是当我理解了把 goroutine 和 channel 结合起来使用后,我恍然大悟,直呼太强了</p><p>为什么要它们两个一起用?<br>这是为了方便实行用户层面的进程调度</p><p>当用 go 关键字创建 goroutine 时,会把这个 goroutine 放入就绪区,然后系统在就绪区内选择进程来运行(这不就是操作系统里面的进程调度吗?)<br>但是如果我想要某个进程先执行,产生一个结果后再调用另外一个进程该怎么办?<br>在这里使用 channel 阻塞那个需要等待数据的进程就可以了<br>channel 有一个输入口和一个输出口,当某个信道需要数据输入,但还没有数据输入时,它会进入阻塞状态,直到有数据传来<br>反过来也是如此,如果一个信道需要输出数据,但输出端还没有准备好,它也会进入阻塞状态,直到可以输出数据</p><p>可以理解为利用 channel 可以实现阻塞某个进程,运行某个进程的效果<br>如下代码是以我的理解写的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addNum</span><span class="hljs-params">(num <span class="hljs-type">int</span>, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>ch &lt;- num<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br>channel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> addNum(arr[<span class="hljs-number">0</span>], channel)<br><span class="hljs-keyword">go</span> addNum(arr[<span class="hljs-number">1</span>], channel)<br><span class="hljs-keyword">go</span> addNum(arr[<span class="hljs-number">2</span>], channel)<br><span class="hljs-keyword">go</span> addNum(arr[<span class="hljs-number">3</span>], channel)<br><span class="hljs-keyword">go</span> addNum(arr[<span class="hljs-number">4</span>], channel)<br><span class="hljs-keyword">go</span> addNum(arr[<span class="hljs-number">5</span>], channel)<br><span class="hljs-keyword">go</span> addNum(arr[<span class="hljs-number">6</span>], channel)<br><span class="hljs-keyword">go</span> addNum(arr[<span class="hljs-number">7</span>], channel)<br>a := &lt;-channel<br>b := &lt;-channel<br>c := &lt;-channel<br>d := &lt;-channel<br>e := &lt;-channel<br>f := &lt;-channel<br>g := &lt;-channel<br>h := &lt;-channel<br>fmt.Printf(<span class="hljs-string">&quot;a=%v\n&quot;</span>, a)<br>fmt.Printf(<span class="hljs-string">&quot;b=%v\n&quot;</span>, b)<br>fmt.Printf(<span class="hljs-string">&quot;c=%v\n&quot;</span>, c)<br>fmt.Printf(<span class="hljs-string">&quot;d=%v\n&quot;</span>, d)<br>fmt.Printf(<span class="hljs-string">&quot;e=%v\n&quot;</span>, e)<br>fmt.Printf(<span class="hljs-string">&quot;f=%v\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;g=%v\n&quot;</span>, g)<br>fmt.Printf(<span class="hljs-string">&quot;h=%v\n&quot;</span>, h)<br>&#125;<br></code></pre></td></tr></table></figure><p>先用 go 创建了 8 个 goroutine,他们都是调用 addNum 函数<br>但是 addNum 函数需要信道输出,所以直到 <code>go addNum(arr[7], channel)</code> 执行,都没有信道来接受数据<br>于是他们就都被阻塞了<br>直到执行到 <code>a := &lt;-channel</code> 从缓冲区中随机激活了一个进程,于是某个数字就被赋给了 a 变量<br>就这样不断的激活进程, a~h 这 8 个变量都随机拿到了 1~8 数字中的一个</p><p><code>注意</code>:每一次的输出结果都是不一样的 </p><p>所以通过使用信道,可以在用户层面实现进程的调度<br>当然也不是说 channel 只能用来阻塞&#x2F;激活进程,他还可以实现进程之间的数据传输,上面的例子就是向进程中传输了数据</p><hr><p>学了一天的成果果然还是有的 (ᕑᗢᓫ∗)˒<br>channel 的用法可算是搞懂了,理解之后才感觉到它的强大<br>开心,感觉搞定一了 Go 语言学习的一大障碍 |•’-‘•) ✧</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acme+letsencrypt生成tls证书</title>
    <link href="/2022/10/29/acme-letsencrypt%E7%94%9F%E6%88%90tls%E8%AF%81%E4%B9%A6/"/>
    <url>/2022/10/29/acme-letsencrypt%E7%94%9F%E6%88%90tls%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="获取-TLS-证书"><a href="#获取-TLS-证书" class="headerlink" title="获取 TLS 证书"></a>获取 TLS 证书</h1><p>最近干些事情需要用到 tls 证书,虽说用 mkcert 自签一个证书也可以,但最后还是需要一个可以在公网上使用的证书<br>于是花了一些时间把这个搞定了</p><span id="more"></span><h2 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h2><p>想要申请 tls 证书,那肯定需要有一个域名,我还是在 namesilo(<a href="https://www.namesilo.com/">https://www.namesilo.com/</a>) 上买了一个便宜的域名<br>就跟之前搭博客时一样,花点钱买了个一年的域名<br>申请了域名之后别忘了在 DNS 解析中添加一条A记录指向需要的地址</p><h2 id="使用-acme-sh-获取证书"><a href="#使用-acme-sh-获取证书" class="headerlink" title="使用 acme.sh 获取证书"></a>使用 acme.sh 获取证书</h2><p><a href="https://github.com/acmesh-official/acme.sh">https://github.com/acmesh-official/acme.sh</a><br>跟着官方的文档就可以完成的差不多</p><p>安装 acme.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl  https://get.acme.sh | sh<br></code></pre></td></tr></table></figure><p>执行<code>source ~/.bashrc</code>命令确保命令都可以生效<br>Arch Linux 在使用时可能会缺少依赖,碰到了就看看需要安装那些<br>我在使用时碰到了没有安装 socat,安装一下即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S socat<br></code></pre></td></tr></table></figure><p>我用的是 letsencrypt 来认证,免费的: <a href="https://letsencrypt.org/">https://letsencrypt.org/</a><br>也可以用 ZeroSSL <a href="https://zerossl.com/">https://zerossl.com</a><br>acme 官方的默认 CA 是 ZeroSSL,但是它老是抽风,容易申请失败,所以后面我还是用了 letsencrypt<br>执行如下命令申请证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/.acme.sh/acme.sh --issue -d 域名 --standalone -k ec-256 --server letsencrypt<br></code></pre></td></tr></table></figure><ul><li>-d 后面跟刚刚买的域名</li><li>-k ECC密钥长度有三个可选: ec-256 ec-384 ec-521</li><li>–server 选择 letsencrypt 来获取证书,默认是用 ZeroSSL 来的,不过日常抽风…</li></ul><h2 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a>更新证书</h2><p>由于 letsencrypt 的证书有效期只有3个月,因此90天内至少要更新一次证书,acme.sh 会每 60 天自动更新证书,但也可以手动更新<br>手动更新执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/.acme.sh/acme.sh --renew -d 域名 --force --ecc<br></code></pre></td></tr></table></figure><h2 id="导出证书和密钥"><a href="#导出证书和密钥" class="headerlink" title="导出证书和密钥"></a>导出证书和密钥</h2><p>将获取到的证书和密钥到出来就可以使用了,更新后的证书也是要重新导出的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/.acme.sh/acme.sh --installcert -d 域名 --fullchainpath /证书/路径/证书.crt --keypath /密钥/路径/密钥.key --ecc<br></code></pre></td></tr></table></figure><p>这样就可以愉快的使用证书了 ξ( ✿＞◡❛)▄︻▇▇〓▄︻┻┳═一</p><hr><p>弄了一上午,可算是把 tls 证书搞定了,用起来很舒适,下次还会再来 (❛◡❛✿)<br>弄完了证书,又可以继续学习我的 golang 了 (๑¯∀¯๑)</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acme</tag>
      
      <tag>TLS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go接口</title>
    <link href="/2022/10/28/Go%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/28/Go%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口和面向对象语言有那么一点像,但又不完全像,接口中会定义一些方法,这些方法也是需要实现的<br>但是接口同时也是一个数据类型,它可以被传递</p><span id="more"></span><h2 id="隐式实现"><a href="#隐式实现" class="headerlink" title="隐式实现"></a>隐式实现</h2><p>实现接口中的所有方法不需要用 “implements” 关键字<br>这样接口的实现就可以出现在任何一个包中,不必提前准备</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 定义接口,需要实现 fun() 方法</span><br><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">interface</span> &#123;<br>fun()<br>&#125;<br><br><span class="hljs-comment">// 定义一个结构体</span><br><span class="hljs-keyword">type</span> vertex <span class="hljs-keyword">struct</span> &#123;<br>S <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 也是一个自定义类型</span><br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v vertex)</span></span> fun() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;用vertex实现了方法\n&quot;</span>)<br>fmt.Println(v)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span></span> fun() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;用MyFloat实现了方法\n&quot;</span>)<br>fmt.Println(f)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 用 vertex 实现一个接口</span><br><span class="hljs-keyword">var</span> i MyInt<br>i = vertex&#123;<span class="hljs-string">&quot;hehe&quot;</span>&#125;<br>i.fun()<br><br>    <span class="hljs-comment">// 用 MyFloat 实现一个接口</span><br><span class="hljs-keyword">var</span> j MyInt = MyFloat(<span class="hljs-number">20</span>)<br>j.fun()<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中,一个接口实例化出了两个变量 i, j<br>i 使用 vertex 结构实现了 fun()方法<br>j 使用 MyFloat 结构实现了 fun()方法<br>就因为他们在实现的时候,选择的实现方式不同,他们的 fun() 方法也就不一样<br>运行结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">用vertex实现了方法<br>&#123;hehe&#125;<br>用MyFloat实现了方法<br>20<br></code></pre></td></tr></table></figure><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>指定了零个方法的接口值被称为空接口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">interface</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>空接口可保存任何类型的值,因为每个类型都至少实现了零个方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;<br>describe(i)<br><br>i = <span class="hljs-number">42</span><br>describe(i)<br><br>i = <span class="hljs-string">&quot;hello&quot;</span><br>describe(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;(%v, %T)\n&quot;</span>, i, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>空接口有一个好处就是谁都可以用,连空值也可以<br>空接口还可以和类型断言一起使用,可以用来做类型选择</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>用来判断一个值的类型的接口<br>用法如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">t, ok := i.(T)<br></code></pre></td></tr></table></figure><p>如果 i 确实是 T 类型的值,那么 t 就会获取到 i 的值 true<br>如果 i 不是 T 类型的值, 那么 t 会获取到 0, ok 获取到 false<br>第二个值 ok 是可以不写的,只是在类型判断错误的时候程序会报错</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;hello&quot;</span><br><br>s := i.(<span class="hljs-type">string</span>)<br>fmt.Println(s)<br><br>s, ok := i.(<span class="hljs-type">string</span>)<br>fmt.Println(s, ok)<br><br>f, ok := i.(<span class="hljs-type">float64</span>)<br>fmt.Println(f, ok)<br><br>f = i.(<span class="hljs-type">float64</span>) <span class="hljs-comment">// 报错</span><br>fmt.Println(f)<br></code></pre></td></tr></table></figure><h2 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h2><p>类型选择和类型断言很像,只是把 i.(T) 中的 T 换成了关键字 type</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>fmt.Printf(<span class="hljs-string">&quot;Type is int value is %v\n&quot;</span>, v)<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>fmt.Printf(<span class="hljs-string">&quot;Type is string value is %v\n&quot;</span>, v)<br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;I don&#x27;t know type %T!\n&quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stringer-接口"><a href="#Stringer-接口" class="headerlink" title="Stringer 接口"></a>Stringer 接口</h2><p>要求是 fmt 包中的 module 才有用<br>接口长这样</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Stringer 接口我感觉就相当于 Java 中的重写 ToString 方法<br>通过重写 Stringer 接口中的 String() 方法,就可以按照自己的格式输出了</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> CodeLanguage <span class="hljs-keyword">struct</span> &#123;<br>Language <span class="hljs-type">string</span><br>Birth  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CodeLanguage)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%v (%v year)&quot;</span>, c.Language, c.Birth)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := CodeLanguage&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-number">2009</span>&#125;<br>z := CodeLanguage&#123;<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">1972</span>&#125;<br>fmt.Println(a, z)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Go 程序使用 error 值来表示错误状态<br>和fmt.Stringer 类似,error类型是一个内建接口,长这样:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说可以重写某些自定义类型的 Error() 方法,达到如果出错可以快速找到那里出错了的目的<br>函数会返回一个 error 值,调用它的时候可以判断这个 error 的值是否为 nil,为 nil 表示没有出错(理解为错误为nil)</p><p>比如下面的 Go 指南里面的题目</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> ErrNegativeSqrt <span class="hljs-type">float64</span><br><br><span class="hljs-comment">// 重写了 ErrNegativeSqrt 的 Error() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e ErrNegativeSqrt)</span></span> Error() <span class="hljs-type">string</span>&#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;cannot Sqrt negative number: %v&quot;</span>, <span class="hljs-type">float64</span>(e))<br>&#125;<br><br><span class="hljs-comment">// 计算开方,返回一个 float64 和一个 error 值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">//小于零的值不能开方,返回0和一个不为 nil 的 error 值</span><br><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, ErrNegativeSqrt(x)<br>&#125;<br><span class="hljs-comment">// 正常开方,返回计算后的值和一个值为 nil 的error值</span><br><span class="hljs-keyword">return</span> math.Sqrt(x),<span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(Sqrt(<span class="hljs-number">2</span>))<br>fmt.Println(Sqrt(<span class="hljs-number">-2</span>))<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>学了一天的 Go 了,感觉很快基础就可以学完了,可以开始学点高端的东西了 (,,・ω・,,)<br>果然还是看文档学东西快,看别人讲其实就是别人把文档改讲的东西讲了一遍,这样还容易被别人的错误理解给误导浪费时间<br>不如自己直接学一手知识 (*‘ v&#96;*)</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go方法</title>
    <link href="/2022/10/28/Go%E6%96%B9%E6%B3%95/"/>
    <url>/2022/10/28/Go%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有类,所以也就不存在真正意义上的方法,Go 中定义的方法是指定了接收者的一种函数<br>方法只是个带接收者参数的函数</p><span id="more"></span><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 自定义一个结构体</span><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><span class="hljs-comment">// 这也是自定义结构</span><br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-type">float64</span><br><br><span class="hljs-comment">// 这是方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><span class="hljs-comment">// 这是函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Abs</span><span class="hljs-params">(v Vertex)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    <span class="hljs-comment">// 很像对象调用方法,但其实不是</span><br>fmt.Println(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><p>方法和函数的区别就是在 func 关键字后面有没有跟接收者参数<br>而且只能为在同一包内定义的类型的接收者声明方法,而不能为其它包内定义的类型(包括 int 之类的内建类型)的接收者声明方法</p><p>所以对于方法的定义我是这么理解的:<br>在一个包里面,可以自定义结构类型(比如结构体),这些自定义结构所定义的变量就是方法的”目标客户”<br>这些变量就可以使用那些以他们为”目标客户”的方法,别的自定义结构的变量就不行</p><h2 id="方法和指针"><a href="#方法和指针" class="headerlink" title="方法和指针"></a>方法和指针</h2><p>众所周知,带指针参数的函数必须接受一个指针</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Scale</span><span class="hljs-params">(v *Vertex, f <span class="hljs-type">float64</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 函数</span><br>&#125;<br><span class="hljs-keyword">var</span> v Vertex<br>Scale(v, <span class="hljs-number">5</span>)  <span class="hljs-comment">// 编译错误!</span><br>Scale(&amp;v, <span class="hljs-number">5</span>) <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>但是如果是以指针为接收者的方法的话,接收者既能为值又能为指针</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Scale(f <span class="hljs-type">float64</span>) &#123;<br><span class="hljs-comment">// 方法</span><br>&#125;<br><span class="hljs-keyword">var</span> v Vertex<br>v.Scale(<span class="hljs-number">5</span>)  <span class="hljs-comment">// OK</span><br>p := &amp;v<br>p.Scale(<span class="hljs-number">10</span>) <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>使用指针为接收者的方法是有好处的:方法会直接作用于这个接收者,避免了每次调用方法都要复制一次该值<br>但是值作为接收者和指针作为接收者不能混用</p><p>原因:<br>接收者是值类型的方法,会自动实现接收者是指针类型的方法<br>而接收者是指针类型的方法,不会自动实现接收者是值类型的方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 定义了一个接口,含有两个方法</span><br><span class="hljs-keyword">type</span> coder <span class="hljs-keyword">interface</span> &#123;<br>one()<br>two()<br>&#125;<br><br><span class="hljs-comment">// 定义一个结构体</span><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>S <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 接收者为值类型的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> one() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;I am one\n&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 接收者为指针类型的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> two() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;I am two\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c coder = &amp;Vertex&#123;<span class="hljs-string">&quot;Go&quot;</span>&#125;<br>c.one()<br>c.two()<br><br>    <span class="hljs-comment">// 报错</span><br>    <span class="hljs-comment">// var c coder = Vertex&#123;&quot;Go&quot;&#125;</span><br><span class="hljs-comment">// c.one()</span><br><span class="hljs-comment">// c.two()</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go闭包</title>
    <link href="/2022/10/27/Go%E9%97%AD%E5%8C%85/"/>
    <url>/2022/10/27/Go%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>Go 的函数可以是一个闭包,我对于闭包的理解就是一个函数里面定义一些变量,然后返回一个函数<br>在调用这个函数的时候,里面那个返回的函数就会被”赋值”给调用处接收的变量,这个变量就可以当一个函数使用,并且可以使用外层函数的变量<br>有点绕,使用闭包的好处就是在外层函数定义的变量可以一直被使用,它在调用这个函数之后不会被释放,它保存的值可以在下一次调用时使用</p><span id="more"></span><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>比如如下代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum += x<br><span class="hljs-keyword">return</span> sum<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>pos, neg := adder(), adder()<br>fmt.Println(<span class="hljs-string">&quot;pos&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(pos(i))<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;neg&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(neg(i*<span class="hljs-number">2</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看了代码就很清晰了,调用了两次 adder(),函数,然后将两个函数的返回值(也就是adder()里面的闭包函数)赋给了 pos 和 neg 两个变量<br>此时, pos 和 neg 这两个变量实质上是两个函数<br>如下是我对此时的 pos 和 neg 状态的理解</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang">pos <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    sum += x<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang">neg <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>    sum += x<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p>里面 sum 变量看上去是没有定义,其实已经定义了,在调用 adder() 函数的时候就已经定义了<br>sum 这个变量就跟着调用它的变量”绑定”在了一起,只有这个变量(实质上是个函数)被销毁了,它才会跟着被销毁<br>所以 pos 和 neg 它们有着各自的 sum 虽然名字一样,但互不干扰,永远是它们自己的 sum</p><p>理解了闭包是怎么回事了,程序运行的结果也就明了了<br>pos 依次传入 0~9 共10个数,每传一次输出一次 sum<br>于是结果就是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">初始 sum := 0<br>pos //sum+传入的值<br>0   //0+0<br>1   //0+1<br>3   //1+2<br>6   //3+3<br>10  //6+4<br>15  //10+5<br>21  //15+6<br>28  //21+7<br>36  //28+8<br>45  //36+9<br></code></pre></td></tr></table></figure><p>同理 neg 就是依次传入 0~18 间隔为2的共10个数,每传一次输出一次 sum</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">初始 sum := 0<br>neg //sum+传入的值<br>0   //0+0<br>2   //0+2<br>6   //2+4<br>12  //6+6<br>20  //12+8<br>30  //20+10<br>42  //30+12<br>56  //42+14<br>72  //56+16<br>90  //72+18<br></code></pre></td></tr></table></figure><h2 id="斐波纳契闭包函数"><a href="#斐波纳契闭包函数" class="headerlink" title="斐波纳契闭包函数"></a>斐波纳契闭包函数</h2><p>这是在 Tour of Go 里面学习闭包时的练习,拿来理解闭包更方便一点</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 返回一个“返回int的函数”</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>i, j := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span>&#123;<br>temp := i<br>i, j = j, (i+j)<br><span class="hljs-keyword">return</span> temp<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := fibonacci()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(f())<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了前面的理解,就不难看出 i 和 j 两个变量和 f 是”绑定”在了一起的<br>i 和 j 的初始值为 0 和 1<br>每调用一次 f 就会把此时的 i 的值赋给 temp ,然后将此时的 j 赋给 i, 此时的 i+j 赋给 j<br>最后返回 temp<br>每一次 i 和 j 的值都是上一次调用后的结果,不会回到最开始的初值</p><hr><p>这算是弄懂了闭包吧 (･ω´･ )<br>以前学 Python 的时候碰到过闭包,但没理解透彻就放弃了<br>现在算是理解了吧 Ciallo～(∠・ω&lt; )⌒★</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go install用法</title>
    <link href="/2022/10/24/go-install%E7%94%A8%E6%B3%95/"/>
    <url>/2022/10/24/go-install%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><code>go install</code> 命令就是为了把编译好的 go 程序放到 <code>$HOME/go/bin</code> 下,这样就可以在任何地方都可以使用编译好的代码了</p><span id="more"></span><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>先进入到需要编译 go 程序目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build<br></code></pre></td></tr></table></figure><p>于是就会产生一个编译好的二进制文件<br>可以直接执行它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./二进制文件<br></code></pre></td></tr></table></figure><p>然后就可以把他安装到 GOPATH 中了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go install<br></code></pre></td></tr></table></figure><p>在 $GOPATH&#x2F;bin 中可以找到刚才安装的文件<br>但是还是只能在那个目录里面使用安装的二进制文件,这不和没安装没区别吗?<br>所以要把 $GOPATH&#x2F;bin 添加到环境目录下</p><p>查看 $GOPATH 在哪里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go env GOPATH<br></code></pre></td></tr></table></figure><p>我的 $GOPATH 是在 $HOME&#x2F;go 中,所以添加如下环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=$HOME/go/bin:$PATH <br></code></pre></td></tr></table></figure><p>这样换到别的目录下就可以继续使用编译好的程序了,不过只限当前终端,因为只是添加了一个临时环境变量,没有添加到真正的环境变量中<br>如果想要一直使用的话,就要把它长期添加到环境变量中</p><p>修改 ~&#x2F;.bashrc 文件,这也不是固定的,看用的是哪个 shell<br>我用的是 zsh,所以我要修改的是 ~&#x2F;.zshrc 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.zshrc<br></code></pre></td></tr></table></figure><p>在最后一行添加一行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">export PATH=&quot;$HOME/go/bin:$PATH&quot;<br></code></pre></td></tr></table></figure><p>保持并退出,然后 <code>source ~/.zshrc</code> 或者 <code>source ~/.bashrc</code></p><p>这是在某个特定用户中添加环境变量,这样这个用户就可以每次都会把 GOPATH 添加到他的环境变量中了</p>]]></content>
    
    
    <categories>
      
      <category>Go笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux 搭建Anaconda+PyCharm环境</title>
    <link href="/2022/10/19/ArchLinux-%E6%90%AD%E5%BB%BAAnaconda-PyCharm%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/10/19/ArchLinux-%E6%90%AD%E5%BB%BAAnaconda-PyCharm%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="心血来潮想学-OpenCV"><a href="#心血来潮想学-OpenCV" class="headerlink" title="心血来潮想学 OpenCV"></a>心血来潮想学 OpenCV</h1><p>心血来潮想学一下 OpenCV, 没想到会卡在安装 OpenCV 环境上<br>在安装 OpenCV 环境的时候 anaconda 会一直报错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Solving environment: failed with initial frozen solve. Retrying with flexible solve.<br></code></pre></td></tr></table></figure><p>最后总算是解决了,记录一下,方便以后万一又碰到了呢</p><span id="more"></span><h2 id="安装-PyCharm-和-Anaconda"><a href="#安装-PyCharm-和-Anaconda" class="headerlink" title="安装 PyCharm 和 Anaconda"></a>安装 PyCharm 和 Anaconda</h2><p>安装软件在 Arch Linux 是特别方便的,两条命令搞定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S pycharm-community-edition<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S anaocnda<br></code></pre></td></tr></table></figure><h2 id="配置-Anaconda"><a href="#配置-Anaconda" class="headerlink" title="配置 Anaconda"></a>配置 Anaconda</h2><p>后面会碰到 &#x2F;opt&#x2F;anaconda 这个目录无权限的情况,所以可以把这个文件的所有权改为普通用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo chown -R $USER:$USER /opt/anaconda<br></code></pre></td></tr></table></figure><p>启动 Anaconda</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /opt/anaconda/bin/activate root<br></code></pre></td></tr></table></figure><p>更新 Anaconda</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda update --all<br></code></pre></td></tr></table></figure><p>如果这时候尝试安装 OpenCV 就会蹦出开头的那个错误<br>我使用 Anaconda 是要普通用户来运行,但是默认 Anaconda 只能 root 来运行,这就很矛盾了(当然这个时候 root 用户来安装就没有问题了(´･_･&#96;)</p><p>所以这就需要创建一个普通用户的环境了</p><ol><li>进入 conda 命令行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /opt/anaconda/bin/activate root<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个新环境</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda create --name myenv<br></code></pre></td></tr></table></figure><ol start="3"><li>更改运行的环境为刚才创建的环境</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda activate myenv <br></code></pre></td></tr></table></figure><ol start="4"><li>安装 OpenCV 环境</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda install opencv <br></code></pre></td></tr></table></figure><p>OpenCV 环境安装完成 (ﾟ∀ﾟ)</p><h2 id="PyCharm-使用-Anaconda-环境"><a href="#PyCharm-使用-Anaconda-环境" class="headerlink" title="PyCharm 使用 Anaconda 环境"></a>PyCharm 使用 Anaconda 环境</h2><p>在 PyCharm 中选择 Python 环境为 &#x2F;opt&#x2F;anaconda&#x2F;envs&#x2F;myenv&#x2F;bin&#x2F;python<br><img src="/img/2022-10-19-1.png"></p><p>完成后在程序中尝试导入 cv2,运行不报错表示设置成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_hi</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    print_hi(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p><img src="/img/2022-10-19-2.png" alt="成功运行!"></p><hr><p>大三了,马上就要毕业了,现在要一边准备考研,一边学点新东西了<br>想学 OpenCV 主要还是想能在毕业的时候有点和别人不一样的技能吧 ( ´･ω)<br>尝试做一个自动图像处理的程序出来感觉蛮好的 ヽ(✿ﾟ▽ﾟ)ノ</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
      <tag>Python</tag>
      
      <tag>PyCharm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pacman及yay 多线程编译</title>
    <link href="/2022/10/18/pacman%E5%8F%8Ayay-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E8%AF%91/"/>
    <url>/2022/10/18/pacman%E5%8F%8Ayay-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="更新编译花的时间太长了"><a href="#更新编译花的时间太长了" class="headerlink" title="更新编译花的时间太长了"></a>更新编译花的时间太长了</h1><p>最近更新系统的时候花的时间增加了很多,很大一个原因就是编译用了很多时间<br>这时候一看,好家伙,16核只有1核在工作,其他15个在围观,怪不得编译得这么慢<br>于是我就想着可不可以多线程编译,这样更新就快一点呢<br>最后这个问题成功解决了</p><span id="more"></span><h2 id="设置多线程"><a href="#设置多线程" class="headerlink" title="设置多线程"></a>设置多线程</h2><p>设置多线程只需要修改 &#x2F;etc&#x2F;makepkg.conf 文件就可以解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/makepkg.conf <br></code></pre></td></tr></table></figure><p>找到 MAKEFLAGS 参数,修改 -j 后面的参数为想要用多少个核编译,保持并退出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">MAKEFLAGS=&quot;-j8&quot;<br></code></pre></td></tr></table></figure><p>这时候就已经可以多线程编译了</p><h2 id="使用-Ccache-加快编译"><a href="#使用-Ccache-加快编译" class="headerlink" title="使用 Ccache 加快编译"></a>使用 Ccache 加快编译</h2><p>官方介绍:Ccache 是一个编译工具,可以加速 gcc 对同一个程序的多次编译,尽管第一次编译会花费长一点的时间,有了ccache,后续的编译将变得非常非常快<br>可以使用 Ccache 来加快 pacman 安装的编译速度<br>安装 Ccache</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S ccache<br></code></pre></td></tr></table></figure><p>编辑 &#x2F;etc&#x2F;makepkg.conf, 把 BUILDENV 中 ccache 前的感叹号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">BUILDENV=(!distcc !color ccache !check !sign)<br></code></pre></td></tr></table></figure><p>为了能在命令行中使用,需要修改 $PATH,可以使用下面的命令一次性使用,也可以加入到 ~&#x2F;.bashrc 中一直使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=&quot;/usr/lib/ccache/bin/:$PATH&quot;<br></code></pre></td></tr></table></figure><hr><p>之前真傻,为了让软件编译让电脑单线程跑了一天 ヾ(;ﾟ;Д;ﾟ;)ﾉﾞ<br>现在可以多线程编译了,10分钟就搞定了 (<em>´▽&#96;</em>)</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pacman</tag>
      
      <tag>yay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux设置开机启动frp和qbittorrent-nox</title>
    <link href="/2022/09/19/ArchLinux%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8frp%E5%92%8Cqbittorrent-nox/"/>
    <url>/2022/09/19/ArchLinux%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8frp%E5%92%8Cqbittorrent-nox/</url>
    
    <content type="html"><![CDATA[<h1 id="设置开机启动服务"><a href="#设置开机启动服务" class="headerlink" title="设置开机启动服务"></a>设置开机启动服务</h1><p>正常使用 systemctl 我还是会的,但碰到不是安装好的软件,比如自己下载的程序,没办法直接用 systemctl 的,之前就没想过怎么弄<br>今天刚好想搞一下开机自动启动 frp 和 qbittorrent-nox<br>所以学了一下怎么玩</p><span id="more"></span><h2 id="开机启动-frp"><a href="#开机启动-frp" class="headerlink" title="开机启动 frp"></a>开机启动 frp</h2><p>像 frp 这样的程序可以把它链接到 &#x2F;usr&#x2F;local&#x2F;bin 这个目录下,以后使用起来更方便一点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ln frpc /usr/local/bin/frpc<br></code></pre></td></tr></table></figure><ul><li>&#x2F;usr&#x2F;bin 是系统用户安装的软件的所在目录</li><li>&#x2F;usr&#x2F;local&#x2F;bin 是用户可以自定义的程序目录,推荐放在这个目录下</li></ul><h3 id="编写单元文件"><a href="#编写单元文件" class="headerlink" title="编写单元文件"></a>编写单元文件</h3><p>单元文件可以放在一下两个目录下:</p><ul><li>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F; 软件包安装的单元</li><li>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 系统管理员安装的单元,推荐放在这个目录下</li></ul><p>创建并编辑单元文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/systemd/system/frp.service<br></code></pre></td></tr></table></figure><p>写入一下内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">[Unit]<br>Description=Auto start frp connect<br>After=network.target network-online.target syslog.target<br>Wants=network.target network-online.target<br><br>[Service]<br>Type=simple<br>ExecStart=/home/nero/frp/frpc -c /home/nero/frp/frpc.ini<br>Restart=always<br>RestartSec=5<br>StartLimitInterval=0<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ul><li>Description 是描述这个单元文件的,相当于备注</li><li>After 是需要这些服务启动后再启动</li><li>Wants 是需要这些服务依赖</li><li>Type 设置为默认值simple,表示该服务会立即启动</li><li>ExecStart 表示执行的脚本</li><li>Restart 设置为除非使用 stop,否则一直尝试启动</li><li>RestartSec 设置尝试启动的时间间隔为5s</li><li>StartLimitInterval 尝试的次数,0为无限次</li><li>WantedBy 表示会被哪个用户使用</li></ul><p>保存并退出<br>然后重新载入配置文件,否则无法使用这个单元</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>这样就可以启动这个单元</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start frp<br></code></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable frp<br></code></pre></td></tr></table></figure><h2 id="qbittorrent-nox-使用"><a href="#qbittorrent-nox-使用" class="headerlink" title="qbittorrent-nox 使用"></a>qbittorrent-nox 使用</h2><p>ArchLinux 安装 qbittorrent-nox 时可以先搜索一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Ss qbittorrent<br></code></pre></td></tr></table></figure><p>会发现有一个 qbittorrent-nox 这是自带 WebUI 的,我安装的就是这个</p><p>在命令行输入 qbittorrent-nox 就可以使用它的 WebUI<br>打开浏览器输入 IP:8080 就可访问了<br>账号默认 admin<br>密码默认 adminadmin</p><h3 id="开机启动-qbittorrent-nox"><a href="#开机启动-qbittorrent-nox" class="headerlink" title="开机启动 qbittorrent-nox"></a>开机启动 qbittorrent-nox</h3><p>安装好后,可以先用 whereis 命令找到他的安装目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whereis qbittorrent-nox<br></code></pre></td></tr></table></figure><p>可以看到它被安装到了 &#x2F;usr&#x2F;bin&#x2F;qbittorrent-nox 下<br>然后就可以编辑单元文件了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/systemd/system/qbittorrent.service<br></code></pre></td></tr></table></figure><p>写入一下内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">[Unit]<br>Description=qBittorrent Daemon Service<br>After=network.target<br><br>[Service]<br>ExecStart=/usr/bin/qbittorrent-nox<br>ExecStop=/usr/bin/killall -w qbittorrent-nox<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ul><li>ExecStop 表示停止条件</li></ul><p>保存并退出<br>重新载入配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>启动程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start qbittorrent <br></code></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable qbittorrent<br></code></pre></td></tr></table></figure><p>该做的都做了,重启 <code>reboot</code> 后试着用 frp 连接一次主机,打开一次 qbittorrent-nox 的 WebUI 就知道了 (≧▽≦)</p><hr><p>大三了,该准备考研了,但还是想玩点技术,这样才让生活不那么枯燥<br>身边的人都开始拼命学习了,弄的我好焦虑啊啊啊啊啊 Ծ‸Ծ<br>这个学期开始边复习边玩点技术吧 (˶˚ ᗨ ˚˶)</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
      <tag>systemd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RHEL在vmware下无法连接网络</title>
    <link href="/2022/09/15/RHEL%E5%9C%A8vmware%E4%B8%8B%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/09/15/RHEL%E5%9C%A8vmware%E4%B8%8B%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="vmware下红帽系统无法连接网络"><a href="#vmware下红帽系统无法连接网络" class="headerlink" title="vmware下红帽系统无法连接网络"></a>vmware下红帽系统无法连接网络</h1><p>之前在 manjaro 上碰到过类似的在虚拟机中的系统无法连接到网络<br>暑假把电脑的系统换成了 ArchLinux,里面的数据和配置都被清空了,然后也没有管 vmware 的网络这回事了<br>之前还以为是 manjaro 的问题,换成 ArchLinux 后就没有这样的问题了<br>没想到是我太天真了,无法连接网络的问题还是没能解决<br>但我根着之前的博客做了之后没能解决问题,于是又尝试了新的解决方法,终于解决了</p><span id="more"></span><h2 id="准备好虚拟机需要的网卡"><a href="#准备好虚拟机需要的网卡" class="headerlink" title="准备好虚拟机需要的网卡"></a>准备好虚拟机需要的网卡</h2><p>在之前的博客里也说了怎么添加网卡<br>也可以直接在 Edit -&gt; Virtual Network Editor 下添加网卡,选择 NAT 模式<br>然后在 vmware 的网络设置中设置网络连接方式为 NAT 模式</p><p>如果正常情况下,虚拟机应该是可以访问互联网了,但在 Arch 系(说的就是 manjaro)下就是无法访问互联网</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br></code></pre></td></tr></table></figure><p>在 RHEL 的命令行中查看网卡情况会发现 ens33 这张网卡没有获取到 ip 地址<br><img src="/img/2022-9-15-1.png" alt="ens33这张网卡没有ip地址"></p><p>经过一系列的排查认定应该不是 ArchLinux 的锅,是 vmware 对系统初始的设置有问题<br>需要重新编辑一下网卡的配置文件</p><h2 id="编辑网卡文件"><a href="#编辑网卡文件" class="headerlink" title="编辑网卡文件"></a>编辑网卡文件</h2><p>进入 root 模式,编辑 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts 下的对应网卡文件<br>我的里面是 ens33 网卡,于是发现有一个 ifcfg-ens33 文件,这就是这张网卡的配置文件<br>打开修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p>将 ONBOOT&#x3D;no 选项更改为 ONBOOT&#x3D;yes<br>然后我删掉了一些我认为没用的配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">TYPE=Ethernet<br>BOOTPROTO=dhcp<br>NAME=ens33<br>UUID=44b29690-3d81-461f-9a4b-0f2578d07497<br>DEVICE=ens33<br>ONBOOT=yes<br></code></pre></td></tr></table></figure><p>最主要的就是 ONBOOT 选项改为 yes</p><p>然后重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart network<br></code></pre></td></tr></table></figure><p>再查看 ip 地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br></code></pre></td></tr></table></figure><p><img src="/img/2022-9-15-2.png" alt="问题解决!"></p><hr><p>解决了一个曾经解决过的问题,这下这个问题可以放在一边不考虑一段时间了,可以去干别的事情了(比如摸鱼＼(￣▽￣)／</p><p>好久没有更新博客了,整个暑假都摸鱼去了,别说摸鱼的感觉还挺爽的,直接摸了一个暑假<br>暑假把&lt;&lt;权力的游戏&gt;&gt;看完了,前七季真的是神,最后一季真的是不行,怪不得那么多人说烂尾了<br>不过暑假过去了,再也不能摸鱼了<br>摸鱼的日子不远了,要学点新的技术了,和开始准备考研<br>考上了研究生还能再摸几年的鱼了o(￣▽￣)ｄ</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RHEL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派搭建泰拉瑞亚服务器</title>
    <link href="/2022/08/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/08/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建了一个泰拉瑞亚的服务器"><a href="#搭建了一个泰拉瑞亚的服务器" class="headerlink" title="搭建了一个泰拉瑞亚的服务器"></a>搭建了一个泰拉瑞亚的服务器</h1><p>好久没写博客了，由于各种各样的原因，导致没时间学习，也就没什么博客可以写的<br>由于暑假没学啥，所以都玩去了<br>于是，为了玩游戏玩的更快乐，我就学着拿树莓派(吃灰派)搭建了一各泰拉瑞亚的服务器，可以多人联机</p><span id="more"></span><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>我的树莓派的 Linux 发行版是 ArchLinux，所以可以使用 pacman 来安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S mono tmux<br></code></pre></td></tr></table></figure><p>然后就是下载服务器的环境 TShock，项目地址：<a href="https://github.com/Pryaxis/TShock">https://github.com/Pryaxis/TShock</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/Pryaxis/TShock/releases/download/v4.5.17/TShock4.5.17_Terraria_1.4.3.6.zip<br></code></pre></td></tr></table></figure><p>然后解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip TShock4.5.17_Terraria_1.4.3.6.zip -d TShock<br></code></pre></td></tr></table></figure><h2 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h2><p>进入 TShock ，执行如下命令即可开启服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mono TerrariaServer.exe<br></code></pre></td></tr></table></figure><p>跟着它的要求输入需要的参数就可以了</p><p>后台运行就使用 tmux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux<br>mono TerrariaServer.exe<br></code></pre></td></tr></table></figure><p>然后 Ctrl + b 再按 d 就可以挂起程序了</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>可能会碰到 tmux 的 locale 的问题，这是 locale.gen 文件没有配置好的原因<br>可以修改 &#x2F;etc&#x2F;locale.gen 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/locale.gen<br></code></pre></td></tr></table></figure><p>找到 en_US.UTF_8 UTF-8 去掉前面的注释<br>然后执行如下命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">locale-gen<br></code></pre></td></tr></table></figure><hr><p>好久没写博客了，有一个月了吧<br>挨 :( 最近的事太多了，都没有时间学习，就更别说写博客了<br>开学后可能就有时间了 &#x2F;ᐠ｡ꞈ｡ᐟ\</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Server</tag>
      
      <tag>Terraria</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>make oldconfig 理解</title>
    <link href="/2022/07/11/make-oldconfig-%E7%90%86%E8%A7%A3/"/>
    <url>/2022/07/11/make-oldconfig-%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="对-make-oldconfig-命令的理解"><a href="#对-make-oldconfig-命令的理解" class="headerlink" title="对 make oldconfig 命令的理解"></a>对 make oldconfig 命令的理解</h1><span id="more"></span><p>Linux 内核会默认一个 .config 文件配置，这是跟着内核源文件走的<br>使用 <code>make defconfig</code> 可以把这个配置放到 .config 文件中<br>修改 .config 文件，比如使用 <code>make config</code>、<code>make memuconfig</code> 或者直接编辑 .config 文件<br>使用 <code>make oldconfig</code> 命令会把这个修改了的配置放到 .config.old 文件中作为备用，表示这个配置已经可以被用来编译了<br>.config 文件就会回到默认配置，而 .config.old 文件就是对当前的配置做了个备份<br>以后就可以直接把 .config.old 里面的配置，放到别的准备编译的内核目录下的 .config 文件中使用了<br>这样就可以很方便的采用现有配置并将其移动到新内核中</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派编译ArchLinux aarch64内核</title>
    <link href="/2022/07/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BC%96%E8%AF%91ArchLinux-aarch64%E5%86%85%E6%A0%B8/"/>
    <url>/2022/07/09/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BC%96%E8%AF%91ArchLinux-aarch64%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="升级树莓派"><a href="#升级树莓派" class="headerlink" title="升级树莓派"></a>升级树莓派</h1><p>树莓派用了一段时间之后发现，我之前装的系统是32位的 ArchLinux<br>但树莓派4b本身是支持64位系统的，所以捣鼓了一天，把系统升级了一下<br>其实也就是编译了一个系统</p><p>还有就是官方的 aarch64 镜像有问题，按照 wiki 安装是无法成功的<br>现在可以安装 64 位 ArchLinux 的方法只能自己编译一个了</p><span id="more"></span><h2 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a>编译准备</h2><p>先安装编译需要用到的交叉编译软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S aarch64-linux-gnu-gcc<br></code></pre></td></tr></table></figure><p>下载树莓派的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone -b rpi-5.15.y --depth=1 https://github.com/raspberrypi/linux.git raspberrypi-linux<br></code></pre></td></tr></table></figure><ul><li>-b 表示分支，可以去 GitHub 上选择需要的分支</li></ul><p><a href="https://github.com/raspberrypi/linux">https://github.com/raspberrypi/linux</a></p><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>进入下载好的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd raspberrypi-linux<br>make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- bcm2711_defconfig<br></code></pre></td></tr></table></figure><p>多线程编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j 8<br></code></pre></td></tr></table></figure><ul><li>-j 表示同时使用几个线程编译</li></ul><p>将编译好后的整个文件夹拷贝到树莓派中，这里我是直接把 TF 卡挂载到电脑上复制的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -r raspberrypi-linux /mnt/home/nero<br></code></pre></td></tr></table></figure><h2 id="生成内核模块"><a href="#生成内核模块" class="headerlink" title="生成内核模块"></a>生成内核模块</h2><p>连接上树莓派，进入刚刚复制的目录，进入到 arch&#x2F;arm64&#x2F;boot 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd raspberrypi-linux/arch/arm64/boot<br></code></pre></td></tr></table></figure><p>然后执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp Image /boot/kernel8.img<br>cp dts/broadcom/*.dtb /boot/<br>cp dts/overlays/*.dtb* /boot/overlays/<br>cp dts/overlays/README /boot/overlays/<br></code></pre></td></tr></table></figure><p>回到 raspberrypi-linux 目录下<br>安装 kmod 依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S kmod<br></code></pre></td></tr></table></figure><p>执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make ARCH=arm64 modules_install<br></code></pre></td></tr></table></figure><p>最后修改 &#x2F;boot下的 config.txt 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">arm_64bit=1 kernel=kernel8.img<br></code></pre></td></tr></table></figure><p><img src="/img/2022-7-9-1.png" alt="删掉了一行，修改了一行"></p><p>重启 <code>reboot</code></p><p>进入树莓派，查看是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname -m<br></code></pre></td></tr></table></figure><p><img src="/img/2022-7-9-2.png" alt="成功!"></p><hr><p>上午刚考完科目一，99过了，高兴  ♪（＾∀＾●）ﾉｼ<br>下午又捣鼓到了晚上，捣鼓成功了，舒爽 （●´∀｀）♪<br>今天既体会到了高兴，又解决了想做的事情，真是快乐的一天啊 (¦3[▓▓]</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aarch64</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 搭建下载器及播放器</title>
    <link href="/2022/07/06/Docker-%E6%90%AD%E5%BB%BA%E4%B8%8B%E8%BD%BD%E5%99%A8%E5%8F%8A%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2022/07/06/Docker-%E6%90%AD%E5%BB%BA%E4%B8%8B%E8%BD%BD%E5%99%A8%E5%8F%8A%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="下载器及播放器"><a href="#下载器及播放器" class="headerlink" title="下载器及播放器"></a>下载器及播放器</h1><p>搭建一个下载器和一个播放器，这两个一组合，不就是一个家庭影院嘛<br>想到暑假在家不可能整天都在学习，没事看部电影补补番剧，放松一下也不是不可以<br>于是我就尝试用 Docker 搭建了一个BT下载器和播放器</p><span id="more"></span><h2 id="搭建下载器"><a href="#搭建下载器" class="headerlink" title="搭建下载器"></a>搭建下载器</h2><p>下载器用的是 GitHub 上的开源项目 Aria2 Pro (<a href="https://github.com/P3TERX/Aria2-Pro-Docker">https://github.com/P3TERX/Aria2-Pro-Docker</a>) 搭建的<br>DockerHub 上可以直接拿来用<br>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull p3terx/aria2-pro<br></code></pre></td></tr></table></figure><p>创建两个文件夹，一个存放配置文件，一个存放下载好的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /home/aria2-config<br>mkdir /home/aria2-downloads<br></code></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>--name aria2-pro \<br>--restart unless-stopped \<br>--log-opt max-size=1m \<br>--network host \<br>-e PUID=$UID \<br>-e PGID=$GID \<br>-e RPC_SECRET=nero371215 \<br>-e RPC_PORT=6800 \<br>-e LISTEN_PORT=6888 \<br>-v /home/aria2-config:/config \<br>-v /home/aria2-downloads:/downloads \<br>p3terx/aria2-pro<br></code></pre></td></tr></table></figure><h2 id="GUI-界面"><a href="#GUI-界面" class="headerlink" title="GUI 界面"></a>GUI 界面</h2><p>下载器只是一个下载器，可以再用 Docker 搭建一个图形化界面出来<br>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull p3terx/ariang<br></code></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>--name ariang \<br>--restart unless-stopped \<br>--log-opt max-size=1m \<br>-p 6880:6880 \<br>p3terx/ariang<br></code></pre></td></tr></table></figure><p>打开浏览器，进入服务器 IP:6880<br>设置 aria2 pro 设置的token<br><img src="/img/2022-7-6-1.png"></p><p>连接成功后就可以使用了</p><h2 id="搭建播放器"><a href="#搭建播放器" class="headerlink" title="搭建播放器"></a>搭建播放器</h2><p>这里我使用的是 GitHub 上的开源项目 jellyfin (<a href="https://github.com/jellyfin/jellyfin">https://github.com/jellyfin/jellyfin</a>)<br>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull jellyfin/jellyfin<br></code></pre></td></tr></table></figure><p>创建两个目录，一个配置文件和一个缓存文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /home/jellyfin-cache<br>mkdir /home/jellyfin-config<br></code></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>--name jellyfin \<br>--net=host \<br>--volume /home/jellyfin-config:/config \<br>--volume /home/jellyfin-cache:/cache \<br>--mount type=bind,source=/home/aria2-downloads,target=/media \<br>--restart=unless-stopped \<br>jellyfin/jellyfin<br></code></pre></td></tr></table></figure><p>–mount 参数和 -v 或者 –volume 差不多，但在这个地方更建议使用 –mount 参数<br><img src="/img/2022-7-6-2.png" alt="更建议使用 --mount"></p><p><a href="https://docs.docker.com/storage/bind-mounts/">https://docs.docker.com/storage/bind-mounts/</a><br>所以此处使用 –mount 参数</p><p>打开浏览器 进入 IP:8096<br>完成一系列设置后，就可以开始使用播放器了</p><hr><p>总算是把下载器和播放器搞定了，下载器有了，播放器有了，大量资源也有了<br>这个暑假不至于学没学到什么，又没有玩到什么了<br>芜湖~起飞 ٩(●˙▿˙●)۶…⋆ฺ</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Jellyfin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UEFI引导安装ArchLinux</title>
    <link href="/2022/06/30/UEFI%E5%BC%95%E5%AF%BC%E5%AE%89%E8%A3%85ArchLinux/"/>
    <url>/2022/06/30/UEFI%E5%BC%95%E5%AF%BC%E5%AE%89%E8%A3%85ArchLinux/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一下安装-Arch"><a href="#记录一下安装-Arch" class="headerlink" title="记录一下安装 Arch"></a>记录一下安装 Arch</h1><p>安装 ArchLinux 作为实体机已经有一段时间了，现在来记录一下安装的过程<br>正好刚才给另外一台主机也安装了 ArchLinux，又加强了一点印象</p><span id="more"></span><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>这里很简单，可以用 ventoy 制作一个启动盘，把 ISO 镜像放进U盘就可以了<br>记得用 sha256sum 或 md5 计算下载后文件的哈希值，并和官网的进行对比<br>将U盘插上主机，进入 BIOS 将U盘启动设置为首项<br>重启</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>进入 ventoy，选择 ArchLinux 镜像<br>选择 <code>Arch Linux install medium</code> 进入安装环境</p><h3 id="验证引导模式"><a href="#验证引导模式" class="headerlink" title="验证引导模式"></a>验证引导模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /sys/firmware/efi/efivars<br></code></pre></td></tr></table></figure><p>如果系统是以 UEFI 模式引导的，会列出该文件夹中的文件，否则会报错<br><img src="/img/2022-6-30-1.png"></p><h3 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h3><p>网络设置是最让我头大的，之前几次想安装 ArchLinux 到实体机上的时候，都卡在了网络这一步<br>后面下载软件的时候一定要记得下载网络管理工具！</p><p>检查网络接口是否已启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip link<br></code></pre></td></tr></table></figure><ul><li>如果是用网线连接的，插上网线就可以了</li><li>如果是用 WiFi 连接的，可以使用 iwctl 连接</li></ul><h4 id="iwctl-连接-WiFi"><a href="#iwctl-连接-WiFi" class="headerlink" title="iwctl 连接 WiFi"></a>iwctl 连接 WiFi</h4><p>进入 iwctl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iwctl<br></code></pre></td></tr></table></figure><p>列出所有 WiFi 设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">device list<br></code></pre></td></tr></table></figure><p>使用无线设备扫描网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">station wlan0 scan<br></code></pre></td></tr></table></figure><p>列出可用网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">station wlan0 get-networks<br></code></pre></td></tr></table></figure><p>连接到网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">station wlan0 connect &lt;SSID&gt;<br></code></pre></td></tr></table></figure><p>如果有密码输入密码就可以了</p><p>退出 iwctl 后可以检测一下是否连接到了网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping archlinux.org<br></code></pre></td></tr></table></figure><h3 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">timedatectl set-ntp true<br></code></pre></td></tr></table></figure><h3 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h3><p>很重要的一步，由于是用 UEFI 引导，所以需要创建两个分区，一个 EFI系统分区，一个根分区，如果需要 Swap 分区，可以查看 wiki<br>查看系统识别到的硬盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fdisk -l<br></code></pre></td></tr></table></figure><p><img src="/img/2022-6-30-2.png" alt="可以看到有一块30G的硬盘 &#x2F;dev&#x2F;sda"></p><p>可以使用 cfdisk 分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cfdisk /dev/sda<br></code></pre></td></tr></table></figure><p><img src="/img/2022-6-30-3.png"></p><p>选择一块需要安装系统的分区，我是把整个硬盘拿来装系统的<br>如果有不需要的分区，可以选择 Delete 删掉这个分区</p><p>选择 new，输入 EFI 所占空间，最小为 300M<br><img src="/img/2022-6-30-4.png"></p><p>选择 Type 把分许类型改为 EFI System<br><img src="/img/2022-6-30-5.png"></p><p>剩下的全部分给根分区<br><img src="/img/2022-6-30-6.png"></p><p>完成后选择 Write，输入 yes，然后下面会提示修改成功<br>Quit 退出 cfdisk，修改成功后可以查看是否修改成功<br><img src="/img/2022-6-30-7.png"></p><h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h3><p>格式化根分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs.ext4 /dev/sda2<br></code></pre></td></tr></table></figure><p>格式化 EFI 分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs.fat -F 32 /dev/sda1<br></code></pre></td></tr></table></figure><h3 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h3><p>将根分区挂载到 <code>/mnt</code> 下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount /dev/sda2 /mnt<br></code></pre></td></tr></table></figure><p>挂载 EFI 分区需要在 &#x2F;mnt 下创建一个 boot 目录，然后再挂在到 boot 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /mnt/boot<br></code></pre></td></tr></table></figure><p>挂载 EFI 分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount /dev/sda1 /mnt/boot<br></code></pre></td></tr></table></figure><h3 id="安装必需的软件包"><a href="#安装必需的软件包" class="headerlink" title="安装必需的软件包"></a>安装必需的软件包</h3><p>这是将 Linux 装进硬盘中的步骤<br>可以在这一步提前安装以后会用的软件，比如 vim，dhcpcd，networkmanager<br>尤其要注意安装网络管理工具！否则新系统无法连接网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap /mnt base linux linux-firmware vim dhcpcd networkmanager<br></code></pre></td></tr></table></figure><p>如果这一步没有安装网络管理工具，导致安装的系统无法连接网络，可以插入启动盘，挂载主分区，再用上面的命令安装需要的软件<br>这种方法也可以用来安装其他软件</p><h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><p>生成 fstab 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure><p>进入新安装的系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">arch-chroot /mnt<br></code></pre></td></tr></table></figure><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br></code></pre></td></tr></table></figure><p>生成 &#x2F;etc&#x2F;adjtime</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hwclock --systohc<br></code></pre></td></tr></table></figure><h3 id="区域设置"><a href="#区域设置" class="headerlink" title="区域设置"></a>区域设置</h3><p>设置 &#x2F;etc&#x2F;locale.gen 文件，取消掉 en_US.UTF-8 UTF-8 的注释<br><img src="/img/2022-6-30-8.png"><br>生成 locale 信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">locale-gen<br></code></pre></td></tr></table></figure><p>创建 &#x2F;etc&#x2F;locale.conf 文件，编辑 LANG 变量</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">LANG=en_US.UTF-8<br></code></pre></td></tr></table></figure><h3 id="配置主机名"><a href="#配置主机名" class="headerlink" title="配置主机名"></a>配置主机名</h3><p>创建 &#x2F;etc&#x2F;hostname 文件，编辑主机名</p><h3 id="设置-root-密码"><a href="#设置-root-密码" class="headerlink" title="设置 root 密码"></a>设置 root 密码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd<br></code></pre></td></tr></table></figure><h3 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h3><p>这一步我选择安装 GRUB 引导<br>安装 grub 和 efibootmgr</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S grub efibootmgr<br></code></pre></td></tr></table></figure><p>安装引导</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB<br></code></pre></td></tr></table></figure><p>生成 &#x2F;boot&#x2F;grub&#x2F;grub.cfg 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h3 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h3><p><code>exit</code> 退出 chroot 环境<br><code>reboot</code> 重启电脑<br>系统安装完成</p><h3 id="安装-KDE-桌面"><a href="#安装-KDE-桌面" class="headerlink" title="安装 KDE 桌面"></a>安装 KDE 桌面</h3><p>安装 xorg-server 软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S xorg-server<br></code></pre></td></tr></table></figure><p>安装显卡对应的驱动<br><img src="/img/2022-6-30-9.png"><br>我安装的是 AMD 的驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S xf86-video-amdgpu<br></code></pre></td></tr></table></figure><p>安装 plasma-meta 元软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S plasma-meta<br></code></pre></td></tr></table></figure><p>安装 KDE 应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S kde-applications <br></code></pre></td></tr></table></figure><p>安装 SDDM</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -S sddm<br></code></pre></td></tr></table></figure><p>设置开机启动 SDDM</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable sddm.service<br></code></pre></td></tr></table></figure><p>重启 <code>reboot</code></p><hr><p>总算是把这一篇博客写出来了，安装 ArchLinux 其实不难，跟着 wiki 走，很快就可以搞定<br>安装好 ArchLinux 后，要记得常更新，小心滚挂 (´･ω･&#96;)</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArchLinux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 搭建 nextcloud 网盘</title>
    <link href="/2022/06/29/Docker-%E6%90%AD%E5%BB%BA-nextcloud-%E7%BD%91%E7%9B%98/"/>
    <url>/2022/06/29/Docker-%E6%90%AD%E5%BB%BA-nextcloud-%E7%BD%91%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建个人网盘"><a href="#搭建个人网盘" class="headerlink" title="搭建个人网盘"></a>搭建个人网盘</h1><p>终于想起来要搭建一个个人网盘，于是学习了一下使用 docker 搭建了一个个人网盘，记录一下搭建的过程<br>使用 mysql 作为数据库</p><span id="more"></span><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql<br>docker pull nextcloud<br></code></pre></td></tr></table></figure><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>创建并运行 mysql 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 3306:3306 --name nextcloud_db -e MYSQL_ROOT_PASSWORD=371215 mysql<br></code></pre></td></tr></table></figure><p>进入 nextcloud_db 容器，创建一个数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it nextcloud_db /bin/bash<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p<br><br><span class="hljs-keyword">create</span> database nextcloud;<br></code></pre></td></tr></table></figure><p>创建并运行 nextcloud 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 10101:80 --name nextcloud \<br>-v /home/nextcloud:/var/www/html \<br>-v /home/nextcloud/apps:/var/www/html/custom_apps \<br>-v /home/nextcloud/config:/var/www/html/config \<br>-v /home/nextcloud/data:/var/www/html/data \<br>nextcloud<br></code></pre></td></tr></table></figure><ul><li>-v 参数表示将镜像中的目录映射到某一个本地目录下</li></ul><p>网上很多教程都说要用 <code>--link</code> 参数，但我看了 docker 的文档，上面建议不要使用 <code>--link</code> 这个参数<br><img src="/img/2022-6-29-1.png" alt="不建议使用这个参数，可能会被移除"><br><a href="https://docs.docker.com/network/links/">https://docs.docker.com/network/links/</a></p><p>所以我没有使用这个参数，后面也不用必须连接某个容器，可以直接使用网络连接数据库</p><h2 id="设置网盘"><a href="#设置网盘" class="headerlink" title="设置网盘"></a>设置网盘</h2><p>打开浏览器，输入网盘的 IP 地址和端口，设置参数<br><img src="/img/2022-6-29-2.png" alt="数据库的地址填ip:port"></p><p>设置好后等就可以了</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>frp 服务端设置 frps.ini</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">[common]<br>bind_port = 7000<br>vhost_http_port = 10086<br></code></pre></td></tr></table></figure><p>启动frps</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nohup ./frps -c frps.ini &gt; /dev/null 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>frp 客户端设置 frpc.ini</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[web]<br>type = http<br>local_port = 10101<br>custom_domains = X.X.X.X<br></code></pre></td></tr></table></figure><p>启动frpc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nohup ./frpc -c frpc.ini &gt; /dev/null 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>打开浏览器，输入 服务器 IP:10086，会碰到无法访问的问题，这是因为这个 IP 地址不受到信任<br><img src="/img/2022-6-29-3.png"></p><p>进入 nextcloud 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it nextcloud /bin/bash<br></code></pre></td></tr></table></figure><p>安装 vim 并修改 &#x2F;var&#x2F;www&#x2F;html&#x2F;nextcloud&#x2F;config&#x2F;config.php 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get update<br>apt-get install vim<br>vim /var/www/html/config/config.php<br></code></pre></td></tr></table></figure><p>找到 trusted_domains 这一项，在后面的 array 的括号里添加一项服务器的 IP 地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs test">&#x27;trusted_domains&#x27; =&gt; <br>  array (<br>          0 =&gt; &#x27;192.168.0.105:10101&#x27;,<br>          1 =&gt; &#x27;X.X.X.X&#x27;<br>  ),<br></code></pre></td></tr></table></figure><p>保存并退出，浏览器刷新一下就可以了<br><img src="/img/2022-6-29-4.png"></p><hr><p>总算是把网盘给搭建好了，后面可以再做一个加速的操作，这样我就有一个自己的不限速的网盘了<br>以后可以买几块大的硬盘放家里，存些我自己的数据，随时拿随时取咯 (ᕑᗢᓫ∗)˒</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aur无法更新下载</title>
    <link href="/2022/06/23/aur%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0%E4%B8%8B%E8%BD%BD/"/>
    <url>/2022/06/23/aur%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="aur-无法更新和下载"><a href="#aur-无法更新和下载" class="headerlink" title="aur 无法更新和下载"></a>aur 无法更新和下载</h1><p>今天碰到了很无语的事，aur 无法使用</p><span id="more"></span><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">request failed: Get &quot;https://aur.tuna.tsinghua.edu.cn/xxxxxx&quot;: dial tcp: lookup aur.tuna.tsinghua.edu.cn: no such host<br></code></pre></td></tr></table></figure><p>翻译过来就是该主机不可达，然后我尝试重新换了一次源，还是没有用<br>就在查着 google 的时候，发现清华的 aur 源关闭了<br>怪不得无法下载，于是换了个官方源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay --aururl &quot;https://aur.archlinux.org&quot; --save<br></code></pre></td></tr></table></figure><p>然后再下载更新，就没问题了</p><hr><p>就很无语，之前下好 yay 的时候不应该换源的，就应该用官方源的<br>官方源慢，但挂上代理之后就快很多了，还是好好用官方源吧</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aur</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派安装ArchLinux</title>
    <link href="/2022/06/21/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ArchLinux/"/>
    <url>/2022/06/21/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85ArchLinux/</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派到货了"><a href="#树莓派到货了" class="headerlink" title="树莓派到货了"></a>树莓派到货了</h1><p>心心念念的树莓派终于到货了，安装了个 ArchLinux 系统，能跑起来<br>在树莓派上安装 ArchLinux 比在电脑上安装简单太多了吧<br>记录一下安装的流程</p><span id="more"></span><h2 id="在-SD-卡上安装系统"><a href="#在-SD-卡上安装系统" class="headerlink" title="在 SD 卡上安装系统"></a>在 SD 卡上安装系统</h2><p>ArchLinux 官方就有教程，我这篇记录就当是汉化吧 o(´^｀)o<br><a href="https://archlinuxarm.org/platforms/armv8/broadcom/raspberry-pi-4">https://archlinuxarm.org/platforms/armv8/broadcom/raspberry-pi-4</a></p><ol><li>在 SD 卡上分区</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fdisk /dev/sdX<br></code></pre></td></tr></table></figure><ol start="2"><li>删除旧分区，创建新分区</li></ol><ul><li>键入 o ，清除驱动器上的所有分区</li><li>键入 p ，列出分区，此处应该没有任何分区</li><li>输入 n ，然后 p 表示主分区，然后 1 表示驱动器上的第一个分区，然后回车使用默认的第一个扇区，然后输入 +200M 表示最后一个扇区</li><li>键入 t ，然后 c 将第一个分区设置为键入 W95 FAT32 (LBA)</li><li>键入 n ，然后 p 表示主分区，然后 2 表示驱动器上的第二个分区，然后两次 回车 表示默认的第一个和最后一个扇区</li><li>键入 w ，表示写入分区表并推出</li></ul><ol start="3"><li>创建并挂载 FAT 文件系统</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs.vfat /dev/sdX1<br>mkdir boot<br>mount /dev/sdX1 boot<br></code></pre></td></tr></table></figure><ol start="4"><li>创建并挂载 ext4 文件系统</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs.ext4 /dev/sdX2<br>mkdir root<br>mount /dev/sdX2 root<br></code></pre></td></tr></table></figure><ol start="5"><li>下载并解压根文件系统，root 权限下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-armv7-latest.tar.gz<br>bsdtar -xpf ArchLinuxARM-rpi-armv7-latest.tar.gz -C root<br>sync<br></code></pre></td></tr></table></figure><ol start="6"><li>将引导文件移动到第一个分区</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv root/boot/* boot<br></code></pre></td></tr></table></figure><ol start="7"><li>卸载两个分区</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">umount boot root<br></code></pre></td></tr></table></figure><h2 id="树莓派启动"><a href="#树莓派启动" class="headerlink" title="树莓派启动"></a>树莓派启动</h2><p>将 SD 卡插入树莓派，连上电源，还有网线<br>这样就可以通过 ssh 连接树莓派了<br>默认用户为 alarm 密码为 alarm<br>默认 root 密码为 root</p><p>初始化 pacman 密钥环并填充 Arch Linux ARM 包签名 密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman-key --init<br>pacman-key --populate archlinuxarm<br></code></pre></td></tr></table></figure><h2 id="更换国内源"><a href="#更换国内源" class="headerlink" title="更换国内源"></a>更换国内源</h2><p>编辑 &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist ，最顶部添加</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/$arch/$repo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Syyu<br></code></pre></td></tr></table></figure><h2 id="记得开启必要的服务"><a href="#记得开启必要的服务" class="headerlink" title="记得开启必要的服务"></a>记得开启必要的服务</h2><p>ssh 和 dhcp 这两个服务一定要记得开启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable sshd<br>systemctl enable dhcpcd<br></code></pre></td></tr></table></figure><hr><p>心心念念的树莓派终于到了，可以好好玩玩了，暑假有事情做了<br>不过树莓派安装 ArchLinux 也太简单了，照着官方文档做，一下就搞定了<br>下次找个时间写一下电脑安装 ArchLinux 的博客吧 |•’-‘•) ✧</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArchLinux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KDE 美化</title>
    <link href="/2022/06/18/KDE-%E7%BE%8E%E5%8C%96/"/>
    <url>/2022/06/18/KDE-%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="爱美之心"><a href="#爱美之心" class="headerlink" title="爱美之心"></a>爱美之心</h1><p>kde 原本就蛮好看的，安装好后可以直接使用，开箱即用<br>但是我还是不满足这初始的 UI，所以今天花了点时间研究了一下 KDE 的美化</p><span id="more"></span><h2 id="全局主题"><a href="#全局主题" class="headerlink" title="全局主题"></a>全局主题</h2><p>KDE 的主题可以在 System Settings -&gt; Appearance -&gt; Global Theme 右下角 Get New Global Themes 中获取<br>但是速度嘛…开着代理都很慢<br>所以可以去 kde store 里面下载好主题的压缩包，然后自行安装，这样速度可以快很多<br><a href="https://store.kde.org/browse">https://store.kde.org/browse</a><br>进去后选择 Global Themes，找一个觉得好看的主题下载它的 tar 压缩包<br>解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xf xxx.tar.xz<br></code></pre></td></tr></table></figure><p>把解压后的文件放在 ~&#x2F;.local&#x2F;share&#x2F;plasma&#x2F;look-and-feel 目录下，没有就用 mkdir 创建<br>这样就可以在设置主题的界面选择这个主题了</p><h2 id="设置-Splash-Screen"><a href="#设置-Splash-Screen" class="headerlink" title="设置 Splash Screen"></a>设置 Splash Screen</h2><p>Splash Screen 是登陆后进入桌面前的一段动画，可以在 System Settings -&gt; Appearance -&gt; Splash Screen 中设置<br>正常下载很慢，所以还是到 kde store 上下载<br>设置 Splash Screen 和设置全局主题的步骤几乎是一样的，连目录的都是在 look-and-feel 下<br>这个很轻松就设置好了</p><h2 id="设置-SDDM"><a href="#设置-SDDM" class="headerlink" title="设置 SDDM"></a>设置 SDDM</h2><p>这就是登陆界面的主题，我直接用了 Breeze 这个主题，换了张图片<br>在 System Settings -&gt; Startup and Shutdown -&gt; Login Screen 中设置</p><h2 id="设置睡眠唤醒后的壁纸"><a href="#设置睡眠唤醒后的壁纸" class="headerlink" title="设置睡眠唤醒后的壁纸"></a>设置睡眠唤醒后的壁纸</h2><p>在 System Settings -&gt; Workspace Behavior -&gt; Screen Locking 中设置</p><h2 id="设置-latte-dock"><a href="#设置-latte-dock" class="headerlink" title="设置 latte-dock"></a>设置 latte-dock</h2><p>这是一个类似 Mac 的任务栏工具，用起来有苹果的质感<br>安装 latte-dock</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S latte-dock<br></code></pre></td></tr></table></figure><p>启动 latte-dock</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">latte-dock<br></code></pre></td></tr></table></figure><p>可以在 System Settings -&gt; Startup and Shutdown -&gt; Autostart 中设置 latte-dock 开机自启</p><hr><p>弄了一天，总算把系统的美化搞定了，顺便把一些常用的工具给下回来了<br>摸鱼了一天，虽然没有学习，但还是辛苦自己了.jpg<br>系统调好了，终于可以安心用我的 ArchLinux 了<br>展示一下今天的成果吧<br><img src="/img/2022-6-18-1.png" alt="Arch 娘当 ArchLinux 桌面真有意思"></p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux 网络问题</title>
    <link href="/2022/06/17/ArchLinux%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2022/06/17/ArchLinux%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="ArchLinux-安装成功"><a href="#ArchLinux-安装成功" class="headerlink" title="ArchLinux 安装成功"></a>ArchLinux 安装成功</h1><p>一放假，我就把电脑的系统换成了 ArchLinux，这一次做足了准备，碰到的问题都解决了<br>不然也没机会写这篇博客啊</p><span id="more"></span><h2 id="安装好后无法联网"><a href="#安装好后无法联网" class="headerlink" title="安装好后无法联网"></a>安装好后无法联网</h2><p>ArchLinux 在安装的时候还能连上 WiFi，安装好后就连不上了，因为联网的工具都没了<br>问题产生原因是在安装 ArchLinux 的时候没有将网络管理工具装进系统<br><img src="/img/2022-6-17-1.png" alt="这一步的问题"></p><p>由于已经安装好了系统，所以需要重新进入 live 环境，也就是插上启动盘，进入安装界面<br>然后在 live 环境下用 iwctl 连接 WiFi<br>挂载电脑的系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount /dev/root_partition(根分区) /mnt<br></code></pre></td></tr></table></figure><p>安装软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap -i /mnt iwd dhcpcd networkmanager pacman<br></code></pre></td></tr></table></figure><p>重新进入系统，然后就可以用 iwd 连接 WiFi 了</p><h2 id="iwd-连接了-WiFi-但没有-IP-地址"><a href="#iwd-连接了-WiFi-但没有-IP-地址" class="headerlink" title="iwd 连接了 WiFi 但没有 IP 地址"></a>iwd 连接了 WiFi 但没有 IP 地址</h2><p>这是因为 DHCP 没有设置好，开启 DHCP 服务就好了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start dhcpcd<br>systemctl start iwd<br></code></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable dhcpcd<br>systemctl enable iwd<br></code></pre></td></tr></table></figure><h2 id="GRUB-安装提醒"><a href="#GRUB-安装提醒" class="headerlink" title="GRUB 安装提醒"></a>GRUB 安装提醒</h2><p>安装好 grub 后，一定要生成 grub.cfg 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><p>今天装了三次 ArchLinux ，安装的步骤都轻车熟路了，下次有机会写一篇安装 ArchLinux 的博客吧<br>一定要记得生成 grub.cfg 文件 ╰（‵□′）╯</p><hr><p>安装一个 ArchLinux 也不难嘛，多敲几次命令就会了，之前还想着怎么安装呢，没想到几个小时就大概摸清楚了<br>靠着之前的博客，输入法等其他工具的安装也是一下子就搞定了，快速恢复到趋近与之前的 Manjaro 了<br>也是时候美化一下了<br>展示一波我的 ArchLinux （&#x3D;￣ω￣&#x3D;）<br><img src="/img/2022-6-17-2.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArchLinux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Stream流</title>
    <link href="/2022/06/12/Java-Stream%E6%B5%81/"/>
    <url>/2022/06/12/Java-Stream%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="很方便的一个东西"><a href="#很方便的一个东西" class="headerlink" title="很方便的一个东西"></a>很方便的一个东西</h1><p>对于数组的处理肯定会用到 for 循环，不过如果要对一个数组进行多次操作的话，肯定会需要中间数组<br>而使用 Stream 流的方式，就可以全程只对一个数组进行操作了<br>就像流水线上生产的物品，Stream 流就是把数组变成一个待加工的物件，每一步操作都对这个流进行操作</p><span id="more"></span><h2 id="创建-Stream-流"><a href="#创建-Stream-流" class="headerlink" title="创建 Stream 流"></a>创建 Stream 流</h2><p>创建 Stream 流的方式很简单，List,Set,Map 都有 stream() 方法，可以把组转换为流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Stream&lt;String&gt; stream1 = list.stream();<br><br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>Stream&lt;String&gt; stream2 = set.stream();<br><br>Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Set&lt;String&gt; keySet = map.keySet();<br>Stream&lt;String&gt; stream3 = keySet.stream();<br><br>Collection&lt;String&gt; values = map.values();<br>Stream&lt;String&gt; stream4 = values.stream();<br><br>Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();<br>Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream();<br></code></pre></td></tr></table></figure><p>也可以使用 Stream.of() 方法来创建流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream1 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br>Integer[] arr1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>Stream&lt;Integer&gt; stream1 = Stream.of(arr1);<br><br>String[] arr2 = &#123;<span class="hljs-string">&quot;aba&quot;</span>, <span class="hljs-string">&quot;kua&quot;</span>, <span class="hljs-string">&quot;gua&quot;</span>&#125;;<br>Stream&lt;String&gt; stream3 = Stream.of(arr2);<br></code></pre></td></tr></table></figure><h2 id="使用-Stream-流"><a href="#使用-Stream-流" class="headerlink" title="使用 Stream 流"></a>使用 Stream 流</h2><p>Stream 流可以实现链式编程，有的方法返回的也是 Stream 流<br>有的返回的不是 Stream 流，这就是终结方法</p><h3 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach 方法"></a>forEach 方法</h3><p>遍历整个数组，没有返回值，是终结方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-string">&quot;ddd&quot;</span>);<br>stream.forEach((name)-&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;str:&quot;</span> + name);<br>&#125;);<br></code></pre></td></tr></table></figure><p>遍历这个流，然后在方法中写入该怎么遍历，可以传入一个 lambda 表达式</p><h3 id="count-方法"><a href="#count-方法" class="headerlink" title="count 方法"></a>count 方法</h3><p>返回数组的长度，是终结方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stream.count();<br>System.out.println(count);<br></code></pre></td></tr></table></figure><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter 方法"></a>filter 方法</h3><p>过滤数组，返回 Stream 流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>str.add(<span class="hljs-string">&quot;w t f&quot;</span>);<br>str.add(<span class="hljs-string">&quot;fuck me&quot;</span>);<br>str.add(<span class="hljs-string">&quot;what the hell&quot;</span>);<br>str.add(<span class="hljs-string">&quot;surprise mother fucker&quot;</span>);<br>Stream&lt;String&gt; stream = str.stream();<br>stream.filter((name) -&gt; &#123;<span class="hljs-keyword">return</span> name.startsWith(<span class="hljs-string">&quot;w&quot;</span>);&#125;).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>调用 filter 方法，里面传入过滤的规则，然后返回过滤后的流，可以继续使用这个流进行链式编程</p><h3 id="limit-方法"><a href="#limit-方法" class="headerlink" title="limit 方法"></a>limit 方法</h3><p>就是返回数组的前多少个元素组成新的流，返回 Stream 流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;cao&quot;</span>, <span class="hljs-string">&quot;wlg&quot;</span>&#125;;<br>Stream&lt;String&gt; stream = Arrays.stream(arr);<br>Stream&lt;String&gt; stream1 = stream.limit(<span class="hljs-number">2</span>); <span class="hljs-comment">//只要前两个元素</span><br>stream1.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="skip-方法"><a href="#skip-方法" class="headerlink" title="skip 方法"></a>skip 方法</h3><p>返回跳过了几个元素后的流，返回 Stream 流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;草&quot;</span>, <span class="hljs-string">&quot;靠&quot;</span>, <span class="hljs-string">&quot;可恶&quot;</span>, <span class="hljs-string">&quot;我去&quot;</span>);<br>Stream&lt;String&gt; stream1 = stream.skip(<span class="hljs-number">2</span>);<br>stream1.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map 方法"></a>map 方法</h3><p>对数组进行映射，把一个数组里的元素经过一定规则的映射后，返回映射后的结果，返回 Stream 流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>);<br>Stream&lt;Integer&gt; stream1 = stream.map(Integer::parseInt);<br>stream1.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>此处将字符串的数组映射为了 int 类型的数字</p><h3 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat 方法"></a>concat 方法</h3><p>将两个 Stream 流合并为一个流，返回 Stream 流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">&quot;阿巴阿巴&quot;</span>, <span class="hljs-string">&quot;外币巴布&quot;</span>, <span class="hljs-string">&quot;不拉布拉&quot;</span>);<br>Stream&lt;String&gt; stream2 = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;gdi&quot;</span>, <span class="hljs-string">&quot;btw&quot;</span>);<br>Stream&lt;String&gt; concat = Stream.concat(stream1, stream2);<br>concat.forEach(System.out::println);<br></code></pre></td></tr></table></figure><hr><p>看了看文档，Stream 流有很多方法可以使用，这里只是几个常用的方法，还有很多东西要学呢<br>Java 的 api 怎么这么难学啊 Σ(▼□▼メ)</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java函数式接口</title>
    <link href="/2022/06/10/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/06/10/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>刚接触完全不理解是个什么东西，但学了一会后有那么一点感觉这东西的好处了</p><span id="more"></span><h2 id="对函数式接口的理解"><a href="#对函数式接口的理解" class="headerlink" title="对函数式接口的理解"></a>对函数式接口的理解</h2><p>我觉得这个东西就是为了简化代码，减轻内存压力的<br>如果为了使用一个方法而重新写一个类并实例化它，就会浪费内存去存储这个类<br>这时候，如果把这个方法变成一个函数，就可以简化代码，减少程序占的内存了</p><h2 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a>Supplier 接口</h2><p>就是返回一个结果的参数<br>只有一个 get() 方法，用来获得结果<br>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> getString(()-&gt;&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;demo&quot;</span>;<br>    &#125;);<br>    System.out.println(str);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getString</span><span class="hljs-params">(Supplier&lt;String&gt; sup)</span>&#123;<br>    <span class="hljs-keyword">return</span> sup.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>看代码有点难理解，我理解的执行过程是:</p><ol><li>执行到 getString() 方法处，发现参数是一个 Supplier 接口</li><li>给 Supplier 接口传入一个 lambda 表达式，重写这个接口，并命名为 sup，进入函数中</li><li>调用 sup 的 get() 方法，返回这个结果</li><li>用 str 这个变量来接受这个返回结果</li><li>打印输出 str</li></ol><h2 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a>Consumer 接口</h2><p>接受单个输入参数并且不返回结果的操作，大概表示用一个传入的参数<br>有两个方法 accept 和 andThen<br>使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method(<span class="hljs-string">&quot;fuck me&quot;</span>,(String str)-&gt;&#123;<br>        System.out.println(<span class="hljs-string">&quot;I say: &quot;</span>+ str);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(String name, Consumer&lt;String&gt; con)</span>&#123;<br>    con.accept(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程和 Supplier 一样，都是重写了接口</p><p>andThen 方法就是可以一次可以使用多个 Consumer 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arr = &#123;<span class="hljs-string">&quot;buang,18&quot;</span>, <span class="hljs-string">&quot;kuang,20&quot;</span>, <span class="hljs-string">&quot;muang,17&quot;</span>&#125;;<br>    method(arr,<br>            (mess)-&gt;&#123;<br>                System.out.print(<span class="hljs-string">&quot;姓名: &quot;</span> + mess.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>]);<br>            &#125;,<br>            (mess)-&gt;&#123;<br>                System.out.println(<span class="hljs-string">&quot;年龄: &quot;</span> + mess.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]);<br>            &#125;<br>    );<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(String[] arr, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2)</span>&#123;<br>    <span class="hljs-keyword">for</span> (String message : arr) &#123;<br>        <span class="hljs-comment">//con1.accept(message)</span><br>        <span class="hljs-comment">//con2.accept(message) 分两次使用</span><br>        con1.andThen(con2).accept(message); <span class="hljs-comment">//一次性使用两个 Consumer</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Predicate-接口"><a href="#Predicate-接口" class="headerlink" title="Predicate 接口"></a>Predicate 接口</h2><p>对给定的参数进行判断，并返回一个 boolean 值<br>基本的方法有 test，and(并且)，or(或者)，negate(取反)<br>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span>check(str,(str1)-&gt;&#123;<br>        <span class="hljs-keyword">return</span> str1.length()&gt;<span class="hljs-number">5</span>;<br>    &#125;);<br>    System.out.println(b);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(String str, Predicate&lt;String&gt; pre)</span>&#123;<br>    <span class="hljs-keyword">return</span> pre.test(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>对一 Predicate 接口的理解</p><ol><li>执行到 check() 方法处，传入一个字符串，发现要传入一个 Predicate 的接口实现</li><li>重写 Predicate 的 test() 方法，可以使用 lambda 表达式</li><li>重写 test() 方法的判断标准是字符串长度大于5，由于 “abc” 长度小于5，返回 false</li><li>输出 false 这个结果</li></ol><p>and 方法就是要两边都满足才判断为真，需要传入多个 Predicate 接口实现<br>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abandon&quot;</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> method(s, (str)-&gt;&#123;<br>        <span class="hljs-keyword">return</span> str.length()&gt;<span class="hljs-number">5</span>;<br>    &#125;,(str)-&gt;&#123;<br>        <span class="hljs-keyword">return</span> str.contains(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">//判断字符串是否含有字符 a</span><br>    &#125;);<br>    System.out.println(b);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">method</span><span class="hljs-params">(String str, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span>&#123;<br>    <span class="hljs-comment">//return pre1.test(str) &amp;&amp; pre2.test(str);</span><br>    <span class="hljs-keyword">return</span> pre1.and(pre1).test(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>or 就是或，使用方法和 and 一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> pre1.or(pre1).test(str);<br></code></pre></td></tr></table></figure><p>negate 就是取反，非</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> pre.negate().test(str);<br></code></pre></td></tr></table></figure><h2 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a>Function 接口</h2><p>接受一个参数并产生结果的函数<br>常用方法为 apply 和 andThen<br>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method(str, (s)-&gt;&#123;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(s + <span class="hljs-number">100</span>);<br>    &#125;);<br>    System.out.println(result);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(String str, Function&lt;String, Integer&gt; fun)</span>&#123;<br>    <span class="hljs-keyword">return</span> fun.apply(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>method() 方法功能为传入一个数字字符串，经过一系列处理后，返回一个结果<br>andThen 方法的使用同 Consumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String str, Function&lt;String, Integer&gt; fun1, Function&lt;Integer, String&gt; fun2)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> fun1.andThen(fun2).apply(str);<br>    System.out.println(ss);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345678&quot;</span>;<br>    change(str, (s)-&gt;&#123;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(s) + <span class="hljs-number">10</span>;<br>    &#125;,(i)-&gt;&#123;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>change() 方法为传入一个字符串，将其转换为数字，并加10，再转换会字符串，并返回</p><h2 id="定义函数式接口"><a href="#定义函数式接口" class="headerlink" title="定义函数式接口"></a>定义函数式接口</h2><p>定义一个接口，并宣称这是一个函数式接口，就是在最前面加上 @FunctionalInterface</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PrintStr</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String s)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(PrintStr p)</span>&#123;<br>    p.print(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method((a)-&gt;&#123;<br>        System.out.println(a);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>对执行步骤的理解:</p><ol><li>执行主方法，发现 method 方法需要传入一个接口实现对象</li><li>传入一个 lambda 表达式，参数为a，这个 a 就是 print 方法的参数</li><li>lambda 表达式就是接口的实现对象，也就是 method 中定义的参数 p</li><li>p 调用接口的抽象方法 print 方法</li><li>重写了 print 方法为输出参数 a，也就是 method 中传入 print 方法的字符串</li><li>打印出字符串</li></ol><p>在执行的过程中 a&#x3D;”hello world”，传入的 lambda 表达式&#x3D;p</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(PrintStr p)</span>&#123;<br>    p.print(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method((a)-&gt;&#123;<br>        a=<span class="hljs-string">&quot;fuck me&quot;</span>; <span class="hljs-comment">//修改参数 a 的值</span><br>        System.out.println(a);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是修改了参数 a 的值，重写了传入 print 方法的参数，这样就会打印 fuck me 了</p><hr><p>感觉这个知识点会变成这样:<br>什么玩意？-&gt; 有点懂了 -&gt; 原来如此 -&gt; 一段时间后 -&gt; 什么玩意？<br>这个东西确实说难不难，理解起来也不难，但就是脑子转不过弯来，以后肯定会多次重新学习这个东西的<br>感觉这个也是一个在实际使用中很有用的玩意</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>frp内网穿透</title>
    <link href="/2022/06/09/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2022/06/09/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="内网穿透解决了困扰一个学期的问题"><a href="#内网穿透解决了困扰一个学期的问题" class="headerlink" title="内网穿透解决了困扰一个学期的问题"></a>内网穿透解决了困扰一个学期的问题</h1><p>一个学期了，都快结束了，宿舍里的软路由刷了了个 Linux 系统当下载器兼服务器<br>但校园网的质量怎么说呢。。。<br>经常断网，然后 DHCP 重新给了个 IP 地址，然后我就连不上软路由了<br>今天突然想到可以用内网穿透来解决</p><span id="more"></span><h2 id="frp-使用"><a href="#frp-使用" class="headerlink" title="frp 使用"></a>frp 使用</h2><p>在一台有公共 IP 地址的 VPS 上部署服务端，在软路由上部署客户端，客户端会主动连接到服务端的相应接口<br>建立好连接后，只需要连接上有公网 IP 地址的 VPS 的相应端口就能连接到内网的软路由了<br>就这么简单的东西，我一个学期都没有拿来用一下，唉:(</p><h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>先连接的上再说以后的事嘛<br>GitHub 上面下好最新的 release <a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a><br>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xvzf frp_0.43.0_linux_amd64.tar.gz<br></code></pre></td></tr></table></figure><p>里面有6个文件，3个 frp 后面是c,3个 frp 后面是s<br>c 的是 client 客户端，s 的是 server 服务端<br>服务端的上传到 VPS 上，客户端发在软路由上</p><p>配置服务端的 frps.inf</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[common]<br>bind_port = 7000<br></code></pre></td></tr></table></figure><p>代表客户端绑定服务端的端口</p><p>配置客户端的 frpc.ini</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">[common]<br>server_addr = vps_ip<br>server_port = 7000<br><br>[ssh]<br>type = tcp<br>local_ip = 127.0.0.1<br>local_port = 22<br>remote_port = 6000<br></code></pre></td></tr></table></figure><p>common 里填的就是服务端暴露出来的端口<br>ssh 里填写用来被连接的端口，直接用默认的6000也行</p><h3 id="启动并后台运行"><a href="#启动并后台运行" class="headerlink" title="启动并后台运行"></a>启动并后台运行</h3><p>为了后台运行，可以用 nohup 命令</p><p>服务端:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nohup ./frps -c frps.ini &gt; /dev/null 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>客户端:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nohup ./frpc -c frpc.ini &gt; /dev/null 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>命令解释: 将标准错误 2 重定向到标准输出 &amp;1，标准输出 &amp;1 再被重定向输入到 &#x2F;dev&#x2F;null 中，&amp; 表示退出命令行后继续运行</p><p>然后在别的机器上就能通过 VPS 来连接软路由了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -oPort=6000 user@vps_ip<br></code></pre></td></tr></table></figure><hr><p>后面的其他更牛逼的玩法，后面我再自己看文档去了，全是英文 …(｡•ˇ‸ˇ•｡) …<br>感觉还可以结合刚学会使用的一个项目来加速 frp 连接，这样就能在软路由上搭一个速度快，还不限速的网盘了 <em>.。(๑･∀･๑)</em>.。</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo添加RSS</title>
    <link href="/2022/06/06/Hexo%E6%B7%BB%E5%8A%A0RSS/"/>
    <url>/2022/06/06/Hexo%E6%B7%BB%E5%8A%A0RSS/</url>
    
    <content type="html"><![CDATA[<h1 id="RSS-真是太方便了"><a href="#RSS-真是太方便了" class="headerlink" title="RSS 真是太方便了"></a>RSS 真是太方便了</h1><p>突然发现 RSS 很方便，可以快速获取我关注的信息，而且不至于让互联网上那些公司收集我的喜好<br>这样我就不用再浪费大量的时间去看他们推荐给我我想看到的东西了<br>怎么没有早点发现这个东西呢</p><span id="more"></span><h2 id="Hexo-添加-RSS-功能"><a href="#Hexo-添加-RSS-功能" class="headerlink" title="Hexo 添加 RSS 功能"></a>Hexo 添加 RSS 功能</h2><p>给自己的博客添加 RSS 功能，为 RSS 的未来添一把力<br>首先安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-generator-feed --save<br></code></pre></td></tr></table></figure><p>配置博客根目录下的 _config.yml 配置文件，在里面添加配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">feed:<br>  enable: true<br>  type:<br>    - atom<br>    - rss2<br>  path:<br>    - atom.xml<br>    - rss2.xml  <br>  limit: 0<br>  hub:<br>  content: true<br>  content_limit: <br>  content_limit_delim: &#x27; &#x27;<br>  order_by: -date<br>  icon: icon.png<br>  autodiscovery: true<br>  template:<br></code></pre></td></tr></table></figure><ul><li>enable: 启用或禁用插件</li><li>type: 类型，默认 atom，但我觉得 rss2 更好一点(我全都有.jpg)</li><li>path: 路径，type 有什么就写什么</li><li>limit: 提要中的最大帖子数(0或者 false 显示所有文章)</li><li>hub: PubSubHubbub 的 URL，PubSubHubbub 协议在供稿网址内容更新后，能接近即时的得到通知，没有则留空</li><li>content: 设置为 true 时，在提要中包含整个帖子的内容</li><li>content_limit: 只有当 content 为false时，设置摘要中使用的帖子内容的默认长度</li><li>content_limit_delim: 如果设置了 content_limit，这个选项可以在达到限定字数之前设定的符号处断开，一般不开启</li><li>order_by: 排序，默认用日期</li><li>icon: 图标</li><li>autodiscovery: 自动发现</li><li>template: 自定义模板</li></ul><p>设置完成后保存并退出<br>生成文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><h2 id="使用-RSS"><a href="#使用-RSS" class="headerlink" title="使用 RSS"></a>使用 RSS</h2><p>现在我在用的 RSS 阅读器是浏览器的插件 Feedbro<br><img src="/img/2022-6-6-1.png" alt="挺好用的"></p><p>由于许多网站没有 RSS 订阅，为了更好的使用，可以用 RSSHub Radar 来生成 RSS 链接<br><img src="/img/2022-6-6-4.png"></p><h2 id="docker-搭建-RSSHub-服务器"><a href="#docker-搭建-RSSHub-服务器" class="headerlink" title="docker 搭建 RSSHub 服务器"></a>docker 搭建 RSSHub 服务器</h2><p>由于 RSSHub Radar 用的人太多了，许多网站会进行反爬操作，导致链接失效，所以可以自己搭建一个 RSSHub<br>很简单，RSSHub 官方文档上也有写 <a href="https://docs.rsshub.app/">https://docs.rsshub.app/</a></p><p>拉取镜像:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull diygod/rsshub<br></code></pre></td></tr></table></figure><p>运行镜像:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name rsshub -p 1200:1200 diygod/rsshub<br></code></pre></td></tr></table></figure><p>然后浏览器打开 <a href="http://127.0.0.1:1200/">http://127.0.0.1:1200</a><br>就能看见搭建成功<br><img src="/img/2022-6-6-2.png"><br>也可以在服务器上搭建，我这个就是在一台阿里云的服务器上搭建的，不过还是建议用国外的，因为用国内的服务器话，国外的 RSS 是推送不到的<br>然后在 RSSHub 中设置服务器的地址<br><img src="/img/2022-6-6-3.png" alt="完成"><br>这样就能用自己的服务器来获取 RSS 信息了</p><hr><p>刚发现 RSS 这一学习神器，真的太有用了，不用为了看点咨询去贴吧和知乎，然后被其他内容吸引走了<br>有了 RSS ，互联网公司就得到我的喜好更少一点，我的学习效率也将提升一点 （&#x3D;￣ω￣&#x3D;）</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java序列化与反序列化</title>
    <link href="/2022/06/04/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/06/04/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="不算难理解"><a href="#不算难理解" class="headerlink" title="不算难理解"></a>不算难理解</h1><p>序列化和反序列化这两个名词很早就从 Java 的反序列化漏洞里听过了<br>但当时由于实力不足，不知道是什么意思，也就很懵逼的过去了<br>今天学了序列化和反序列化，理解起来不算难吧</p><span id="more"></span><h2 id="ObjectOutputStream-序列化"><a href="#ObjectOutputStream-序列化" class="headerlink" title="ObjectOutputStream 序列化"></a>ObjectOutputStream 序列化</h2><p>把 Java 中实例化的对象转换为字节数据，这样就能把它存储起来，这样以后要用的时候就不用在 new 一个对象了<br>也可以把这个序列化后的数据通过网络发送到其他电脑上，这样别的电脑就可以使用这个类了</p><p>使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;person.txt&quot;</span>); <span class="hljs-comment">//创建一个输出流对象</span><br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fos); <span class="hljs-comment">//创建一个序列化对象，并传入输出流对象，实例化后的文件就存在输出流指定的文件中</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">ren</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;mua&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">//实例化一个 Person 对象</span><br>oos.writeObject(ren); <span class="hljs-comment">//序列化对象</span><br>fos.close();<br>oos.close();<br></code></pre></td></tr></table></figure><p>然后就会发现多了一个 person.txt 的文件，但由于编码问题，看到的是乱码</p><h2 id="ObjectInputStream-反序列化"><a href="#ObjectInputStream-反序列化" class="headerlink" title="ObjectInputStream 反序列化"></a>ObjectInputStream 反序列化</h2><p>对象实例化后产生的文件可以通过反序列化变回一个对象<br>变回的对象都是 Object 类的对象，需要转换一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;person.txt&quot;</span>)); <span class="hljs-comment">//创建读取对象</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> ois.readObject(); <span class="hljs-comment">//读取对象</span><br>ois.close();<br><span class="hljs-type">Person</span> <span class="hljs-variable">ren</span> <span class="hljs-operator">=</span> (Person) o; <span class="hljs-comment">//类型转换</span><br>System.out.println(ren);<br></code></pre></td></tr></table></figure><h2 id="存储和读取多个对象"><a href="#存储和读取多个对象" class="headerlink" title="存储和读取多个对象"></a>存储和读取多个对象</h2><p>可以用 ArrayList 来创建一个对象的数组，然后存储起来，反序列化的时候用 ArrayList 接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Person&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//创建一个 Person 类对象数组</span><br>arr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Wife&quot;</span>, <span class="hljs-number">16</span>)); <span class="hljs-comment">//添加元素</span><br>arr.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Sister&quot;</span>, <span class="hljs-number">14</span>));<br><br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)); <span class="hljs-comment">//创建序列化对象</span><br>oos.writeObject(arr); <span class="hljs-comment">//序列化整个数组</span><br>oos.close(); <span class="hljs-comment">//释放资源</span><br></code></pre></td></tr></table></figure><p>反序列化多个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)); <span class="hljs-comment">//创建读取对象</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> ois.readObject(); <span class="hljs-comment">//读取数组，返回的是 Object 类</span><br>ArrayList&lt;Person&gt; per = (ArrayList&lt;Person&gt;) o; <span class="hljs-comment">//类型转换</span><br><span class="hljs-keyword">for</span> (Person person : per) &#123;<br>    System.out.println(person); <span class="hljs-comment">//输出对象</span><br>&#125;<br>ois.close(); <span class="hljs-comment">//释放资源</span><br></code></pre></td></tr></table></figure><h2 id="序列化类的定义"><a href="#序列化类的定义" class="headerlink" title="序列化类的定义"></a>序列化类的定义</h2><p>如果一个类所创建的对象要实现序列化，就要继承 Serializable 接口，这个接口里面什么方法都没有，之所以继承只是为了标记这个类是可序列化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">//序列号id,这样就可以固定这个类序列化后的id</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个类如果可以被序列化，那么就可以根据这个类的定义算出它的序列id，类似于进行了一次hash运算<br>如果对类进行了修改，这个id就会不一样，反序列化的时候需要用到这个id，如果id不一样就会反序列化失败<br>此时如果在定义类的时候固定这个id，就不会有这种困难了<br>serialVersionUID 必须加上static final 这两个修饰符</p><p>transient和static修饰符很像，它们定义的参数都不能参加序列化<br>transient只是不参加序列化，它没有static的可以不实例化类就调用的特性</p><hr><p>马上就可以开始学习网络编程了，虽然之前学过 Python 的网络编程，但两个语言的差别还是挺大的，还是要好好学<br>马上要放暑假了，回家可以边学 Java，边学学 Linux 开发 (⸝⸝•‧̫•⸝⸝)</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java文件操作</title>
    <link href="/2022/06/02/Java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/06/02/Java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="刚学完文件操作"><a href="#刚学完文件操作" class="headerlink" title="刚学完文件操作"></a>刚学完文件操作</h1><p>今天刚学了文件操作，比 Python 困难了许多，因为用到的方法和类比较多，比较杂<br>但方法多了，可以做的事情就更多了，能进行的操作也就更多、更灵活了</p><span id="more"></span><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>File 类就是用来创建一个文件对象，它的构造方法里面传入的不管这个文件夹或者文件是否存在，都可以被创建，没问题<br>File 类有三个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/home/nero&quot;</span>); <span class="hljs-comment">//创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/home&quot;</span>, <span class="hljs-string">&quot;demo.txt&quot;</span>); <span class="hljs-comment">//一个父路径，一个子路径，把路径分成了两个部分</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(f1, <span class="hljs-string">&quot;java.txt&quot;</span>); <span class="hljs-comment">//父路径是File类的对象，子路径是字符串</span><br></code></pre></td></tr></table></figure><p>常用的一些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">absolute</span> <span class="hljs-operator">=</span> f.getAbsolutePath(); <span class="hljs-comment">//不管传入的是相对路径还是决定路径，都返回绝对路径</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> f.getPath(); <span class="hljs-comment">//获取路径名称字符串</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> f.getName(); <span class="hljs-comment">//获取文件名称字符串</span><br><br>f.exists(); <span class="hljs-comment">//判断文件是否存在</span><br><br>f.isFile(); <span class="hljs-comment">//判断路径是否以文件结尾</span><br><br>f.isDirectory(); <span class="hljs-comment">//判断路径是否以文件夹结尾</span><br><span class="hljs-comment">//文件不存在时，isFile和isDirectory都返回false</span><br></code></pre></td></tr></table></figure><h3 id="创建与删除"><a href="#创建与删除" class="headerlink" title="创建与删除"></a>创建与删除</h3><p>可以通过 File 实例化的对象来创建文件或者文件夹</p><ul><li>创建文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;demo.txt&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> f.createNewFile();<br></code></pre></td></tr></table></figure><ul><li>创建文件夹</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Dir&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> f1.mkdir(); <span class="hljs-comment">//创建单级文件夹</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Dir1/Dir2/Dir3&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> f2.mkdirs(); <span class="hljs-comment">//创建多级文件夹</span><br></code></pre></td></tr></table></figure><ul><li>删除文件或文件夹</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Dir&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> f1.delete(); <span class="hljs-comment">//既能删除文件，也能删除文件夹</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;demo.txt&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> f2.delete();<br><span class="hljs-type">File</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Dir1/Dir2/Dir3&quot;</span>); <span class="hljs-comment">//删除多级文件夹要写全</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> f3.delete();<br></code></pre></td></tr></table></figure><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>以字节的方式读取&#x2F;写入文件，就是把01代码一连串的处理一遍<br>此处的 input 和 output 是相对于内存的<br>input 就是从硬盘读取数据到内存<br>output 就是从内存写入数据到硬盘</p><h3 id="FileInputStream-类"><a href="#FileInputStream-类" class="headerlink" title="FileInputStream 类"></a>FileInputStream 类</h3><p>创建一个以字节流的方式读取的文件对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Test.txt&quot;</span>); <span class="hljs-comment">//创建一个读取文件的对象</span><br>System.out.println(fis.read()); <span class="hljs-comment">//读取一个字节</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((len = fis.read()) != -<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//循环遍历所有字节</span><br>    System.out.println((<span class="hljs-type">char</span>) len);<br>&#125;<br>fis.close();<br></code></pre></td></tr></table></figure><p>read() 方法会反回一个字节，如果读取到了文件末尾，则反回 -1</p><h4 id="利用-byte-数组来加快读取速度"><a href="#利用-byte-数组来加快读取速度" class="headerlink" title="利用 byte 数组来加快读取速度"></a>利用 byte 数组来加快读取速度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;Test.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">//用来存储读取出来的字节</span><br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> fis.read(br); <span class="hljs-comment">//len表示有效读取字节个数</span><br><span class="hljs-keyword">while</span> ((len = fis.read(bytes)) != -<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//循环遍历所有字节</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-number">0</span>, len)); <span class="hljs-comment">//输出有效的字节数，这样输出的时候后面就不会有多余的空格了</span><br>&#125;<br>br.close();<br></code></pre></td></tr></table></figure><h3 id="FileOutputStream-类"><a href="#FileOutputStream-类" class="headerlink" title="FileOutputStream 类"></a>FileOutputStream 类</h3><p>创建一个以字节流的方式写入的文件对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;Test.txt&quot;</span>); <span class="hljs-comment">//构造方法传入写入数据的目的地</span><br>fos.write(<span class="hljs-number">97</span>); <span class="hljs-comment">//写入字节，一次只能传入一个字节</span><br>fox.close();<br></code></pre></td></tr></table></figure><p>以上方式一次只能传入一个字节，很麻烦，可以传入一个字节数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;justTest.txt&quot;</span>);<br><span class="hljs-type">byte</span>[] arr = &#123;<span class="hljs-number">97</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span>, <span class="hljs-number">68</span>, <span class="hljs-number">72</span>, <span class="hljs-number">100</span>&#125;;<br>fos.write(arr); <span class="hljs-comment">//写入一串字节</span><br><br><span class="hljs-type">byte</span>[] arr2 = <span class="hljs-string">&quot;你好世界&quot;</span>.getBytes(); <span class="hljs-comment">//getBytes()方法反回一个字节数组</span><br>fos.write(arr2);<br></code></pre></td></tr></table></figure><p>FileOutputStream 类可以传入第二个参数true&#x2F;false，表示是否追加写</p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字节流是一次处理一个字节，字符流就是一次处理一个字符，由于中文占两到三个字节，所以用字节流处理中文会乱码</p><h3 id="FileReader-类"><a href="#FileReader-类" class="headerlink" title="FileReader 类"></a>FileReader 类</h3><p>以字符流读取字符<br>用法和字节流差不多，只不过反回的是字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;Test.txt&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((len = fr.read()) != -<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//和字节流的 read() 方法一样，一次读取一个字符，读取完毕返回 -1</span><br>    System.out.println((<span class="hljs-type">char</span>)len);<br>&#125;<br>fr.close();<br></code></pre></td></tr></table></figure><p>一次读取多个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;Test.txt&quot;</span>);<br><span class="hljs-type">char</span>[] ch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((len = fr.read(ch)) != -<span class="hljs-number">1</span>)&#123;<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(ch, <span class="hljs-number">0</span>, len)); <span class="hljs-comment">//输出有效的字符数，这样输出的时候后面就不会有多余的空格了</span><br>&#125;<br>fr.close();<br></code></pre></td></tr></table></figure><h3 id="FileWriter-类"><a href="#FileWriter-类" class="headerlink" title="FileWriter 类"></a>FileWriter 类</h3><p>以字符流写入字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;Test.txt&quot;</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">//true 表示使用追加写</span><br>fw.write(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>fw.flush(); <span class="hljs-comment">//写入数据到硬盘中</span><br>fw.close();<br></code></pre></td></tr></table></figure><h2 id="Properties-集合"><a href="#Properties-集合" class="headerlink" title="Properties 集合"></a>Properties 集合</h2><p>Properties 集合是一种特殊的集合，它可以把数据以键值对的方式存储，并且可以写入到特定的文件，方便以后读取使用</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>(); <span class="hljs-comment">//创建Properties 集合对象</span><br>prop.setProperty(<span class="hljs-string">&quot;ShaMiKo&quot;</span>, <span class="hljs-string">&quot;150&quot;</span>);<br>prop.setProperty(<span class="hljs-string">&quot;MoMo&quot;</span>, <span class="hljs-string">&quot;140&quot;</span>);<br><span class="hljs-keyword">try</span> (<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;prop.txt&quot;</span>))&#123; <span class="hljs-comment">//处理异常，使用 try...catch 可以自动关闭流</span><br>    prop.store(fw, <span class="hljs-string">&quot;save data&quot;</span>); <span class="hljs-comment">//store() 方法写入到fw创建的对象对应的文件中，第二个参数是注释</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>Properties 集合的load方法可以读取文件（键值对）到集合中<br>void Load (InputStream inputStream) 字节输入，不能读中文<br>void Load (Reader reader) 字符输入，可以读中文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;prop.txt&quot;</span>);)&#123;<br>    prop.load(fr);<br>    Set&lt;String&gt; arr = prop.stringPropertyNames();<br>    <span class="hljs-keyword">for</span> (String s : arr) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> prop.getProperty(s);<br>        System.out.println(s + <span class="hljs-string">&quot;=&quot;</span> + value);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>创建一个缓冲区，这样可以提高文件的读取&#x2F;存储效率<br>有四个缓冲区类</p><ul><li>BufferedOutputStream() –&gt; 字节缓冲输出流</li><li>BufferedInputStream() –&gt; 字节缓冲输入流</li><li>BufferedWriter() –&gt; 字符缓冲输出流</li><li>BufferedReader() –&gt; 字符缓冲输入流</li></ul><p>用法都差不多<br>BufferedOutputStream() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fos, <span class="hljs-number">1024</span>); <span class="hljs-comment">//第二个参数设置缓冲区大小，不写就用默认的大小</span><br>bos.flush(); <span class="hljs-comment">//写入硬盘</span><br>bos.close();<br></code></pre></td></tr></table></figure><p>FileInputStream() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fis, <span class="hljs-number">1024</span>); <span class="hljs-comment">//第二个参数设置缓冲区大小，不写就用默认的大小</span><br>fis.close();<br></code></pre></td></tr></table></figure><p>BufferedWriter() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fw, <span class="hljs-number">1024</span>); <span class="hljs-comment">//第二个参数设置缓冲区大小，不写就用默认的大小</span><br>bw.flush(); <span class="hljs-comment">//写入硬盘</span><br>bw.close();<br></code></pre></td></tr></table></figure><p>BufferedReader() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr, <span class="hljs-number">1024</span>); <span class="hljs-comment">//第二个参数设置缓冲区大小，不写就用默认的大小</span><br>br.close();<br></code></pre></td></tr></table></figure><h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>输出流可以很方便的把各种数据输入到文件中</p><ul><li>PrintStream: 输出的是字节</li><li>PrintWriter: 输出的是字符</li><li>两者用法几乎一样</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;print.txt&quot;</span>); <span class="hljs-comment">//创建打印流，绑定目标文件</span><br>ps.write(<span class="hljs-number">97</span>); <span class="hljs-comment">//使用继承自父类的write方法，那么写入的时候会查询编码表</span><br>ps.println(<span class="hljs-number">97</span>); <span class="hljs-comment">//使用自己特有的print/println方法，会原样输出</span><br>ps.println(<span class="hljs-string">&quot;阿巴阿巴&quot;</span>);<br>ps.println(<span class="hljs-string">&#x27;c&#x27;</span>);<br>ps.println(<span class="hljs-number">3.14</span>);<br>ps.close();<br></code></pre></td></tr></table></figure><p>print.txt 文件内容如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">a97<br>阿巴阿巴<br>c<br>3.14<br></code></pre></td></tr></table></figure><p>输出流就是把输出到命令行的数据，输出到文件中<br>可以用 System 下的 setOut() 方法把输出到命令行的文字重定向到文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;控制台输出&quot;</span>);<br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-string">&quot;目的地是打印流.txt&quot;</span>);<br>System.setOut(ps);<br>System.out.println(<span class="hljs-string">&quot;我在打印流中输出&quot;</span>);<br>ps.close();<br></code></pre></td></tr></table></figure><hr><p>有一段时间没有学习 Java 了，跑去学别的东西了，现在又有时间回来继续学习 Java 了  ♪（＾∀＾●）ﾉｼ<br>文件操作应该蛮重要的，但看上去并不是很难理解，可能是以前学过类似的东西吧 (●´∀｀●)</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fcitx5安装</title>
    <link href="/2022/05/31/Fcitx5%E5%AE%89%E8%A3%85/"/>
    <url>/2022/05/31/Fcitx5%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="换了好几个输入法"><a href="#换了好几个输入法" class="headerlink" title="换了好几个输入法"></a>换了好几个输入法</h1><p>自从把电脑的系统换成 manjaro 之后，输入法就是一个很有必要考虑的事情了<br>毕竟是中国人，电脑里怎么的都得输入一些中文，处理个文档，搜个问题之类的<br>刚开始电脑用的是 Fcitx 加了一个皮肤，就这么用了几个月，直到电脑蹦了的那一天<br>重装了系统后，又要安装输入法，然后就用了 Fcitx-sougoupinyin ，用了一周，感觉还不错<br>但后来发现 Fcitx 已经不维护了，用不维护的软件当然不舒服，所以就转了现在的 Fcitx5<br>过不了多久，我想把我的电脑系统换成 ArchLinux ，想玩玩 ArchLinux 了 ╭(′▽`)╭(′▽&#96;)╯<br>到时候可以跟着这篇博客来安装输入法了</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ArchLinux 的库里是有 Fcitx5 的，可以直接安装，但 Fcitx5 只是一个输入法框架，只能输入英文，想要输入中文还需要输入法引擎<br>所以可以直接安装输入法引擎，这样可以一步到位啦<br>顺便在这里安装输入法模块 fcitx5-qt 和 fcitx5-gtk<br>以及配置工具 fcitx5-configtool ，用起来更方便</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S fcitx5-chinese-addons<br>sudo pacman -S fcitx5-qt fcitx5-gtk<br>sudo pacman -S fcitx5-configtool <br></code></pre></td></tr></table></figure><p>这个输入法引擎比较好用，支持多种中文输入方式，用起来比较方便</p><h2 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h2><p>在 &#x2F;etc&#x2F;environment 文件中加入以下变量</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">GTK_IM_MODULE=fcitx<br>QT_IM_MODULE=fcitx<br>XMODIFIERS=@im=fcitx<br>INPUT_METHOD=fcitx<br>SDL_IM_MODULE=fcitx<br>GLFW_IM_MODULE=fcitx<br></code></pre></td></tr></table></figure><h2 id="添加输入法"><a href="#添加输入法" class="headerlink" title="添加输入法"></a>添加输入法</h2><p>打开 System Settings -&gt; Regional Settings -&gt; Input Method ，添加一个输入法，在这里我添加了一个 pinyin 的输入法<br><img src="/img/2022-5-31-1.png" alt="添加输入法"><br><img src="/img/2022-5-31-2.png" alt="加入一个pinyin输入法，也可以添加别的输入法"><br><img src="/img/2022-5-31-3.png" alt="添加成功后保存"></p><h2 id="安装词库"><a href="#安装词库" class="headerlink" title="安装词库"></a>安装词库</h2><p>目前就只安装了两个词库 fcitx5-pinyin-zhwiki 和 moegirl<br>fcitx5-pinyin-zhwiki 可以在库里直接下载，这也是一种安装词库的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S fcitx5-pinyin-zhwiki<br></code></pre></td></tr></table></figure><p>moegirl 词库是在 GitHub 上面下好 .dict 文件放到 ~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;pinyin&#x2F;dictionaries 文件夹中<br>项目地址 <a href="https://github.com/outloudvi/mw2fcitx">https://github.com/outloudvi/mw2fcitx</a></p><h2 id="皮肤安装"><a href="#皮肤安装" class="headerlink" title="皮肤安装"></a>皮肤安装</h2><p>话说原版皮肤真的不敢恭维，确实不好看，所以我自己安装了皮肤，一个 nord ，一个四季主题<br>nord 可以在库里直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S fcitx5-nord<br></code></pre></td></tr></table></figure><p>打开 Fcitx5 设置工具，设置皮肤<br><img src="/img/2022-5-31-4.png"><br>在经典 UI 设置中选择主题就可以了<br><img src="/img/2022-5-31-5.png"></p><p>另外一个四季主题是在 GiHhub 上下载的<br>项目地址 <a href="https://github.com/thep0y/fcitx5-themes">https://github.com/thep0y/fcitx5-themes</a><br>选择一个喜欢的主题，放到 ~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;themes 文件夹中<br>最后到设置工具里面设置为这个主题，我正在用的这个主题是我觉得最好看的一个<br><img src="/img/2022-5-31-6.png" alt="简约，但很好看"></p><hr><p>主要是快期末了，怕可能用到电脑，所以对自己的电脑不敢轻举妄动，现在刷系统太危险了<br>所以先继续用着 manjaro 这个系统，放假了就可以继续调♀戏电脑了 &lt;(￣︶￣)&gt;</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fcitx5</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>预防暴露真实IP地址</title>
    <link href="/2022/05/30/%E9%A2%84%E9%98%B2%E6%9A%B4%E9%9C%B2%E7%9C%9F%E5%AE%9EIP%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/05/30/%E9%A2%84%E9%98%B2%E6%9A%B4%E9%9C%B2%E7%9C%9F%E5%AE%9EIP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="发现的-IP-可能暴露"><a href="#发现的-IP-可能暴露" class="headerlink" title="发现的 IP 可能暴露"></a>发现的 IP 可能暴露</h1><p>在 <a href="https://browserleaks.com/ip">https://browserleaks.com/ip</a> 上进行了一下测试，发现我的真实 IP 地址暴露了，别人可以通过两个漏洞来获取我的真实 IP 地址，然后来一个线下网友交流<br>这两个漏洞分别是 WebRTC 泄露和 DNS 泄露</p><span id="more"></span><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>WebRTC 是一个支持网页浏览器进行实时语音对话或视频对话的API，很早就得到了广泛的应用<br>但后来爆出了一个漏洞，就是 WebRTC 泄露，通过这个漏洞，使用 JavaScript 就能获取真实的 IP 地址<br>我觉得蛮恐怖的，因为在互联网就是需要安全的来访问嘛</p><p>DNS 泄露的问题最核心的问题就是 DNS 配置不当，导致 DNS 查询的报文可能在网上到处传播，这就有可能暴露查询的内容<br>如果使用了不安全的 DNS 服务器，那么你的所以上网行为在别人面前就是裸奔</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>WebRTC 泄露是发生在浏览器上的，只要关闭 WebRTC 这一功能，需要的时候再打开就可以了<br>在 Firefox 的地址栏输入 about:config<br>进入设置界面，搜索 media.peerconnection.enabled，把这一项改成 false 就可以了<br><img src="/img/2022-5-30-1.png"></p><p>DNS 泄露就设置好 DNS，国内就用腾讯云的 119.29.29.29，或者阿里云的 223.5.5.5<br>国外就用 Cloudflare 的 1.1.1.1，或者 Google 的 8.8.8.8<br>实在不行自己用 AdGuard 搭建一个私有 DNS 也不是不可以</p><hr><p>互联网真是太可怕了，一不小心就暴露了自己，本来上网就是想要有一个谁都不知道自己的世界，然而事实却不尽如人意<br>好好保护自己的隐私吧，别让自己在互联网上裸奔 ꒦ິ^꒦ິ</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IP</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manjaro不断推送需要登录</title>
    <link href="/2022/05/28/manjaro%E4%B8%8D%E6%96%AD%E6%8E%A8%E9%80%81%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95/"/>
    <url>/2022/05/28/manjaro%E4%B8%8D%E6%96%AD%E6%8E%A8%E9%80%81%E9%9C%80%E8%A6%81%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="manjaro-连接网络就要求登录"><a href="#manjaro-连接网络就要求登录" class="headerlink" title="manjaro 连接网络就要求登录"></a>manjaro 连接网络就要求登录</h1><p>最近两天打开电脑，连上网络，不论是有线还是无线，都会提醒要求登录</p><span id="more"></span><p><img src="/img/2022-5-28-2.png"><br><img src="/img/2022-5-28-1.png"><br>点击登录会打开一个网站<br><a href="http://networkcheck.kde.org/">http://networkcheck.kde.org/</a><br>应该是一个网络检查的网站，然后就给了我一个 OK 的反馈<br><img src="/img/2022-5-28-3.png" alt="整个网页就是一个OK"><br>然后就啥都没有发生</p><p><strong>但问题是本来就能上网，但它就是会提示要登录</strong><br>我啥都不做也没问题</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>在 manjaro 的论坛里找到了解决方法，在其中有人给了解决方案，这个解决方案在 ArchLinux 的 wiki 上也有解释<br><a href="https://wiki.archlinux.org/title/NetworkManager#Checking_connectivity">https://wiki.archlinux.org/title/NetworkManager#Checking_connectivity</a></p><p>NetworkManager 会在连接后会尝试访问网络服务器，以确定它没有后门之类的东西</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>禁用连接检查就可以了<br>打开 &#x2F;etc&#x2F;NetworkManager&#x2F;conf.d 中的 20-connectivity.conf 文件，没有就创建一个<br>输入以下配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[connectivity] <br>enabled=false<br></code></pre></td></tr></table></figure><p>保存，重启，问题解决</p><hr><p>不是什么大问题，网上一找就能找到解决方法，果然把 Linux 当主系统会碰到各种各样的问题，这就需要好好调♀教自己的 Linux 了</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VLAN华为设备配置</title>
    <link href="/2022/05/25/VLAN%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/05/25/VLAN%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="VLAN-学习记录"><a href="#VLAN-学习记录" class="headerlink" title="VLAN 学习记录"></a>VLAN 学习记录</h1><p>今天上课上了华为的交换机和路由器的配置，复习了一下 VLAN 和单臂路由，然后发现有蛮多忘记了<br>最后实验是成功了，但可能也就今天学会了吧，说不定明天就忘了<br>所以记录一下整个流程吧</p><span id="more"></span><h2 id="搭建拓扑"><a href="#搭建拓扑" class="headerlink" title="搭建拓扑"></a>搭建拓扑</h2><p><img src="/img/2022-5-25-1.png"><br>如图把拓扑搭建好，先把一些简单的配置给写好，这里 PC 的IP是利用 DHCP 来自动获取的</p><h2 id="配置左半边单臂路由"><a href="#配置左半边单臂路由" class="headerlink" title="配置左半边单臂路由"></a>配置左半边单臂路由</h2><h3 id="每台交换机配置stp，两个最上面的交换机配置为根桥"><a href="#每台交换机配置stp，两个最上面的交换机配置为根桥" class="headerlink" title="每台交换机配置stp，两个最上面的交换机配置为根桥"></a>每台交换机配置stp，两个最上面的交换机配置为根桥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">stp enable<br>stp mode stp<br><br>stp root primary <br></code></pre></td></tr></table></figure><ul><li>stp root primary: 设置根桥</li></ul><h3 id="LSW3-和-LSW4-连接-PC-的接口配置-valn"><a href="#LSW3-和-LSW4-连接-PC-的接口配置-valn" class="headerlink" title="LSW3 和 LSW4 连接 PC 的接口配置 valn"></a>LSW3 和 LSW4 连接 PC 的接口配置 valn</h3><p>下面是LSW3的配置，LSW4差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vlan batch 10<br>interface Ethernet 0/0/3<br>port link-type access <br>port default vlan 10<br></code></pre></td></tr></table></figure><h3 id="配置下面两个交换机连接的上面交换机的接口"><a href="#配置下面两个交换机连接的上面交换机的接口" class="headerlink" title="配置下面两个交换机连接的上面交换机的接口"></a>配置下面两个交换机连接的上面交换机的接口</h3><p>下面是LSW3的配置，LSW4差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">interface Ethernet 0/0/1<br>port link-type trunk <br>port trunk allow-pass vlan 10<br></code></pre></td></tr></table></figure><ul><li>之所以用 trunk 这个接口类型，是因为划分了 vlan ，用 access 接口会把标签去除再发送，trunk 会保留标签再发送，这样才能达到划分vlan的效果</li></ul><h3 id="配置上面的交换机"><a href="#配置上面的交换机" class="headerlink" title="配置上面的交换机"></a>配置上面的交换机</h3><p>连接下面交换机的两个接口配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vlan batch 10 20<br>int Ethernet 0/0/2<br>port link-type trunk<br>port trunk allow-pass vlan 10<br></code></pre></td></tr></table></figure><p>连接上面路由器的接口配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">int Ethernet 0/0/1<br>port link-type trunk <br>port trunk allow-pass vlan 10 20<br></code></pre></td></tr></table></figure><h3 id="配置上面的路由器"><a href="#配置上面的路由器" class="headerlink" title="配置上面的路由器"></a>配置上面的路由器</h3><p>先配置 DHCP，由于是两个vlan，所以要做两个department</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">dhcp enable<br>ip pool department1<br>network 192.168.10.0 mask 24<br>gateway-list 192.168.10.1<br></code></pre></td></tr></table></figure><ul><li>ip pool department1: 创建department1地址池</li></ul><p>配置子接口，一个vlan对应一个子接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">interface GigabitEthernet 0/0/1.10<br>ip address 192.168.10.1 255.255.255.0 <br>dot1q termination vid 10<br>arp broadcast enable<br>dhcp select global<br></code></pre></td></tr></table></figure><ul><li>dot1q termination vid 10: 配置此子接口服务于vlan10</li><li>arp broadcast enable: 启动arp广播</li></ul><p>这样左边的两台 PC 开启自动获取 IP，然后就能互相 ping 通了<br><img src="/img/2022-5-25-2.png" alt="PC1获取了IP地址"><br><img src="/img/2022-5-25-3.png" alt="PC2获取了IP地址"><br><img src="/img/2022-5-25-4.png" alt="PC1成功ping通了PC2"></p><h2 id="配置右半边三层交换机实现不同vlan通信"><a href="#配置右半边三层交换机实现不同vlan通信" class="headerlink" title="配置右半边三层交换机实现不同vlan通信"></a>配置右半边三层交换机实现不同vlan通信</h2><h3 id="每台交换机配置stp，两个最上面的交换机配置为根桥-1"><a href="#每台交换机配置stp，两个最上面的交换机配置为根桥-1" class="headerlink" title="每台交换机配置stp，两个最上面的交换机配置为根桥"></a>每台交换机配置stp，两个最上面的交换机配置为根桥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">stp enable<br>stp mode stp<br><br>stp root primary <br></code></pre></td></tr></table></figure><ul><li>stp root primary: 设置根桥</li></ul><h3 id="LSW5-和-LSW6-连接-PC-的接口配置-valn"><a href="#LSW5-和-LSW6-连接-PC-的接口配置-valn" class="headerlink" title="LSW5 和 LSW6 连接 PC 的接口配置 valn"></a>LSW5 和 LSW6 连接 PC 的接口配置 valn</h3><p>下面是LSW5的配置，LSW6差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vlan batch 30<br>interface Ethernet 0/0/3<br>port link-type access <br>port default vlan 30<br></code></pre></td></tr></table></figure><h3 id="配置下面两个交换机连接的上面交换机的接口-1"><a href="#配置下面两个交换机连接的上面交换机的接口-1" class="headerlink" title="配置下面两个交换机连接的上面交换机的接口"></a>配置下面两个交换机连接的上面交换机的接口</h3><p>下面是LSW5的配置，LSW6差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">interface Ethernet 0/0/1<br>port link-type trunk <br>port trunk allow-pass vlan 30<br></code></pre></td></tr></table></figure><h3 id="配置上面的交换机-1"><a href="#配置上面的交换机-1" class="headerlink" title="配置上面的交换机"></a>配置上面的交换机</h3><p>连接下面交换机的两个接口配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vlan batch 30 40<br>interface GigabitEthernet 0/0/2<br>port link-type trunk<br>port trunk allow-pass vlan 30<br></code></pre></td></tr></table></figure><p>配置Vlanif</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">dhcp enable<br>ip pool department1<br>network 192.168.30.0 mask 24<br>gateway-list 192.168.30.1<br>ip pool department2<br>network 192.168.40.0 mask 24<br>gateway-list 192.168.40.1<br>interface Vlanif 30<br>ip add 192.168.30.1 24<br>dhcp select global<br>interface Vlanif 40<br>ip add 192.168.40.1 24<br>dhcp select global<br></code></pre></td></tr></table></figure><ul><li>在这个交换机上生成了 IP 池，并且开启了 DHCP 服务</li></ul><p>为了能和路由器交流，需要再创建一个vlan并配置Vlanif</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vlan batch 100<br>interface Vlanif 100<br>ip address 192.168.24.2 24<br></code></pre></td></tr></table></figure><p>配置交换机与路由器连接的接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">interface GigabitEthernet 0/0/1<br>port link-type access <br>port default vlan 100<br></code></pre></td></tr></table></figure><h3 id="配置上面的路由器-1"><a href="#配置上面的路由器-1" class="headerlink" title="配置上面的路由器"></a>配置上面的路由器</h3><p>设置连接交换机的接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">interface GigabitEthernet 0/0/1<br>ip address 192.168.24.1 24<br></code></pre></td></tr></table></figure><p>这样下面两台PC就能获取IP了<br><img src="/img/2022-5-25-5.png"><br><img src="/img/2022-5-25-6.png"><br><img src="/img/2022-5-25-7.png"></p><h2 id="利用-OSPF-让所有主机都能通讯"><a href="#利用-OSPF-让所有主机都能通讯" class="headerlink" title="利用 OSPF 让所有主机都能通讯"></a>利用 OSPF 让所有主机都能通讯</h2><p>在两台路由器和一台三层交换机上开启 OSPF</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ospf 1<br>area 0<br>network 192.168.10.0 0.0.0.255<br>...<br></code></pre></td></tr></table></figure><hr><p>有点生疏了，好多都是靠搜索引擎才做出来的，这些东西说不定就是以后吃饭的东西呢，不能把饭碗丢了啊 ,,Ծ‸Ծ,,</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VLAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java lambda表达式</title>
    <link href="/2022/05/23/Java-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/05/23/Java-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一个用来减少代码量的函数"><a href="#一个用来减少代码量的函数" class="headerlink" title="一个用来减少代码量的函数"></a>一个用来减少代码量的函数</h1><p>使用 lambda 表达式可以使代码更简洁，逻辑更紧凑，但学起来属实头秃</p><span id="more"></span><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表) -&gt; &#123;一些重写方法的代码&#125;;<br></code></pre></td></tr></table></figure><ul><li>(): 接口找那个抽象方法的参数列表，没有参数就空着，有参数就写出参数，多个参数使用逗号分隔</li><li>-&gt;: 传递的意思，把参数传递给方法体{}</li><li>{}: 重写接口的抽象方法的方法体</li></ul><p>看上去很简单，但要理解就需要点时间了</p><h2 id="没有返回值"><a href="#没有返回值" class="headerlink" title="没有返回值"></a>没有返回值</h2><p>创建线程的时候，可以用如下代码来创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;新线程创建了&quot;</span>);<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><p>在创建的时候，需要传入的参数只有一个，那就是 Runnable 接口的一个实现类，这里用了多态<br>而且只需要重写里面的 run 方法，所以，这种情况下，不看参数也知道它需要什么参数，不看重写谁，也知道它重写的是谁<br>于是，这些代码就可以省略了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;新线程创建了&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure><h2 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h2><p>定义一个 calc 接口类，里面只有一个计算的抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">calc</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>; <span class="hljs-comment">//sum方法，返回一个整数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在主函数里面定义一个使用这个接口的方法，里面只使用了 calc 这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeCalc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, calc c)</span>&#123; <span class="hljs-comment">//需要传入两个参数和一个 calc 接口的子类对象</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> c.sum(a,b); <span class="hljs-comment">//此方法调用了 calc 接口的sum方法</span><br>    System.out.println(ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 main 方法中调用 invokeCalc 方法，需要重写 calc 接口的 sum 方法，才能正确调用 invokeCalc 方法<br>正常的写法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">invokeCalc(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">calc</span>() &#123; <span class="hljs-comment">//实例化一个 calc 的子类对象，这里用了多态</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">//返回值</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>重写了 sum 方法后，再执行 invokeCalc 方法的输出语句，把答案输出</p><p>此处使用 lambda 表达式可以如下简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">invokeCalc(<span class="hljs-number">20</span>, <span class="hljs-number">20</span> , (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;a + b);<br></code></pre></td></tr></table></figure><p>前两个是参数，后面的是重写 calc 的 sum 方法<br>(int a, int b)表示 sum 方法的参数<br>-&gt; 表示传递这两个参数到 sum 方法<br>a + b 就是返回的值，也即是重写 sum 方法后的返回值</p><h2 id="更丧心病狂的省略"><a href="#更丧心病狂的省略" class="headerlink" title="更丧心病狂的省略"></a>更丧心病狂的省略</h2><ul><li>lambda 表达式的参数列表括号里的参数类型可以不写</li><li>参数列表里的参数只有一个的时候，括号和参数可以都不写</li><li>{} 里的代码如果只有一行，无论是否有返回值，都可以省略 {},return,分号 (要省略就必须都省略)</li></ul><p>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;新线程创建了&quot;</span>);<br>&#125;).start();<br><br><span class="hljs-comment">//优化后</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;新线程创建了&quot;</span>)).start();<br></code></pre></td></tr></table></figure><p>定义一个 Cook 类，里面只有一个 makeFood() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cook</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeFood</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主方法中定义一个使用这个接口的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeCook</span><span class="hljs-params">(Cook cook)</span>&#123;<br>    cook.makeFood();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这个方法的用法有如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">invokeCook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cook</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeFood</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;恰饭了&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//普通lambda</span><br>invokeCook(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;吃饭了&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">//优化后</span><br>invokeCook(()-&gt; System.out.println(<span class="hljs-string">&quot;开吃&quot;</span>));<br></code></pre></td></tr></table></figure><hr><p>lambda 表达式就是为了简化代码而产生的，并且应用场景比较严苛，被重写的接口必须只有一个方法，调用的函数也只能使用这个接口，这样才lambda 表达式才能根据上下文来了解需要重写哪个接口的哪个方法，为了简化代码有点丧心病狂了 (」゜ロ゜)」</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程</title>
    <link href="/2022/05/22/Java%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/05/22/Java%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><p>这玩意绝对很重要，因为经常听到多线程这个词，而且也听说很难</p><span id="more"></span><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>创建线程有两种方法，一种是创建继承Thread的子类，一种是创建实现Runnable接口的实现类</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3><p>步骤:</p><ol><li>创建一个 Thread 子类</li><li>在Thread类的子类中重写Thread的run方法，设置线程任务</li><li>创建Thread子类对象</li><li>调用Thread类中的start方法，开启新的线程执行run方法</li></ol><p>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123; <span class="hljs-comment">//继承Thread类，重写里面的run方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;run:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">myThread</span> <span class="hljs-variable">mt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">myThread</span>(); <span class="hljs-comment">//创建实现类的对象</span><br>mt.start(); <span class="hljs-comment">//启动线程</span><br><span class="hljs-type">myThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">myThread</span>(); <span class="hljs-comment">//创建第二个线程</span><br>mt1.start(); <span class="hljs-comment">//可以开启多个线程</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <span class="hljs-comment">//主线程，这些线程都是是同时执行的</span><br>    System.out.println(<span class="hljs-string">&quot;润:&quot;</span> + i);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用对象的start方法就是在调用对象的run方法，于是执行了重写的run方法</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><p>步骤:</p><ol><li>创建Runnable接口的实现类</li><li>重写接口的run方法</li><li>创建实现类对象</li><li>创建Thread类对象，构造方法中传入Runnable接口的实现类对象</li><li>调用Thread类中的start方法，开启新的线程执行run方法</li></ol><p>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()); <span class="hljs-comment">//输出线程名称</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RunnableImpl</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableImpl</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">th</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run);<br>th.start();<br></code></pre></td></tr></table></figure><ul><li>使用Runnable接口的优点就是一个类只能继承自一个父类，但能继承多个接口，如果使用继承Thread的方法，则无法继承其他的类了</li></ul><h2 id="获取线程名称的方法"><a href="#获取线程名称的方法" class="headerlink" title="获取线程名称的方法:"></a>获取线程名称的方法:</h2><p>currentThread()方法返回当前正在执行的进程对象的引用,获取主线程的线程名可以通过 Thread.currentThread().getName() 来获取<br>线程获取线程名的方法可以直接调用 getName() 方法，返回字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getName();<br>        System.out.println(name);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> currentThread();<br>        System.out.println(name1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">myThread</span> <span class="hljs-variable">mt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">myThread</span>();<br>mt.start();<br><span class="hljs-type">myThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">myThread</span>();<br>mt1.start();<br>System.out.println(Thread.currentThread().getName()); <span class="hljs-comment">//获取主线程名称</span><br></code></pre></td></tr></table></figure><p>通过currentThread()方法可以看出，调用这个线程的是主线程</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多个线程访问共享数据的时候，会出现线程安全问题，所以需要让线程进行某些操作的时候，同一时间只能有一个进程在工作<br>有两种方法实现:第一种使用synchronized同步代码块，第二种使用Lock锁</p><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一:"></a>方法一:</h3><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(锁对象)&#123;<br><span class="hljs-comment">//可能出现线程安全的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>原理: 抢夺到了同步块的执行权，会把锁对象拿走，然后执行同步代码块，执行完了就释放锁对象，其他线程执行到此处发现没有锁对象，没有执行权，会一直等待锁对象归还<br>锁对象我认为只要 Object 的对象都可以，此处锁对象可以使用一个有意义的对象来控制进程的调用</p><p>synchronized可以实现同步代码块，也可以实现同步方法</p><p>同步代码块实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">//实例化一个 Object 对象来当锁对象</span><br><span class="hljs-keyword">synchronized</span> (obj)&#123;<br>    System.out.println(Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure><p>同步方法实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (ticket&gt;<span class="hljs-number">0</span>)&#123;<br>                payTicket();<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payTicket</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(Thread.currentThread());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二:"></a>方法二:</h3><p>Lock锁解决线程安全，比synchronized更好用<br>Lock接口的方法:<br>void lock()获取锁<br>void unlock()释放锁</p><p>步骤:<br>步骤</p><ol><li>在类的成员位置创建一个ReentrantLock对象</li><li>在可能出现安全问题的代码前调用Lock接口的lock方法</li><li>在可能出现安全问题的代码后调用Lock接口的unlock方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        l.lock();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(Thread.currentThread().getName());<br>        &#125;<br>        l.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同步和锁都是让这部分代码一个时间只能有一个线程去执行，这样就不会出现线程问题了</p><h2 id="等待-wait-和唤醒-notify"><a href="#等待-wait-和唤醒-notify" class="headerlink" title="等待(wait)和唤醒(notify)"></a>等待(wait)和唤醒(notify)</h2><p>这里就可以用到同步锁对象来做到让线程等待和唤醒其他线程了</p><p>调用wait方法会使该线程进入等待状态，并且会释放被同步对象的锁<br>notify操作可以唤醒一个因执行wait而处于阻塞状态的线程，使其进入就绪状态，被唤醒的线程等待锁对象被释放后，可以尝试获得锁对象，如果获得了，则执行wait之后的代码</p><hr><p>多线程实例，包子铺和吃货</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaoZi</span> &#123; <span class="hljs-comment">//定义包子类，拿来当锁对象</span><br>    String pi; <span class="hljs-comment">//包子皮</span><br>    String xian; <span class="hljs-comment">//包子馅</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//包子是否被做好的标记</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaoZiPu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123; <span class="hljs-comment">//包子铺类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BaoZi baozi; <span class="hljs-comment">//用来接收对象锁的变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//用来控制包子铺做什么包子</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaoZiPu</span><span class="hljs-params">(BaoZi bz)</span>&#123; <span class="hljs-comment">//本类的构造方法，需要一个BaoZi对象</span><br>        <span class="hljs-built_in">this</span>.baozi = bz;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//重写run方法</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123; <span class="hljs-comment">//一直做包子</span><br>            <span class="hljs-keyword">synchronized</span> (baozi)&#123; <span class="hljs-comment">//传入锁对象</span><br>                <span class="hljs-keyword">if</span> (baozi.flag)&#123; <span class="hljs-comment">//判断包子是否做好了，true表示包子是做好了，然后包子铺线程进入等待状态</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        baozi.wait(); <span class="hljs-comment">//线程进入等待状态</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//被唤醒后</span><br>                <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//判断做什么包子</span><br>                    baozi.pi=<span class="hljs-string">&quot;薄皮&quot;</span>;<br>                    baozi.xian=<span class="hljs-string">&quot;三鲜&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    baozi.pi=<span class="hljs-string">&quot;冰皮&quot;</span>;<br>                    baozi.xian=<span class="hljs-string">&quot;牛肉&quot;</span>;<br>                &#125;<br>                count++;<br>                System.out.println(<span class="hljs-string">&quot;包子铺正在生产:&quot;</span> + baozi.pi + baozi.xian + <span class="hljs-string">&quot;包子&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;生产包子需要3s&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//设置生产包子的时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                baozi.flag=<span class="hljs-literal">true</span>; <span class="hljs-comment">//设定包子已经被生产好了</span><br>                baozi.notify(); <span class="hljs-comment">//唤醒其他线程，也就是吃货线程</span><br>                System.out.println(<span class="hljs-string">&quot;包子铺已经生产好了&quot;</span> + baozi.pi + baozi.xian + <span class="hljs-string">&quot;包子，可以吃了&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChiHuo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123; <span class="hljs-comment">//吃货类</span><br>    <span class="hljs-keyword">private</span> BaoZi baozi; <span class="hljs-comment">//用来接收对象锁的变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChiHuo</span><span class="hljs-params">(BaoZi bz)</span>&#123; <span class="hljs-comment">//本类的构造方法，需要传入一个BaoZi类对象</span><br>        <span class="hljs-built_in">this</span>.baozi=bz;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//重写run方法</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123; <span class="hljs-comment">//一直吃下去</span><br>            <span class="hljs-keyword">synchronized</span> (baozi)&#123; <span class="hljs-comment">//传入锁对象</span><br>                <span class="hljs-keyword">if</span> (!baozi.flag)&#123; <span class="hljs-comment">//判断包子是否被做好，没做好是false，取反就是true，执行下面的代码</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        baozi.wait(); <span class="hljs-comment">//吃货线程进入等待</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//被唤醒后</span><br>                System.out.println(<span class="hljs-string">&quot;吃货正在吃&quot;</span> + baozi.pi + baozi.xian + <span class="hljs-string">&quot;的包子&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;吃包子需要3s&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">//设置吃包子的时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                baozi.flag=<span class="hljs-literal">false</span>; <span class="hljs-comment">//把包子的完成设置为false，这样包子铺那边就可以执行做包子的代码了</span><br>                <span class="hljs-comment">//唤醒包子铺</span><br>                baozi.notify();<br>                System.out.println(<span class="hljs-string">&quot;吃货已经吃掉了&quot;</span> + baozi.pi + baozi.xian + <span class="hljs-string">&quot;的包子&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;==============================&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BaoZi</span> <span class="hljs-variable">baozi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaoZi</span>(); <span class="hljs-comment">//实例化BaoZi对象</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaoZiPu</span>(baozi).start(); <span class="hljs-comment">//开启包子铺线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChiHuo</span>(baozi).start(); <span class="hljs-comment">//开启吃货线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>多线程真的让人头秃，看了课之后又多看了几遍代码，然后就加上了注释，也就是自己的理解，途中还翻了许多大佬的博客来验证自己的理解是不是正确的，现在来说，理解算是接近正确的了吧 ٩(๑❛ᴗ❛๑)۶</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java异常处理</title>
    <link href="/2022/05/20/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/05/20/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p>看的我人麻了，学 Python 的异常处理的时候也没有这么晕啊 +_+</p><span id="more"></span><h2 id="throw-throws-关键字"><a href="#throw-throws-关键字" class="headerlink" title="throw&#x2F;throws 关键字"></a>throw&#x2F;throws 关键字</h2><p>在定义方法的时候，如果方法没有捕获到一个检查性异常，可以在声明末尾处用 throws 抛出异常<br>也可以用 throw 关键字抛出一个异常<br>感觉 throw和throws这两个关键字有甩锅的意思，把自己处理不了的异常交给上一级来处理，直到有父类能够处理，最终交给JVM来处理</p><p>下面定义了一个函数，返回传入的数组的指定索引的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> index)</span> <span class="hljs-keyword">throws</span> NullPointerException,ArrayIndexOutOfBoundsException&#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;传递的数组是null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index &gt;= arr.length)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;索引超出范围&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> arr[index];<br>    <span class="hljs-keyword">return</span> ele;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 throw 的时候，可以在错误类的后面写入自己的话，这样报错的时候就能输出这句话</li><li>throws 可以抛出多个异常，用逗号隔开</li><li>throw 和 throws 有一个就可以，可以不两个都写</li></ul><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>这里就和 Python 的差不多了，使用try和catch关键字来捕获异常<br>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>   <span class="hljs-comment">//程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(ExceptionName e)&#123;<br>   <span class="hljs-comment">//Catch 块</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>catch 语句包含要捕获异常类型的声明，当try代码块中发生一个异常时，后面的 catch 块就会被检查</li><li>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，交给 catch 处理<br>实例:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(String filename)</span>&#123;<br>    <span class="hljs-keyword">if</span> (filename==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;没有该文件&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;打开了文件&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>传入一个文件名，如果传入的是 null，则抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    readFile(<span class="hljs-literal">null</span>); <span class="hljs-comment">//调用方法，传入名字为null</span><br>&#125;<span class="hljs-keyword">catch</span> (NullPointerException e)&#123; <span class="hljs-comment">//捕获异常，并进行处理</span><br>    System.out.println(<span class="hljs-string">&quot;没有&quot;</span>); <span class="hljs-comment">//直接输出没有文件</span><br>    System.out.println(<span class="hljs-string">&quot;================&quot;</span>);<span class="hljs-comment">//分割线</span><br>    System.out.println(e.toString());<span class="hljs-comment">//输出异常的名称，并输出定义好的语句</span><br>    System.out.println(<span class="hljs-string">&quot;================&quot;</span>);<br>    System.out.println(e.getMessage());<span class="hljs-comment">//只输出定义好的语句</span><br>    System.out.println(<span class="hljs-string">&quot;================&quot;</span>);<br>    e.printStackTrace();<span class="hljs-comment">//红字输出异常信息，并输出定义好的语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">没有<br>================<br>java.lang.NullPointerException: 没有该文件<br>================<br>没有该文件<br>================<br>java.lang.NullPointerException: 没有该文件<br>at yichang.tryCatch.readFile(tryCatch.java:31)<br>at yichang.tryCatch.main(tryCatch.java:17)<br></code></pre></td></tr></table></figure><h2 id="finally-关键字"><a href="#finally-关键字" class="headerlink" title="finally 关键字"></a>finally 关键字</h2><p>无论 try 中的语句是否发生异常，都会被执行<br>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    readFile(<span class="hljs-literal">null</span>);<br>&#125; <span class="hljs-keyword">catch</span>(NullPointerException e)&#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;资源释放&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>异常也是一个类，可以自己定义异常<br>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> amount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">myException</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAmount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面的构造方法可以理解为一旦这个类被实例化了(出现了这个异常)，会执行的代码<br>从别的地方拿来的注意事项:</p><ul><li>所有异常都必须是 Throwable 的子类</li><li>如果希望写一个检查性异常类，则需要继承 Exception 类</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类</li></ul><hr><p>看着不难，但就是不知道为什么，脑子里面就是有无法理解的感觉，但应该算是理解了 (⊙﹏⊙)b</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manjaro华硕控制风扇转速</title>
    <link href="/2022/05/18/manjaro%E5%8D%8E%E7%A1%95%E6%8E%A7%E5%88%B6%E9%A3%8E%E6%89%87%E8%BD%AC%E9%80%9F/"/>
    <url>/2022/05/18/manjaro%E5%8D%8E%E7%A1%95%E6%8E%A7%E5%88%B6%E9%A3%8E%E6%89%87%E8%BD%AC%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="电脑有时候发烧"><a href="#电脑有时候发烧" class="headerlink" title="电脑有时候发烧"></a>电脑有时候发烧</h1><p>电脑有时候发热，热到键盘都能感到明显温度，而且电脑下面的桌子也是热乎，于是尝试用命令控制风扇<br>但由于主板的原因，不能做太多想做的事</p><span id="more"></span><h2 id="命令如下"><a href="#命令如下" class="headerlink" title="命令如下"></a>命令如下</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 2 &gt; /sys/devices/platform/asus-nb-wmi/hwmon/hwmon[[:print:]]*/pwm1_enable   #风扇自动调节<br>echo 1 &gt; /sys/devices/platform/asus-nb-wmi/hwmon/hwmon[[:print:]]*/pwm1_enable   #停止风扇<br>echo 0 &gt; /sys/devices/platform/asus-nb-wmi/hwmon/hwmon[[:print:]]*/pwm1_enable   #风扇全速转<br></code></pre></td></tr></table></figure><ul><li>root 权限下</li></ul><p>asus-nb-wmi是一个内核模块，它包含在 Linux 内核中，并在华硕笔记本电脑上自动加载</p><p>可以进入文件夹查看有哪些文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /sys/devices/platform/asus-nb-wmi/hwmon/hwmon5<br></code></pre></td></tr></table></figure><ul><li>这是我电脑的情况</li></ul><p>然后就能看到需要调整的文件 pwm1_enable 了<br><img src="/img/2022-5-18-21.png" alt="前面的命令设置的就是这个文件"></p><p>更多命令查看 <a href="https://wiki.archlinux.org/title/Fan_speed_control">https://wiki.archlinux.org/title/Fan_speed_control</a></p><hr><p>没玩到什么，因为主板现在还不敢乱搞，万一搞坏了就不好玩了</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo在GitHub上搭建博客</title>
    <link href="/2022/05/18/Hexo%E5%9C%A8GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/05/18/Hexo%E5%9C%A8GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-在GitHub上搭建博客"><a href="#Hexo-在GitHub上搭建博客" class="headerlink" title="Hexo 在GitHub上搭建博客"></a>Hexo 在GitHub上搭建博客</h1><p>这个博客搭建也有一段时间了，记录一下这个博客是怎么搭建的吧，万一以后还要用呢，写下了以后直接抄作业更香一点</p><span id="more"></span><h2 id="创建-GitHub-repository"><a href="#创建-GitHub-repository" class="headerlink" title="创建 GitHub repository"></a>创建 GitHub repository</h2><p>进入GitHub，选择右上角的加号，New repository，命名为 <strong>GitHub用户名.github.io</strong><br>然后就可以直接创建了，其他的不用管<br>进入刚创建的库，先创建一个 index.html 的文件<br><img src="/img/2022-5-18-1.png" alt="选择 creating a new file"><br><img src="/img/2022-5-18-2.png" alt="输入一行测试用的HTML语句"></p><p>文件创建好后，选择 Settings –&gt; Pages –&gt; Source<br><img src="/img/2022-5-18-3.png" alt="Source 选择main"></p><p>等待一会，就能能通过浏览器打开刚刚创建好的网页了<br><a href="http://github用户名.github.io/">http://GitHub用户名.github.io/</a><br><img src="/img/2022-5-18-4.png" alt="成功"></p><h2 id="Git-设置"><a href="#Git-设置" class="headerlink" title="Git 设置"></a>Git 设置</h2><p>如下设置Git的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;GitHub用户名&quot;<br>git config --global user.email &quot;GitHub注册邮箱&quot;<br></code></pre></td></tr></table></figure><p>生成 ssh 秘钥:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>进入 .ssh 文件，查看公钥并复制下来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd .ssh<br>cat id_rsa.pub<br></code></pre></td></tr></table></figure><p>打开 Settings<br><img src="/img/2022-5-18-5.png"><br>把刚复制下来的公钥加入到 SSH keys 中<br><img src="/img/2022-5-18-6.png"><br><img src="/img/2022-5-18-7.png"></p><p>回到终端测试是否连接库成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh git@github.com<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-18-8.png" alt="出现此提示表示连接成功"></p><h2 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h2><p>安装 Node.js，ArchLinux 的库中有，可以直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S nodejs npm<br></code></pre></td></tr></table></figure><p>检查 npm 是否安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm -v<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-18-9.png" alt="安装成功"></p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>使用 npm 安装 Hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli <br></code></pre></td></tr></table></figure><p>创建博客的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir Blog<br></code></pre></td></tr></table></figure><p>初始化博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd Blog<br>hexo init<br></code></pre></td></tr></table></figure><p>进入博客的目录，继续执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install<br></code></pre></td></tr></table></figure><p>安装成功后的Blog目录下有如下文件<br><img src="/img/2022-5-18-10.png"></p><p>测试网址是否搭建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo s<br></code></pre></td></tr></table></figure><ul><li>g: generate 的简写，生成静态文件</li><li>s: server 的简写，启动服务器，默认是在本地</li></ul><p>打开浏览器，输入 127.0.0.1:4000<br><img src="/img/2022-5-18-11.png" alt="博客在本地搭建完成"></p><h2 id="推送博客到-GitHub"><a href="#推送博客到-GitHub" class="headerlink" title="推送博客到 GitHub"></a>推送博客到 GitHub</h2><p>在博客的根目录下，有一个 _config.yml 文件，编辑这个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim _config.yml<br></code></pre></td></tr></table></figure><p>在文件的最下面，有一个 deploy 模块，修改这个模块</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">deploy:<br>type: git<br>repo: https://github.com/GitHub用户名/GitHub用户名.github.io.git.git<br>branch: master<br></code></pre></td></tr></table></figure><p>网址直接在GitHub的库里复制<br><img src="/img/2022-5-18-12.png" alt="直接点击复制"><br>退出并保存</p><p>再安装 Git 部署插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>推送博客到GitHub</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><ul><li>clean: 清除缓存文件</li><li>d: deploy 的简写，部署网站</li></ul><p>如果碰到如下报错导致无法提交的情况↓</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.<br>remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.<br>fatal: &#x27;https://github.com/GitHub用户名/GitHub用户名.github.io.git/&#x27; 鉴权失败<br>FATAL &#123;<br>  err: Error: Spawn failed<br>      at ChildProcess.&lt;anonymous&gt; (/home/wjk/blog/node_modules/hexo-util/lib/spawn.js:51:21)<br>      at ChildProcess.emit (node:events:527:28)<br>      at ChildProcess._handle.onexit (node:internal/child_process:291:12) &#123;<br>    code: 128<br>  &#125;<br>&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html<br></code></pre></td></tr></table></figure><p>解决方法<br>打开 Github 的 Settings<br>进入 Developer settings<br>打开 Personal access tokens<br>点击 Generate new token，生成一个新的 token，在输入密码的时候输入这个 token<br><img src="/img/2022-5-18-13.png"><br><img src="/img/2022-5-18-14.png"></p><p>出现这种情况的原因是因为 GitHub 已经不再采用密码登录了，所以每一次上传都需要这个 token<br>这样做十分麻烦，所以在前面设置项目地址的时候，可以不设置为 HTTPS，而设置为 SSH<br><img src="/img/2023-4-18-1.png"></p><p>这样就能通过浏览器打开放置个人网站的仓库路径，博客搭建完成</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>先到 <a href="https://www.namesilo.com/">https://www.namesilo.com/</a> 上注册一个账号，购买一个域名<br><img src="/img/2022-5-18-15.png" alt="够买域名"><br><img src="/img/2022-5-18-16.png"><br><img src="/img/2022-5-18-17.png"><br>进入管理我的域名页面<br>管理 DNS<br><img src="/img/2022-5-18-18.png"></p><p>这里要添加两种解析，一种是 A ，一种是 CNAME，A 类解释是下面四个</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">185.199.108.153<br>185.199.109.153<br>185.199.110.153<br>185.199.111.153<br></code></pre></td></tr></table></figure><p>CNAME 的目标地址就是博客的地址<br><img src="/img/2022-5-18-19.png"></p><p>最后在博客的 <code>source</code> 目录下创建一个 CNAME 文件，里面就写买好的域名<br>再打开 GitHub 博客的库，进入 Settings –&gt; Pages，设置域名<br><img src="/img/2022-5-18-20.png"><br>搞定，后面可以自行添加 HTTPS</p><p>Hexo官方文档，自行查看: <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><hr><p>过了这么久了，都有点忘了，这回有回忆起来了，也好，加深了点印象，碰到的问题也能够快速解决  ♪（＾∀＾●）ﾉｼ</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manjaro更换默认Java版本</title>
    <link href="/2022/05/17/manjaro%E6%9B%B4%E6%8D%A2%E9%BB%98%E8%AE%A4Java%E7%89%88%E6%9C%AC/"/>
    <url>/2022/05/17/manjaro%E6%9B%B4%E6%8D%A2%E9%BB%98%E8%AE%A4Java%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="安装burpsuite的时候发现打不开"><a href="#安装burpsuite的时候发现打不开" class="headerlink" title="安装burpsuite的时候发现打不开"></a>安装burpsuite的时候发现打不开</h1><p>由于系统崩了，所有软件都要重装，安装burpsuite的时候发现打不开了</p><span id="more"></span><p><img src="/img/2022-5-17-1.png"><br>重装了几次后，还是打不开，然后仔细看了一下说明，发现了这条<br><img src="/img/2022-5-17-2.png"><br>原来是 Java 的版本太老了，需要换一个Java版本</p><h2 id="更换Java默认版本"><a href="#更换Java默认版本" class="headerlink" title="更换Java默认版本"></a>更换Java默认版本</h2><p>这里可以先看一下 Java 安装的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">which java<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-17-3.png"><br>进入这个文件夹，用一下命令可以看到一个程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls *java*<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-17-4.png"><br>archlinux-java 这个程序就是需要用到的程序，这个命令在哪都能用，因为它在 bin 文件夹下，我只是找了一下它在哪，看了看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">archlinux-java status<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-17-5.png"></p><ul><li>列出已安装的Java，和默认的版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">archlinux-java set &lt;JAVA_ENV&gt;<br></code></pre></td></tr></table></figure><ul><li>设置默认Java，需要在root用户下执行</li></ul><hr><p>系统崩了，正在努力把电脑恢复到以前的状态，碰到了之前没碰到过的问题，也算是经历了一次成长吧 ( ╯-_-)╯┴—┴</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware没有网络</title>
    <link href="/2022/05/16/VMware%E6%B2%A1%E6%9C%89%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/05/16/VMware%E6%B2%A1%E6%9C%89%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="重装了-manjaro-系统"><a href="#重装了-manjaro-系统" class="headerlink" title="重装了 manjaro 系统"></a>重装了 manjaro 系统</h1><p>由于电脑不知道怎么了，突然开不了机，由于我太菜了，所以决定重装系统<br>然后重装所有的软件，今天安装虚拟机的时候，发现虚拟机连不到网络，百度了一下，解决了<br>不过之前解决了就没看到底是什么命令，今天记录一下，万一以后要用，不但知道怎么解决，还知道为什么要这么做了</p><span id="more"></span><h2 id="解决方法及理解"><a href="#解决方法及理解" class="headerlink" title="解决方法及理解"></a>解决方法及理解</h2><p>先加载模块<br>VMware 使用网络需要一个模块，所以需要把模块加载进入 Linux 内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo modprobe vmnet<br></code></pre></td></tr></table></figure><p>启动模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vmware-networks --start<br></code></pre></td></tr></table></figure><p>Could not connect ‘Ethernet0’ to virtual network ‘&#x2F;dev&#x2F;vmnet8’. More information can be found in the vmware.log file.<br>翻译过来就是找不到这张网卡，所以连不上网，网上用的是 vmware-networks 这个命令，应该是一个 VMware 的网络管理工具<br>但这个命令不知道怎么回事，目标不能是一个目录，必须是一个文件，所以要先创建一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo touch /dev/vmware/fuck<br></code></pre></td></tr></table></figure><p>然后再用命令，把网卡迁移进去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vmware-networks --migrate-network-settings /dev/vmware/fuck<br></code></pre></td></tr></table></figure><p>这个创建的文件就能删掉了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rm /dev/vmware/fuck<br></code></pre></td></tr></table></figure><p><strong>也可以在 VMware 的 Edit –&gt; Virtual Network Editor 里面重新创建一个虚拟网卡</strong></p><h2 id="开机启动模块"><a href="#开机启动模块" class="headerlink" title="开机启动模块"></a>开机启动模块</h2><p>把要启动的模块名字写入 &#x2F;etc&#x2F;modules-load.d&#x2F;modules.conf 文件中，就可以开机启动模块了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo echo &quot;vmnet&quot; &gt;&gt; /etc/modules-load.d/modules.conf<br></code></pre></td></tr></table></figure><p>重启之后查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsmod | grep vmnet<br></code></pre></td></tr></table></figure><h2 id="对模块的理解"><a href="#对模块的理解" class="headerlink" title="对模块的理解"></a>对模块的理解</h2><p>之前玩的 v4l2loopback 也用到了模块，看了些文章后，有了自己的一些理解<br>这是为了方便开发内核的一个方式，如果要对 Linux 内核进行开发，那么就需要测试这个内核程序能否跑起来，如果每次跑都要编译一次内核，就会特别麻烦，这时候，就用到了模块<br>把模块挂在内核上面运行，如果成功了，就没问题，如果失败了，modprobe 这个工具就会把模块卸下，不影响内核，方便快速</p><hr><p>系统崩了，心累，没有一点防备，就这样悄悄的崩溃 (ᗒᗣᗕ)՞</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VMware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java比较器</title>
    <link href="/2022/05/15/Java%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    <url>/2022/05/15/Java%E6%AF%94%E8%BE%83%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>自己创建的类组成的列表，如果没有重写排序的方法，那么就没办法对它进行排序，这时就能手动建立一个专属于它的比较器，来实现对这个列表的排序，Comparator 这个接口就能实现</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Person&gt; son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>son.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;王师傅&quot;</span>, <span class="hljs-number">35</span>));<br>son.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;刘师傅&quot;</span>, <span class="hljs-number">17</span>));<br>son.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张师傅&quot;</span>, <span class="hljs-number">28</span>));<br>Collections.sort(son, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123; <span class="hljs-comment">//重写了Comparator接口的compare方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person t1, Person t2)</span> &#123;<br>        <span class="hljs-keyword">return</span> t1.getAge() - t2.getAge();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>list和set都是Collection的子类，Collections类仅由静态方法组合或返回集合，它包含对集合进行操作的多态算法<br>在这里使用Collections里的sort方法，对son这个list排序，但Person这个类是我自己创建的，无法进行排序，所以重写了compare方法，对这个list进行了排序</p><p>t1-t2是升序，t2-t1是降序<br>理解:</p><ul><li>如果是t1-t2，当传进来的两个元素，t1比t2大，那么就会返回一个大于0的数，说明这个值要进行一次交换，把小的放在前面，小于0则不较换</li><li>如果是t2-t1，当传进来的两个元素，t1比t2大，那么就会返回一个小于0的数，不用进行交换，就把大的放在了前面，小的放在了后面，大于0就进行交换</li></ul><h2 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2><p>Comparable 是一个接口，对实现它的每个类的对象强加一个整体排序，这个排序被称为类的自然排序，类的compareTo方法被称为其自然比较方法<br>而自己创建的类没有 compareTo方法，所以在创建类的时候就可以继承 Comparable 这个接口，实现它的 compareTo 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt;&#123; <span class="hljs-comment">//泛型，Comparble接口是一个泛型接口</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person person)</span> &#123;<br>        <span class="hljs-comment">//自定义比较规则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAge()-person.getAge();<span class="hljs-comment">//按照年龄升序排序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Person&gt; per = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>per.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">143143</span>));<br>per.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">424</span>));<br>per.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">303452</span>));<br>per.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;赵六&quot;</span>, <span class="hljs-number">23440</span>));<br>System.out.println(per);<br>Collections.sort(per);<br>System.out.println(per);<br></code></pre></td></tr></table></figure><p>调用 Collections 类里的sort这个静态方法，就是在调用 compareTo，重写后就能对这个列表排序了</p><hr><p>没想到泛型这东西还是没有理解透，翻看了好几次 Java泛型这篇博客，看来写博客还是有用的，可以快速回忆自己当时是怎么想的</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型</title>
    <link href="/2022/05/13/Java%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/05/13/Java%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="感觉是个重点"><a href="#感觉是个重点" class="headerlink" title="感觉是个重点"></a>感觉是个重点</h1><p>感觉是一个很重要的东西，很有必要记录下来，也觉得蛮有用的</p><span id="more"></span><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>我认为是一个定义一个类，这个类里面的数据类型不是固定的，可以让这个类处理多种数据类型的数据<br>格式:<br>定义一个含有泛型的类，就是在类的名称后面加一个&lt;E&gt;，把数据的类型换成E就可以了，E也可以换成其他的，只要有尖括号就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">generic</span>&lt;E&gt;&#123; <span class="hljs-comment">//定义一个含有泛型的类</span><br>    <span class="hljs-keyword">private</span> E name;<br>    <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(E name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用:<br>使用泛型类有两种方式，一种是不用泛型，直接使用类，另一种是使用泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">generic</span> <span class="hljs-variable">gc1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">generic</span>&lt;&gt;(); <span class="hljs-comment">//这样实例化泛型类也是可以的，在使用后面setName方法时可以使用各种类型的数据</span><br>gc1.setName(<span class="hljs-string">&quot;str1&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> gc1.getName();<br>System.out.println(obj1);<br><br><span class="hljs-type">generic</span> <span class="hljs-variable">gc2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">generic</span>&lt;&gt;();<br>gc2.setName(<span class="hljs-number">123</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> gc2.getName();<br>System.out.println(obj2);<br><br>generic&lt;String&gt; gc3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">generic</span>&lt;&gt;(); <span class="hljs-comment">//这样实例化泛型类也是可以的，后面的setName方法只能传入String类型数据</span><br>gc3.setName(<span class="hljs-string">&quot;str2&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> gc3.getName();<br>System.out.println(obj3);<br><br>generic&lt;Integer&gt; gc4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">generic</span>&lt;&gt;(); <span class="hljs-comment">//这个对象的setName方法只能传入Integer类型的数据</span><br>gc4.setName(<span class="hljs-number">456</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj4</span> <span class="hljs-operator">=</span> gc4.getName();<br>System.out.println(obj4);<br></code></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>定义一个含有泛型的方法，就是在修饰符后面加一个&lt;E&gt;，和类一样<br>格式:<br>修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)){<br>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;M&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(M m)</span>&#123; <span class="hljs-comment">//定义一个含有泛型的方法</span><br>    System.out.println(m);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(S s)</span>&#123; <span class="hljs-comment">//定义一个含有泛型的方法</span><br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>定义一个泛型接口，里面的方法可以是泛型方法<br>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">generic</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(E e)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类有两种:</p><ol><li>实现类也使用泛型，相当与定义了一个含有泛型的类，创建对象的时候确定泛型的类型<br>在实现类的名字后面也<strong>有</strong>一个尖括号&lt;O&gt;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">genericClass1</span>&lt;O&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">generic</span>&lt;O&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(O o)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;1重写接口方法&quot;</span> + o);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    genericClass1&lt;String&gt; gc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">genericClass1</span>&lt;&gt;();<br>    gc.method1(<span class="hljs-string">&quot;~bia~&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>定义接口的实现类，实现接口，指定接口的泛型，实现类已经定义好使用什么数据类型<br>在实现类的名字后面<strong>没有</strong>尖括号&lt;String&gt;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">genericClass2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">generic</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;2重写接口方法&quot;</span> + s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">genericClass2</span> <span class="hljs-variable">gc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">genericClass2</span>();<br>    gc.method(<span class="hljs-string">&quot;~pia~&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符 ?"></a>泛型的通配符 ?</h2><p>不能在创建对象的时候使用，只能作为方法的参数使用<br>定义一个方法，传入的数组&#x2F;集合数据类型不固定，全部输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(ArrayList&lt;?&gt; list)</span>&#123; <span class="hljs-comment">//list里的数据类型是不确定的，这里可以使用泛型通配符 ?</span><br>    Iterator&lt;?&gt; it = list.iterator(); <span class="hljs-comment">//同理，迭代器里的数据也不确定，使用泛型通配符 ?</span><br>    <span class="hljs-keyword">while</span> (it.hasNext())&#123;<br>        System.out.println(it.next());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>泛型这么难，肯定是块硬骨头，啃下来说不定对Java就有更深的了解了，况且为了总结一下泛型，把看过的课又看了一遍，算是复习了吧，脑子里对这玩意的了解更深刻了 ヾ(´∀&#96;o)+</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2022/05/13/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/13/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一下最近几天觉得比较重要的东西"><a href="#记录一下最近几天觉得比较重要的东西" class="headerlink" title="记录一下最近几天觉得比较重要的东西"></a>记录一下最近几天觉得比较重要的东西</h1><p>玩别的东西去了，java 都没学多少，不能再这么颓废下去了</p><span id="more"></span><h2 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h2><p>Collection 是一个用到了泛型的接口，可以选择实例化一个实现类来使用，也可以用多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//利用多态来创建一个集合</span><br>coll.add(<span class="hljs-string">&quot;aaa&quot;</span>); <span class="hljs-comment">//add方法新增元素</span><br>coll.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>coll.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> coll.remove(<span class="hljs-string">&quot;aaa&quot;</span>); <span class="hljs-comment">//remove方法移除元素,放回布尔值</span><br>System.out.println(coll.contains(<span class="hljs-string">&quot;ddd&quot;</span>)); <span class="hljs-comment">//contains方法判断是否包含元素</span><br>System.out.println(coll.isEmpty()); <span class="hljs-comment">//isEmpty判断集合是否为空</span><br>System.out.println(coll.size()); <span class="hljs-comment">//返回集合的长度</span><br>Object[] arr = coll.toArray(); <span class="hljs-comment">//把集合中的元素存储到数组中</span><br>coll.clear(); <span class="hljs-comment">//clear方法清空元素</span><br></code></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>由于集合是没有顺序的，和 Python 一样，所以不能用索引来找到元素，这就需要迭代器，也和 Python 一样，果然语言是相同的<br>要使用迭代器就要先实例化一个迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>coll.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>coll.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>coll.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>Iterator&lt;String&gt; it = coll.iterator(); <span class="hljs-comment">//获取一个迭代器</span><br><span class="hljs-keyword">while</span> (it.hasNext())&#123; <span class="hljs-comment">//判断迭代器是否有元素</span><br>    System.out.println(it.next()); <span class="hljs-comment">//输出元素</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><p>用来遍历集合和数组，说真的，很像 Python<br>格式:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">for(集合/数组的数据类型 变量名:集合/数组)&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i:arr)&#123;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一眼看上去就是 Python 里的 foreach 的循环结构</p><hr><p>走网络安全这一条路我是要走到黑，什么东西都要了解一下，知道原理，脑子里的东西越多，才能更牛逼</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>snd-aloop模拟声音设备</title>
    <link href="/2022/05/11/snd-aloop%E6%A8%A1%E6%8B%9F%E5%A3%B0%E9%9F%B3%E8%AE%BE%E5%A4%87/"/>
    <url>/2022/05/11/snd-aloop%E6%A8%A1%E6%8B%9F%E5%A3%B0%E9%9F%B3%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="搞完了虚拟摄像头，没有麦克风怎么行"><a href="#搞完了虚拟摄像头，没有麦克风怎么行" class="headerlink" title="搞完了虚拟摄像头，没有麦克风怎么行"></a>搞完了虚拟摄像头，没有麦克风怎么行</h1><p>本想着下次班主任开班会的时候可以调戏一波，但突然发现没有麦克风，只有摄像头怎么行，所有今天就尝试着解决了这个问题</p><span id="more"></span><h2 id="snd-aloop-模块"><a href="#snd-aloop-模块" class="headerlink" title="snd-aloop 模块"></a>snd-aloop 模块</h2><p>用的也是一个模块，snd-aloop ，它可以用来创建虚拟声音设备<br>安装模块到内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo modprobe snd-aloop<br></code></pre></td></tr></table></figure><p>列出新虚拟的设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aplay -l<br></code></pre></td></tr></table></figure><p>可以看到有一个 Loopback 的声卡，这张声卡就是 snd-aloop 虚拟出来的声卡<br>这里可以看到这张声卡的设备编号和设备编号</p><h2 id="推送音频"><a href="#推送音频" class="headerlink" title="推送音频"></a>推送音频</h2><p>知道了卡号和设备号就能向这个设备推送音频了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -stream_loop -1 -i &#x27;audio.mkv&#x27; -f pulse hw:2,0 <br></code></pre></td></tr></table></figure><p>各参数解释</p><ul><li>-stream_loop 循环次数，-1表示无线循环</li><li>-i 输入源</li><li>约束输出文件的格式容器，音频可以用 pulse, alsa</li><li>hw:R,W<br>打开对应的声卡<br>R:虚拟卡设备编号<br>W:记录设备编号</li></ul><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>开两个终端，然后就可以和虚拟摄像头一起使用了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -re -stream_loop -1 -i &#x27;audio.mkv&#x27; -f pulse hw:*,*<br>ffmpeg -re -stream_loop -1 -i &#x27;video.mkv&#x27; -f v4l2 /dev/video*<br></code></pre></td></tr></table></figure><hr><p>差不多把摄像头，麦克风搞定了，下次就能调戏一波视频软件了 (*•̀ㅂ•́)و</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>snd-aloop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v4l2loopback虚拟摄像机</title>
    <link href="/2022/05/09/v4l2loopback%E8%99%9A%E6%8B%9F%E6%91%84%E5%83%8F%E6%9C%BA/"/>
    <url>/2022/05/09/v4l2loopback%E8%99%9A%E6%8B%9F%E6%91%84%E5%83%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="尝试用-v4l2loopback-虚拟了个摄像头"><a href="#尝试用-v4l2loopback-虚拟了个摄像头" class="headerlink" title="尝试用 v4l2loopback 虚拟了个摄像头"></a>尝试用 v4l2loopback 虚拟了个摄像头</h1><p>玩了玩 v4l2loopback 这个模块，还蛮有意思的，可以创建虚拟虚拟视频设备，普通的 v4l2 应用程序可以读取这些设备，就好像它们是普通的视频设备一样<br>这玩意搭配 FFmpeg 使用说不定就能模拟一个摄像头跟别人视频聊天，虽然人不在电脑前，但别人看到的还是我在电脑前 (o゜▽゜)o☆</p><span id="more"></span><h2 id="v4l2loopback-使用"><a href="#v4l2loopback-使用" class="headerlink" title="v4l2loopback 使用"></a>v4l2loopback 使用</h2><p>先安装这个模块，ArchLinx 的官方库里有，可以直接安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S v4l2loopback-dkms<br></code></pre></td></tr></table></figure><p>运行模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo modprobe v4l2loopback<br></code></pre></td></tr></table></figure><p>这样就可以查看 &#x2F;sys&#x2F;devices&#x2F;virtual&#x2F;video4linux 中是否有虚拟的摄像头了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls ls -1 /sys/devices/virtual/video4linux<br></code></pre></td></tr></table></figure><p>&#x2F;dev 中也能看到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /dev/video*<br></code></pre></td></tr></table></figure><h2 id="在运行-v4l2loopback-模块的时候可以选择加入参数"><a href="#在运行-v4l2loopback-模块的时候可以选择加入参数" class="headerlink" title="在运行 v4l2loopback 模块的时候可以选择加入参数"></a>在运行 v4l2loopback 模块的时候可以选择加入参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo modprobe v4l2loopback devices=2<br></code></pre></td></tr></table></figure><p>devices 参数可以指定虚拟出多少个设备<br>如果要更改配置，需要先卸载模块，重新运行模块才可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo modprobe --remove v4l2loopback<br></code></pre></td></tr></table></figure><h2 id="FFmpeg-把视频流推给虚拟摄像头"><a href="#FFmpeg-把视频流推给虚拟摄像头" class="headerlink" title="FFmpeg 把视频流推给虚拟摄像头"></a>FFmpeg 把视频流推给虚拟摄像头</h2><p>FFmpeg 是一个多媒体视频处理工具，有许多非常牛逼的功能，比如视频采集功能、视频格式转换、视频抓图、给视频加水印等<br>反正处理视频能力就是特别强</p><p>虽然虚拟了摄像头设备，但这些摄像头没有东西可以用，这里就需要使用 FFmpeg 把视频流推给它们</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -re -stream_loop -1 -i &#x27;video.mkv&#x27; -f v4l2 /dev/video2<br></code></pre></td></tr></table></figure><p>各参数解释</p><ul><li>-readrate <speed>: 读取速度</li><li>-re: 以本机帧速率读取，相当于 “-readrate 1”</li><li>-i: 输入源，一个视频</li><li>-f: 约束输出文件的格式容器，可以使用 v4l2</li><li>-stream_loop <number>: 循环播放视频的次数，-1表示无线循环</li><li>&#x2F;dev&#x2F;video: 指定设备，这里用的是我虚拟出来的摄像头</li></ul><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>使用 ffplay 测试效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffplay /dev/video2 <br></code></pre></td></tr></table></figure><p>这样就会打开一个窗口，这个窗口里播放的就是我刚推送的视频</p><p>使用 VLC 测试效果<br>打开 VLC ，左上角选择 媒体 -&gt; 打开捕获设备<br><img src="/img/2022-5-9-1.png" alt="选择对应的设备"><br>点击播放就能看到刚推送的视频了</p><p>使用 OBS 测试效果<br>先在 OBS 中开启虚拟摄像机<br><img src="/img/2022-5-9-2.png"><br>在来源中添加一个视频采集设备，设备选择虚拟摄像设备，就能看到刚推送的视频了<br><img src="/img/2022-5-9-3.png"></p><hr><p>感觉开启了新大陆，如果在和别人视频聊天的时候，把摄像机设备换成虚拟的，那我不就能伪装成别人了吗<br>I am faker…</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>v4l2loopback</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内部类</title>
    <link href="/2022/05/08/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2022/05/08/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>一个类内部包含另一个类，就是套娃<br>在定义一个类的时候，可以在这个类里面在套一个类，这样在外部类中就可以实例化这个内部类，使用这个内部类的方法<br>分两种：成员内部类，局部内部类</p><span id="more"></span><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>就是在外部类里直接定义作为这个类的成员的类<br>格式:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">修饰符 class 外部类名称 &#123;<br>    修饰符 class 内部类名称&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123; <span class="hljs-comment">//外部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123; <span class="hljs-comment">//内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//内部类方法</span><br>            System.out.println(<span class="hljs-string">&quot;I am running&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//外部类方法</span><br>        System.out.println(<span class="hljs-string">&quot;I am going&quot;</span>);<br><br>        <span class="hljs-type">Engine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Engine</span>(); <span class="hljs-comment">//实例化一个内部类对象</span><br>        engine.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内部类用外部类的方法随意使用</li><li>外部类用内部类需要实例化内部类对象</li></ul><p>使用成员内部类方法<br>1.间接方法: 在外部类的方法中，使用内部类，然后只调用外部类的方法<br>2.直接方法: 外部类名称.内部类名称 对象名称 &#x3D; new 外部类名称().new 内部类名称();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(); <span class="hljs-comment">//实例化一个车对象</span><br>        car.go(); <span class="hljs-comment">//间接方法</span><br><br>        <span class="hljs-comment">//直接方法</span><br>        Car.<span class="hljs-type">Engine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Engine</span>(); <span class="hljs-comment">//实例化一个车里面的引擎对象</span><br>        engine.run();<span class="hljs-comment">//调用内部类的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果内外部重名了，内部类使用外部类的方法是 外部类名称.this.外部类成员变量名</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>如果一个类是定义在方法内部的，那么这是一个局部内部类<br>局部: 只有当前所属的方法才能使用它，出了这个方法就不能用了<br>格式:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">修饰符 class 外部类名称&#123;<br>    修饰符 返回值类型 外部类方法名称(参数列表)&#123;<br>        class 局部内部类名称&#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>就是一个方法里面定义了一个类，方便在这个方法内使用，别的地方都不能使用这个类<br>例子:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOuter</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//这是一个外部类方法</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123; <span class="hljs-comment">//在方法里面定义的类</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodInner</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(); <span class="hljs-comment">//在方法里面实例这个类</span><br>        inner.methodInner(); <span class="hljs-comment">//使用对象的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用起来和普通的类的方法没区别，只是这个方法在允许的时候会创建一个类，并且使用这个类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>(); <span class="hljs-comment">//实例化一个外部类</span><br>        outer.methodOuter(); <span class="hljs-comment">//使用这个类的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>如果接口的实现类(或是父类的子类)只需要使用唯一的一次，那么这种情况就可以省略该类的定义，改为使用匿名内部类<br>格式:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">接口名称 对象名 = new 接口名称()&#123;<br>    //覆盖重写所有抽象方法<br>&#125;;<br></code></pre></td></tr></table></figure><p>匿名内部类在创建对象的时候，只能使用唯一一次<br>这样就可以在使用接口的时候不用特意定义一个接口的实现类<br>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">myInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">myInterface</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">myInterface</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;重写了方法&quot;</span>);<br>            &#125;<br>        &#125;;<br>        obj.meMethod(); <span class="hljs-comment">//使用这个对象的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>不难，在脑子里想了一下，在做了个总结后，清晰许多了</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多态</title>
    <link href="/2022/05/07/Java%E5%A4%9A%E6%80%81/"/>
    <url>/2022/05/07/Java%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-多态"><a href="#Java-多态" class="headerlink" title="Java 多态"></a>Java 多态</h1><p>刚学完，记录一下，做个笔记</p><span id="more"></span><h2 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h2><p>用起来还是比较简单的:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">父类名称 对象名 = new 子类名称();<br>接口名称 对象名 = new 实现类名称();<br></code></pre></td></tr></table></figure><p>原本使用子类或父类的时候，是左右都是子类或者父类名称，这里把左边的名称换成了父类名称<br>定义很简单，理解后用起来也很简单</p><h2 id="子类与父类的变量重名"><a href="#子类与父类的变量重名" class="headerlink" title="子类与父类的变量重名"></a>子类与父类的变量重名</h2><ul><li>直接通过对象名称访问成员变量，等号左边是谁，优先用谁，没有则向上找</li><li>间接访问成员方法访问成员变量，看方法属于是，优先用谁，没有则向上找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span> &#123; <span class="hljs-comment">//父类</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">father</span>&#123; <span class="hljs-comment">//子类</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">father</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">child</span>();<br>        System.out.println(obj.num); <span class="hljs-comment">// ①</span><br>        obj.show(); <span class="hljs-comment">// ②</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>①处会输出父类的10，而不是子类的20，因为多态是实例化一个子类，但把它当做父类来看，所以num用的是父类里的值<br>②处会输出子类的20，因为子类对父类的show方法进行了重载，优先使用本类的成员变量，如果没有则向上找</p><h2 id="多态方法的使用"><a href="#多态方法的使用" class="headerlink" title="多态方法的使用"></a>多态方法的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span> &#123; <span class="hljs-comment">//父类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类的方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodFu</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类特有的方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">child</span>&#123; <span class="hljs-comment">//子类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">father</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">child</span>();<br><br>        obj.method(); <span class="hljs-comment">//父子都有，优先用子</span><br>        obj.methodFu(); <span class="hljs-comment">//子类没有，向上找，使用父类的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>obj是父类的东西，但是是由子类new出来的，obj可以使用父类的方法，子类重写了才会在子类中实现，父类中没有的，子类中定义的，obj会找不到</p><h2 id="多态的转型"><a href="#多态的转型" class="headerlink" title="多态的转型"></a>多态的转型</h2><p>向上转型，就是多态的写法<br>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Father</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br></code></pre></td></tr></table></figure><p>创建一个子类对象，把它当做父类来看待使用<br>向上转型一定是安全的<br>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><p>创建一个猫的子类对象，把它当做动物对象来看待</p><p>向下转型类似于数据类型的强制类型转换<br>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">子类名称 对象名 = (子类名称) 原对象;<br></code></pre></td></tr></table></figure><p>向下转型，其实是一个还原的动作<br>比如实例了一只猫，把它当做动物看，但猫能干的事动物未必能干，所以要把这个猫还原为猫对象<br>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br><span class="hljs-type">Cat</span> <span class="hljs-variable">mao</span> <span class="hljs-operator">=</span> (Cat) cat;<br>mao.catMouse(); <span class="hljs-comment">// 猫抓老鼠的方法</span><br></code></pre></td></tr></table></figure><hr><p>Java 多态刚学感觉好难，但仔细想了一下，思绪理通一下，就差不多理解了<br>理解了自己之前不懂的东西好有成就感啊 ヾ(≧▽≦*)o </p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java接口</title>
    <link href="/2022/05/06/Java%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/05/06/Java%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="接口学得我懵逼了，总结一下"><a href="#接口学得我懵逼了，总结一下" class="headerlink" title="接口学得我懵逼了，总结一下"></a>接口学得我懵逼了，总结一下</h1><p>趁着刚学完，做个笔记以后好回忆</p><span id="more"></span><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">myInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodAbs1</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodAbs2</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodAbs3</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodAbs4</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口的方法必须有 public abstract 两个关键词修饰<br>但这两个关键词可以省略<br>以上四个都是抽象方法</p><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">myInterfaceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">myInterface</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodAbs1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;first method&quot;</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>接口不能直接使用，必须先实现类来实现该接口<br>接口必须覆盖重写（实现）接口中所有的抽象方法<br>如果实现类没覆盖重写所有的抽象方法，否则自己必须是抽象类</p><h2 id="接口常量"><a href="#接口常量" class="headerlink" title="接口常量"></a>接口常量</h2><p>就是接口里的“成员变量”，必须用 public static final 修饰<br>可以省略 public static final ，不写效果一样<br>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">myInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>建议常量全部大写，用下划线分隔</p><h2 id="接口静态方法"><a href="#接口静态方法" class="headerlink" title="接口静态方法"></a>接口静态方法</h2><p>格式就是把abstract或者default换成static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">myInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和静态方法的用法一样直接接口名称调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        myInterface.method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h2><p>用以解决接口升级的问题，接口定义了 default 修饰的方法后，使用接口的类可以直接使用，不需要覆盖重写，也可以覆盖重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">myInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">myInterface</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">demo</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">demo</span>();<br>        one.method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法就是在定义接口的时候实现的方法，继承它的类可以选择覆盖重写，或者不管<br>这些类实现的对象可以使用这些默认方法</p><h2 id="接口私有方法"><a href="#接口私有方法" class="headerlink" title="接口私有方法"></a>接口私有方法</h2><p>当定义默认接口的时候，会出现重复的代码块，这时候就可以把这些代码块提取出来放在一个方法里面，需要用的时候直接调用就可以了<br>但这些方法只能允许本接口中这些默认方法使用，所有可以给这些方法修饰为私有(private)方法<br>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">myInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        ...<br>        play();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        ...<br>        play();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>play 方法只允许本接口中的方法使用，别的地方都不能使用</p><h2 id="接口私有静态方法"><a href="#接口私有静态方法" class="headerlink" title="接口私有静态方法"></a>接口私有静态方法</h2><p>接口中的静态方法也会有重复的代码块，这时候也可以把它提取出来放在一个方法里面，由于这些方法是静态的，所有这个代码块也要是静态的，又因为不想让这个代码块再别的地方用，再给它加个私有(private)的修饰<br>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">myInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        ...  <br>        play();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        ...<br>        play();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        myInterface.methodA();<br>        myInterface.methodB();<br><br>        <span class="hljs-comment">//myInterface.play(); //这是不允许的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一个类只能有一个父类，但可以有多个接口"><a href="#一个类只能有一个父类，但可以有多个接口" class="headerlink" title="一个类只能有一个父类，但可以有多个接口"></a>一个类只能有一个父类，但可以有多个接口</h2><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">myInterfaceA</span>, myInterfaceB&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果实现类有多个接口中，存在重复的抽象方法，那么只需要覆写一次就可以了</li><li>如果实现类没有覆盖重写所有接口的所有抽象方法，那么实现类必须是一个抽象类</li><li>如果多个接口中存在重复的默认方法，那么实现类必须覆盖重写默认方法</li><li>如果父类中的方法和接口中的默认方法产生冲突，优先用父类中的方法</li></ul><hr><p>懵逼中，总结了一下后，感觉好多了(´･_･&#96;)</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2022/05/05/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/05/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一些今天学到的觉得比较重要的内容"><a href="#记录一些今天学到的觉得比较重要的内容" class="headerlink" title="记录一些今天学到的觉得比较重要的内容"></a>记录一些今天学到的觉得比较重要的内容</h1><p>记录一些东西，以后查笔记的时候也方便一点</p><span id="more"></span><h2 id="Arrays-常用的方法"><a href="#Arrays-常用的方法" class="headerlink" title="Arrays 常用的方法"></a>Arrays 常用的方法</h2><p>Arrays 需要导入 java.util.Arrays包，是一个对数组操作的工具类<br>两个常用方法:</p><ul><li>public static String toString(数组)将参数数组变成字符串</li><li>public static void sort(数组)按照默认升序对数组的元素排序</li></ul><p>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] intArr = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">intStr</span> <span class="hljs-operator">=</span> Arrays.toString(intArr);<br>        System.out.println(intStr);<br><br>        <span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>&#125;;<br>        Arrays.sort(arr1);<br>        System.out.println(Arrays.toString(arr1));<br><br>        String[] arr2 = &#123;<span class="hljs-string">&quot;ddd&quot;</span>,<span class="hljs-string">&quot;ccc&quot;</span>,<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-string">&quot;bbb&quot;</span>&#125;;<br>        Arrays.sort(arr2);<br>        System.out.println(Arrays.toString(arr2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>目前还不理解是什么，先记录下来</p><ul><li>首次用到本类时，静态代码块执行唯一一次</li><li>静态代码块典型用途：用来一次性对静态成员变量进行赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块执行！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">person</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;普通代码执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h2><p>用起来很简单，直接调用就可以了</p><ul><li>public static double abs(double num); 获取绝对值</li><li>public static double ceil(double num); 向上取整</li><li>public static double floor(double num); 向下取整</li><li>public static double long round(double num); 四舍五入</li></ul><p>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Math.abs(<span class="hljs-number">3.14</span>));<br>System.out.println(Math.ceil(<span class="hljs-number">3.9</span>));<br>System.out.println(Math.floor(<span class="hljs-number">3.2</span>));<br>System.out.println(Math.round(<span class="hljs-number">4.4</span>));<br><br>System.out.println(Math.PI); <span class="hljs-comment">// 常数圆周率 π</span><br></code></pre></td></tr></table></figure><h2 id="父类、子类中变量重名"><a href="#父类、子类中变量重名" class="headerlink" title="父类、子类中变量重名"></a>父类、子类中变量重名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dad</span> &#123; <span class="hljs-comment">// 父类</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dad</span> &#123; <span class="hljs-comment">//子类，继承了父类</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        System.out.println(num);<br>        System.out.println(<span class="hljs-built_in">this</span>.num);<br>        System.out.println(<span class="hljs-built_in">super</span>.num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">30<br>20<br>10<br></code></pre></td></tr></table></figure><p>不难理解，第一个num是局部变量，第二个num是本类的成员变量，第三个num是用super关键字继承父类的<br>super关键字就跟Python里的差不多，把父类的东西拿过来给自己用</p><p>继承关系中:</p><ol><li>子类构造方法中默认含”super()”调用，所有先调用父类的构造方法，再子类构造方法</li><li>子类构造可以通过super关键字来调用父类的重载构造方法</li><li>super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</li></ol><p>子类必须调用父类构造方法，不写则赠送super(),写了则用指定的super调用，super只能有一个，而且必须是第一个</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>类中有抽象方法，则这个类一定是抽象类，反之不一定<br>在抽象类中可以定义抽象方法，而这些方法必须在子类中实现<br>定义方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func3</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//抽象类里既可以定义抽象方法，也可以定义普通方法</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Override 表示重载方法，写不写都可以，但这是一个标识符，能加上最好</p><hr><p>今天又学了新东西，没白忙活，还看了几篇博客，学了点新姿势，下次找机会玩一玩 :D</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WiFi破解</title>
    <link href="/2022/05/04/WiFi%E7%A0%B4%E8%A7%A3/"/>
    <url>/2022/05/04/WiFi%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="记录第一次成功破解WiFi密码"><a href="#记录第一次成功破解WiFi密码" class="headerlink" title="记录第一次成功破解WiFi密码"></a>记录第一次成功破解WiFi密码</h1><p>网上买的无线网卡到了，赶紧插上电脑开始使用，看了好几篇大佬的博客，总算是把已经知道的办公室的WiFi密码给破解出来了<br>忙碌了一个多小时，看来没白忙活</p><span id="more"></span><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>Aircrack-ng是一个包含一个多款工具的套装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S aircrack-ng<br></code></pre></td></tr></table></figure><p>准备一个外置的无线网卡</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先看看有没有连上无线网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsusb<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-4-2.png" alt="可以看到我的网卡是连接上了的"></p><p>查看网卡是否启用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-4-3.png" alt="网卡已启用，而且没有连上任何网络"></p><p>查看网卡状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iwconfig<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-4-4.png" alt="网卡的模式处于Managed"></p><p>启动网卡至 Monitor 模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo airmon-ng start wlp3s0f3u4 #启动网卡为 Monitor 模式<br>sudo airmon-ng stop wlp3s0f3u4 #恢复网卡为正常模式<br></code></pre></td></tr></table></figure><p>然后就能看到网卡处于 Monitor 模式了<br><img src="/img/2022-5-4-5.png" alt="可以看到网卡名字后面多了mon"></p><h2 id="搜集信息"><a href="#搜集信息" class="headerlink" title="搜集信息"></a>搜集信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo airodump-ng wlp3s0f3u4mon<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-4-6.png" alt="可以看到许多WiFi信息"><br>记录下需要破解的 WiFi 信息，按两下 q 退出</p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>使用 airodump-ng 抓握手包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo airodump-ng --ivs --bssid 24:CF:24:58:FF:DA -w test -c 1 wlp3s0f3u4mon<br><br>--ivs     #只抓取可用于破解的IVS数据报文<br>--bssid   #路由器的 Mac 地址<br>-w        #写入到文件中<br>-c        #CH，频道<br></code></pre></td></tr></table></figure><p>保存的文件并不是叫 test ，而是叫 test-01.ivs</p><p><img src="/img/2022-5-4-7.png" alt="可以看到有一个设备接入了这个路由器，就是我的手机"><br>保存好需要的信息，这个终端不要关闭，这是留着抓握手包的</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>开一个新的终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo aireplay-ng -0 1 -a 24:CF:24:58:FF:DA -c 26:12:15:11:89:54 wlp3s0f3u4mon<br>-0   #采用 deauth 攻击模式，后面跟上攻击次数<br>-a   #路由器的mac地址<br>-c   #客户端的mac地址<br></code></pre></td></tr></table></figure><p><img src="/img/2022-5-4-8.png" alt="输入后，客户端的WiFi就会断开，然后重新连接路由器"></p><p>然后在抓包的那个终端，就可能抓到握手包<br><img src="/img/2022-5-4-9.png" alt="成功抓到握手包"></p><h2 id="密码爆破"><a href="#密码爆破" class="headerlink" title="密码爆破"></a>密码爆破</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aircrack-ng -w key.txt test-01.ivs<br></code></pre></td></tr></table></figure><p>为了能快速成功爆破，我把真正的 WiFi 密码放入了字典中<br><img src="/img/2022-5-4-1.png" alt="破解密码成功"><br>中间 KEY FOUND! 的后面中括号里的就是 WiFi 密码</p><hr><p>去年就看到身边的大佬给我展示 WiFi 破解，当时就很震撼，这不比那些假的 WiFi 破解强多了？然后就忘了这个事了<br>几天前看别的大佬博客的时候，又看到了这个方法破解 WiFi 密码，我就想自己尝试一次<br>两天前买的无线网卡，今天就到了，快递的速度还是很快的，于是就赶紧开始了实验<br>实验结果很满意，因为成功了嘛 (o^∇^o)ﾉ </p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WiFi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2022/05/03/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/03/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="每天学一点，久了就能学会很多"><a href="#每天学一点，久了就能学会很多" class="headerlink" title="每天学一点，久了就能学会很多"></a>每天学一点，久了就能学会很多</h1><p>量变 –&gt; 质变</p><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p>一旦用了 static 关键字，那么这样的内容就不再属于对象自己，而是属于类的<br>凡是本类的对象，都共享同一份</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idCounter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = ++idCounter;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.id = ++idCounter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，可以定义一个用 static 关键字修饰的成员变量 idCounter ，再定义一个普通的用 private 修饰的成员变量 id ，就可以实现每创建一个对象，都可以自动获取 id 号，而且是可以自增的<br>这就是利用了 static 这个关键字<br>idCounter 这个变量属于这个类，在内存中只存储一次，所有对象的这个变量的值都是这个</p><p>static 关键字不但可以修饰成员变量，还可以修饰成员方法<br>一旦使用static修饰成员方法，那么这个方法就成为了静态方法，静态方法不属于对象，是属于类的<br>概念和修饰成员变量差不多</p><p>static 关键字修饰的成员方法可以不创建对象就使用里面的方法，如果没有static关键字，那么必须先创建对象，再通过对象使用它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是成员方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodStatic</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是静态方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;自己的方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>无论是成员变量还是成员方法，如果使用了static，都推荐使用类名称调用</li><li>静态方法可以访问静态变量，但不能直接访问非静态变量，反过来可以</li><li>静态方法不能使用this</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">methodStatic</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        obj.method();<br><br>        obj.methodStatic();<span class="hljs-comment">//正确，但不推荐</span><br>        MyClass.methodStatic(); <span class="hljs-comment">//推荐用法，直接使用类名称.静态方法</span><br><br>        myMethod();<br>        methodStatic.myMethod(); <span class="hljs-comment">//等价于上面的</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;my method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>indexOf 获取字符串第一次出现的位置，如果没有则返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> original.indexOf(<span class="hljs-string">&quot;llo&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;索引结果是&quot;</span> + index);<br></code></pre></td></tr></table></figure><p>charAt 获取特定位置的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>.charAt(<span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;一号位的字符是&quot;</span> + ch);<br></code></pre></td></tr></table></figure><h3 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h3><p>和 Python 的 split 方法差不多，通过特定的字符将字符串分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello,world,!&quot;</span>;<br>String[] arr1 = str.split(<span class="hljs-string">&quot;,&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>不能使用 ‘.’ 来切割，若要使用，需要使用 ‘\.’，因为这个是正则表达式的一个符号</li></ul><h3 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat 方法"></a>concat 方法</h3><p>用以连接字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> str1.concat(str2);<br></code></pre></td></tr></table></figure><h3 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h3><p>replace 方法用来替换字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">lang1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fuck you!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">lang2</span> <span class="hljs-operator">=</span> lang1.replace(<span class="hljs-string">&quot;uc&quot;</span>, <span class="hljs-string">&quot;**&quot;</span>);<br>System.out.println(lang1);<br>System.out.println(lang2);<br></code></pre></td></tr></table></figure><p>toCharArray 方法，字符串转换为字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] chars = <span class="hljs-string">&quot;Hello&quot;</span>.toCharArray();<br>System.out.println(chars[<span class="hljs-number">0</span>]);<br>System.out.println(chars.length);<br></code></pre></td></tr></table></figure><p>getBytes 方法，字符串转换为字节数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;abc&quot;</span>.getBytes(); <span class="hljs-comment">//转换为字节数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bytes.length; i++) &#123;<br>    System.out.println(bytes[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串截取方法"><a href="#字符串截取方法" class="headerlink" title="字符串截取方法"></a>字符串截取方法</h3><ul><li>substring(int index):截取从参数位置一直到字符串末尾，返回新字符串</li><li>substring(int begin, int end):截取从begin开始到end结束中间的字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str1.substring(<span class="hljs-number">5</span>);<br>System.out.println(str1);<br>System.out.println(str2);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> str1.substring(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>);<br>System.out.println(str3);<br></code></pre></td></tr></table></figure><h2 id="对比字符串是否相等"><a href="#对比字符串是否相等" class="headerlink" title="对比字符串是否相等"></a>对比字符串是否相等</h2><ul><li>equals(Object obj) 只有参数是一个字符串，且内容相同的才会返回true，否则返回false</li><li>equalsIgnoreCase(Object obj) 忽略大小写<br>语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">str1.equals(str2);<br>strA.equalsIgnoreCase(strB);<br></code></pre></td></tr></table></figure><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>对于ArrayList来说，有一个尖括号<E>代表泛型<br>泛型：装在集合当中的所有元素，全都是统一的类型<br>泛型只能是引用类型，不能是基本类型<br>对于ArrayList集合，直接打印的不是地址值，而是内容</p><p>用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建ArrayList集合，集合名称list，里面装的都是String类型的数据</span><br><span class="hljs-comment">// jdk1.7开始，右边的尖括号可以不写内容</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> list.add(<span class="hljs-string">&quot;piapiapia~&quot;</span>); <span class="hljs-comment">//添加元素</span><br>System.out.println(<span class="hljs-string">&quot;返回结果是&quot;</span> + success);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">2</span>); <span class="hljs-comment">//获取元素</span><br>System.out.println(<span class="hljs-string">&quot;索引为2的是&quot;</span> + word);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">move</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">2</span>); <span class="hljs-comment">//删除元素</span><br>System.out.println(<span class="hljs-string">&quot;被删掉的是&quot;</span> + move);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size(); <span class="hljs-comment">//获取长度</span><br>System.out.println(<span class="hljs-string">&quot;集合长度是&quot;</span> + size);<br></code></pre></td></tr></table></figure><p>若需要用基本类型，则需要使用基本类型的包装类</p><ul><li>jdk1.5开始支持自动装箱、拆箱</li><li>自动装箱，基本类型 –&gt; 包装类型</li><li>自动拆箱，包装类型 –&gt; 基本类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; listA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//创建int集合</span><br>ArrayList&lt;Character&gt; listA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//创建char集合</span><br></code></pre></td></tr></table></figure><p>其他的类型就是开头字母大写，除了以上两个</p><hr><p>勤能补拙，学好了Java就可以开始学习Android开发了，然后就能申请项目赚钱拿奖了，芜湖</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2022/05/02/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/02/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="学了些-Java-，做个笔记"><a href="#学了些-Java-，做个笔记" class="headerlink" title="学了些 Java ，做个笔记"></a>学了些 Java ，做个笔记</h1><p>又学了点Java，记个笔记，免得以后忘了</p><span id="more"></span><h2 id="Scanner-从键盘输入数据"><a href="#Scanner-从键盘输入数据" class="headerlink" title="Scanner 从键盘输入数据"></a>Scanner 从键盘输入数据</h2><p>可以从键盘输入的方法 Scanner，没想到这时候那个老师才讲到，是他教的方式与众不同，还是我学太慢了？<br>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        System.out.println(<span class="hljs-string">&quot;输入的int数字是:&quot;</span> + num);<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">bot</span> <span class="hljs-operator">=</span> sc.nextDouble();<br>        System.out.println(<span class="hljs-string">&quot;输入的double数字是：&quot;</span> + bot);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.next();<br>        System.out.println(<span class="hljs-string">&quot;输入的字符串是:&quot;</span> + str);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>先导包，把 Scanner 包导入</li><li>先实例化一个 Scanner 对象，System.in 表示从键盘输入</li><li>在接受数据时，数字数据是 next+类型这个方法，而字符串是直接用next，因为 Scanner 在接受键盘输入的时候接受的都是字符串，只不过是将数字强制转换了</li></ul><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>先定义一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String str)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = str;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我是这么理解匿名类的，在实例化对象的时候，如果这个类只需要用一次里面的方法，那么就没必要将它先实例化再调用方法，可以一步到位<br>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;WJK!&quot;</span>).show();<br>    &#125;<br></code></pre></td></tr></table></figure><p>直接把熟悉传入后调用方法，使用完了就会被编译器回收内存，节省了内存的使用，也提升了代码整洁度</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>就是随机生成数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> ran.nextInt();<br>        System.out.println(<span class="hljs-string">&quot;随机数是:&quot;</span> + num);<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用方法和 Scanner 差不多，先导包，然后实例化对象，就可以调用方法了，在生成随机数的时候用的yes next+类型的方法<br>nextInt() 方法可以带参数bound，表示[0, bound) 左闭右开的区间里去随机数，否则是在整个 int 里随机选择数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ran.nextInt(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ul><li>随机生成 [0, 9) 里的数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ran.nextInt(<span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ul><li>随机生成 [1, 10] 里的数字</li></ul><hr><p>虽然今天没学到多少，但还是辛苦自己了o(￣ε￣<em>)<br>好好学 Java ，学好后做 Android 开发，再学 kotlin ，然后 Android 逆向，走向头秃的人生巅峰n(</em>≧▽≦*)n</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manjaro无法调节声音</title>
    <link href="/2022/04/29/manjaro%E6%97%A0%E6%B3%95%E8%B0%83%E8%8A%82%E5%A3%B0%E9%9F%B3/"/>
    <url>/2022/04/29/manjaro%E6%97%A0%E6%B3%95%E8%B0%83%E8%8A%82%E5%A3%B0%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="电脑突然无法调节声音了"><a href="#电脑突然无法调节声音了" class="headerlink" title="电脑突然无法调节声音了"></a>电脑突然无法调节声音了</h1><p>我把 manjaro 当成主系统也有五个月了，用起来还是很流畅的，没有碰到什么大问题<br>除了由于电脑的网卡用的是 MT7921 导致连不上 WiFi 的问题，但这个问题自从换了 AX210 网卡后就解决了，WiFi6 用起来很舒畅<br>但前几天突然碰到一个从未碰到过的问题：电脑没有声音了，准确来讲是系统没有识别扬声器设备<br><img src="/img/2022-4-30-1.png" alt="不管怎么调节都是这个状态"><br>遇到这种办法能咋办，只能靠 Google 了</p><span id="more"></span><h2 id="找到的方法千奇百怪"><a href="#找到的方法千奇百怪" class="headerlink" title="找到的方法千奇百怪"></a>找到的方法千奇百怪</h2><p>有重新安装驱动的，但我的扬声器并不是一直没用，是突然没有的<br>有用工具连接的，试了但没用</p><p>查来查去也没有什么进展，不过到是学到了 kde 是用 pulseaudio 来控制声音的，我每次开机使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pulseaudio --start<br></code></pre></td></tr></table></figure><p>扬声器设备就会被识别到了<br>还学到了可以通过工具 alsamixer 来调节声音，感觉挺厉害的，可以通过命令行来调节声音<br><img src="/img/2022-4-30-2.png" alt="看上去就很有感觉"></p><h1 id="同学的电脑被-ssh-连接的时候发现根目录被改了"><a href="#同学的电脑被-ssh-连接的时候发现根目录被改了" class="headerlink" title="同学的电脑被 ssh 连接的时候发现根目录被改了"></a>同学的电脑被 ssh 连接的时候发现根目录被改了</h1><p>我一个同学的电脑是 Debian ，他昨天碰到了一个问题，就是 ssh 上他的电脑后，进入的目录是 &#x2F;root 目录，也就是管理员目录，但他却不是以 root 身份连接上的<br>使用 pwd 查看所在位置就是在 &#x2F;root 下，但 ls 是没有权限的，可是为什么普通用户可以进入 &#x2F;root 目录呢？<br>这就很恐怖了，都认为他的电脑中病毒了，而且还是一个新型病毒，以为利用了 Debian 的 0day 漏洞<br>经过一系列验证，发现可能不是病毒引起的<br>他的 &#x2F;etc&#x2F;environment 文件被修改了，很神奇的是和我的这个文件一对比居然一模一样<br>但把这个文件删掉后，他的问题解决了，回过头来，我发现了事情的不对</p><h1 id="声音无法调节的问题解决"><a href="#声音无法调节的问题解决" class="headerlink" title="声音无法调节的问题解决"></a>声音无法调节的问题解决</h1><p>查看了 &#x2F;etc&#x2F;environment</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/environment<br></code></pre></td></tr></table></figure><p>找到了原因，里面的内容被某个脚本改写了，我也删掉了这个文件试了试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> /etc/environment<br></code></pre></td></tr></table></figure><p>重启，扬声器设备被系统正确识别了<br>帮别人找问题阴差阳错的解决了自己几天前的问题(°ー°〃)</p><hr><p>后来我们一起回忆了一下最近有没有用管理员权限运行了一些自己不信任的脚本<br>原来我们都从 github 上找过一个自动刷课的脚本，拿虚拟机做了实验后，问题复现了<br>然后我们对视一笑，原来你也想这么弄，但没成功啊(ﾉ*･ω･)ﾉ</p><p>以后注意不要乱用自己不确定是否安全的脚本，尤其是要用管理员权限的时候，更何况还是学安全的人呢</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2022/04/28/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/28/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="最近开始学习Java了，想学学安卓开发"><a href="#最近开始学习Java了，想学学安卓开发" class="headerlink" title="最近开始学习Java了，想学学安卓开发"></a>最近开始学习Java了，想学学安卓开发</h1><p>突然想学安卓逆向，但对安卓还是不是特别了解，即使每天拿的手机都是安卓系统的，但我居然对自己的手机的结构一点都不了解，这还怎么学安卓逆向啊，于是就开始学习Java了<br>我还是有点 C 语言和 Python 的基础，脑子里对面向对象编程是有一些映像的，慢慢来吧</p><span id="more"></span><h1 id="private-关键字的-Getter-Setter-方法"><a href="#private-关键字的-Getter-Setter-方法" class="headerlink" title="private 关键字的 Getter&#x2F;Setter 方法"></a>private 关键字的 Getter&#x2F;Setter 方法</h1><p>在定义类的成员变量的时候可以在定义的语句前加上 private 关键字，这样在实例化类的时候就不能直接对这个成员变量进行修改<br>这样的好处就是可以利用 Getter&#x2F;Setter 方法对这个类成员变量的值规范起来<br>example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> ok;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span> <span class="hljs-params">(String str)</span>&#123;<br>        name = str;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span> <span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        age = num;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOk</span> <span class="hljs-params">(<span class="hljs-type">boolean</span> yes)</span>&#123;<br>        ok = yes;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">isOk</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ok;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在定义普通的常量的时候，都是使用 set + 首字母大写的成员变量 和 get + 首字母大写的成员变量，来设置成员变量和获取成员变量</li><li>除了获取布尔值，它是用 is + 首字母大写的成员变量，来获取成员变量</li></ul><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> 类名称(参数类型 参数名称)&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>和 Python 里的初始化方法 <strong>init</strong> 一样，就是在实例化对象的会自动执行的代码<br>不过 Java 里的这个方法是一定会有的，如果没有自己定义，则编译器会赠送一个初始化给程序，也就是白嫖编译器一个初始化方法<br>example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">student</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;默认无参构造方法执行了!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        System.out.println(<span class="hljs-string">&quot;全参构造方法执行了!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造方法不能返回</li><li>1, 2处都定义了构造方法，只是参数不同，也就是说构造方法是可以重载的</li></ul><h1 id="标准类-Java-Bean"><a href="#标准类-Java-Bean" class="headerlink" title="标准类 Java Bean"></a>标准类 Java Bean</h1><ol><li>所有的成员变量都要使用 private 关键字修饰</li><li>为每一个成员变量编写一对 Getter&#x2F;Setter 方法</li><li>编写一个无参数的构造方法</li><li>编写一个全参数的构造方法</li></ol><p>IDEA 快速生成构造方法和 Getter&#x2F;Setter 快捷方式<br>Alt + Insert (Code -&gt; Generate)</p><hr><p>刚开是学 Java 的时候那叫一个快啊，两倍速都嫌慢，然后看到这个位置，速度慢慢降下来了，从2倍速到1.5倍速，到现在的1.25倍速，也算是正式开始入门 Java 了吧<br>当你遇到困难的时候，就是你成长的时候</p>]]></content>
    
    
    <categories>
      
      <category>Java笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql突然无法启动</title>
    <link href="/2022/04/27/mysql%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
    <url>/2022/04/27/mysql%E7%AA%81%E7%84%B6%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="今天上网课的时候学到了-mysql-的新东西，想试一下，打开-mysql-发现无法启动"><a href="#今天上网课的时候学到了-mysql-的新东西，想试一下，打开-mysql-发现无法启动" class="headerlink" title="今天上网课的时候学到了 mysql 的新东西，想试一下，打开 mysql 发现无法启动"></a>今天上网课的时候学到了 mysql 的新东西，想试一下，打开 mysql 发现无法启动</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Job for mysqld.service failed because the control process exited with error code.<br>See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xeu mysqld.service&quot; for details.<br></code></pre></td></tr></table></figure><span id="more"></span><p>直接报了这个错误，搜了10多分钟，什么权限啊、所有者啊，都没用<br>然后气得我直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -Rss mysql<br></code></pre></td></tr></table></figure><p>把 mysql 给卸了<br>然后重装了个 Mariadb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S mariadb<br></code></pre></td></tr></table></figure><p>成功从 mysql 转化为了 mariadb</p><hr><h2 id="重新初始化一次"><a href="#重新初始化一次" class="headerlink" title="重新初始化一次"></a>重新初始化一次</h2><p>初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql<br></code></pre></td></tr></table></figure><p>成为 root 用户之后设置 mariadb 密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql_secure_installation<br></code></pre></td></tr></table></figure><p>完成 (*•̀ㅂ•́)و</p><hr><p>本来好好的看着今天 nisp 的网课，想着看完今天的份额后继续去B站学java的<br>不过这 nisp 的课质量怎么说呢，参差不齐，能学到一点是一点吧<br>不过B站那位老师java讲的还蛮好的</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Termux玩法</title>
    <link href="/2022/04/26/Termux%E7%8E%A9%E6%B3%95/"/>
    <url>/2022/04/26/Termux%E7%8E%A9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="玩了玩-termux-api，蛮有意思的，记录一下"><a href="#玩了玩-termux-api，蛮有意思的，记录一下" class="headerlink" title="玩了玩 termux-api，蛮有意思的，记录一下"></a>玩了玩 termux-api，蛮有意思的，记录一下</h1><p>先在 F-Droid 上安装好 Termux 和 Termux:API<br><img src="/img/2022-4-26-1.jpeg"> <img src="/img/2022-4-26-2.jpeg"><br>在手机里设置 Termux 和 Termux的权限，不同手机的不一样，看着给权限，以为后面使用命令的时候如果没有权限就无法使用了</p><span id="more"></span><p>打开 Termux 输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pkg install termux-api<br></code></pre></td></tr></table></figure><p>安装 Termux-api<br>这样就可以让 Termux 调用 Termux:api 的接口了</p><p>这时候就可以测试是不是可以使用了，使用以下命令可以打开手机的手电筒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">termux-torch on<br></code></pre></td></tr></table></figure><p>关闭手电筒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">termux-torch off<br></code></pre></td></tr></table></figure><p>本来已经可以快乐地玩耍了，但我想着用电脑通过 ssh 连接到手机的 Termux，把手机给别人玩的时候可以恶作剧一下 O(∩_∩)O哈哈~<br>Termux 输入一下命令安装 openssh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pkg install openssh<br></code></pre></td></tr></table></figure><ul><li>注意：Termux 上 openssh 的端口是8022，不是22，在 ssh 连接的时候要指定端口</li></ul><p>查看本机的用户名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whoami<br></code></pre></td></tr></table></figure><p>查看手机 IP 地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd<br></code></pre></td></tr></table></figure><p>这样电脑就可以 ssh 上自己的手机做一些有意思的事情了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -p 8022 &lt;name&gt;@&lt;IP&gt;<br></code></pre></td></tr></table></figure><h1 id="我这里放几个有意思的命令"><a href="#我这里放几个有意思的命令" class="headerlink" title="我这里放几个有意思的命令"></a>我这里放几个有意思的命令</h1><p>拍照</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">termux-camera-info<br>termux-camera-photo [-c camera-id] &lt;output-file&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">eg: termux-camera-photo -c 0 WJK.jpg</span><br></code></pre></td></tr></table></figure><ul><li>第一条命令查看一下手机的相机信息</li><li>第二条命令用相机的 ID 来调用相机拍照</li></ul><p>获取通讯录信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">termux-contact-list<br></code></pre></td></tr></table></figure><p>拨打电话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">termux-telephony-call [number]<br></code></pre></td></tr></table></figure><p>手机震动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">termux-vibrate [-d duration] [-f]<br></code></pre></td></tr></table></figure><ul><li>-d: 持续时间单位毫秒，默认1000</li><li>-f: 强制震动 o(<em>&#x2F;&#x2F;&#x2F;&#x2F;▽&#x2F;&#x2F;&#x2F;&#x2F;</em>)q</li></ul><p>调用系统下载器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">termux-download [-d 描述] [-t 标题] url<br></code></pre></td></tr></table></figure><hr><p>了解新东西就很开心，当学会了使用时就更开心了O(∩_∩)O<br>这个软件学会了以后我脑子里突然多了很多有意思的想法，等我去写个代码实现一波(≧∇≦)ﾉ</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Termux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无法进入manjaro系统</title>
    <link href="/2022/04/24/%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5manjaro%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/04/24/%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5manjaro%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="今天踩了个坑，差点重装系统，记录一下"><a href="#今天踩了个坑，差点重装系统，记录一下" class="headerlink" title="今天踩了个坑，差点重装系统，记录一下"></a>今天踩了个坑，差点重装系统，记录一下</h2><p>今天早上我的 manjaro 出了一点问题，我以为是驱动问题，然后就用了命令 mhwd 装了驱动，然后重启了一下电脑，于是，我的电脑就启动不了了</p><span id="more"></span><p>它一直卡在 &#x2F;dev&#x2F;sdb1… blocks</p><p>经过各种查找，我发现就是因为我装了那两个驱动，导致我无法进入电脑</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">0000:03:00.0 (0300:1002:1638) Display controller ATI Technologies Inc:<br>--------------------------------------------------------------------------------<br>                  NAME               VERSION          FREEDRIVER           TYPE<br>--------------------------------------------------------------------------------<br>           video-linux            2018.05.04                true            PCI<br>     video-modesetting            2020.01.13                true            PCI<br>            video-vesa            2017.03.12                true            PCI<br></code></pre></td></tr></table></figure><p>解决的方法也很简单，在卡在的这个界面按 Ctrl + Alt + F6 进入 tty 登录<br>然后用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mhwd --remove pci video-modesetting<br>sudo mhwd --remove pci video-vesa <br></code></pre></td></tr></table></figure><p>把安装的这两个驱动删掉，重启<br>然后就回来了</p><hr><p>吓死我了还以为要重装系统，我都想好今天下午重新装一个 ArchLinux 了，但我的各种东西可能就没了，还好回来了<br>&#x2F;(ㄒoㄒ)&#x2F;~~</p>]]></content>
    
    
    <categories>
      
      <category>踩坑记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx搭建博客</title>
    <link href="/2022/04/22/Nginx%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/04/22/Nginx%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>在搭建这个博客的几天前，刚在 vultr 上买了个 VPS 用 nginx 和 Typecho 搭了个博客，和这个博客对比一下还是 hexo 好用一点。既然都用 nginx 搭过博客了，刚好记录一下 nginx 的使用方法</p><span id="more"></span><p>我当时是在 ArchLinux 上面搭建的博客，所以是用 pacman 安装需要的软件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S nginx php-fpm mysql<br></code></pre></td></tr></table></figure><p>启动 php-fpm, nginx, mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start nginx php-fpm mysqld<br></code></pre></td></tr></table></figure><p>nginx 安装好后就能用，浏览器访问博客地址<br><img src="/img/2022-4-21-1.png"></p><p>编辑配置文件 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf<br>nginx 原理我目前理解的是一个“看大门的”，它把每一个请求进行审查，然后根据配置文件进行匹配，匹配到了就把这个请求交个那个模块的特定程序进行处理。</p><p>找到 http 部分，listen 就是要监听的端口；server_name 是服务名称，可以改为自己的 IP 地址和域名；error_page 我在当时搭建的时候没有改，但看名字应该就是配置错误的页面了，它下面的 location 就是那个页面的位置。<br>location &#x2F;{} 里的 root 是网页的根目录，index 是网页需要识别的 index 文件，把 index.php 加进去</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">location / &#123;<br>            root   网站根目录;<br>            index  index.html index.htm index.php;<br>            &#125;<br></code></pre></td></tr></table></figure><p>找到下面配置 PHP 的地方，把 FastCGI server 部分的注释取消掉，因为我用的是 php-fpm 来搭建的，不是用 Apache<br>php-fpm 我的理解是一个连接 PHP 和 nginx 的桥梁，php-fpm 做个中转，把 nginx 传过来的数据交给 PHP 来处理</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">location ~ \.php$ &#123;<br>            root           自己博客的根目录的位置，可以和 location / 里的 root 一样;<br>            fastcgi_pass   unix:/run/php-fpm/php-fpm.sock;   #这里先查看一下 php-fpm 的进程，然后把它给复制到这里来，这就是上面讲的把 nginx 传过来的数据进行处理<br>            fastcgi_index  index.php;   #网站的 index<br>            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;   #告诉 nginx 到哪去解析 PHP<br>            include        fastcgi_params;<br>            &#125;<br></code></pre></td></tr></table></figure><p>mysql 在安装后会提示要初始化 mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql<br></code></pre></td></tr></table></figure><p>然后设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql_secure_installation<br></code></pre></td></tr></table></figure><p>进入 mysql 后可以创建一个新用户，当时觉得直接用 root 来使用数据库不安全(虽然没啥人会想攻击我的博客…)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;[localhost|%]&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;password&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>localhost:仅限本地登录</li><li>%:可以通过网络登录</li></ul><p>给这个用户管理员权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;password&#x27;</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> option;<br></code></pre></td></tr></table></figure><p>然后就差不多完成了，到 Typecho 官网去下载 Typecho 的压缩包<br><a href="http://typecho.org/download">http://typecho.org/download</a></p><p>把压缩包解压缩到博客的目录下<br>浏览器打开自己博客的 IP 地址，根据设置好的配置填写，按照提示进行就行了<br>还有就是设置博客的文件夹权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 777 folder<br></code></pre></td></tr></table></figure><p>这样设置好后还会碰到一个情况，就是不管进入什么页面都是 404，这要在配置文件里修改一下 PHP-fpm 的 location，改为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">location ~ .*\.php$<br></code></pre></td></tr></table></figure><hr><p>就这么简单易懂的过程，我当时愣是搞了一天，这里查查，那里看看，我还记得那天早上我看配置方法的时候还不屑的想：这么简单的配置，比上次调 v2ray 的简单多了，然后调了一整天，调到头昏，当时就不该小瞧它 &#x2F;(ㄒoㄒ)&#x2F;~~<br>最后还是成功搭建好了，不过第二天就把那个 VPS 删了，原因是访问太慢了，而且财库还紧张。</p>]]></content>
    
    
    <categories>
      
      <category>姿势学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World!</title>
    <link href="/2022/04/22/hello-world/"/>
    <url>/2022/04/22/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="博客搭建成功！"><a href="#博客搭建成功！" class="headerlink" title="博客搭建成功！"></a>博客搭建成功！</h1><p>兜兜转转搭建了好几个博客，没太多钱买好的VPS搭博客，网站的访问速度很慢，所以搭的博客网站没用几天就删掉不写了。刚发现 hexo 这个框架蛮好用的，然后又用 github 搭了一个博客网站。效果意外的好，总算是把自己的博客搭好了，以后就没事来写写博客，记录生活，记录学习。</p><p>hexo 还是蛮好用的，体验了一天，学了一些使用方法，很舒适。支持 Markdown 语法，写起文章来和写笔记没什么区别，简单实用。</p><p>以后要坚持写博客的习惯，记录下自己的学习，万一以后有什么忘记了，看看自己的博客还更方便，不用到处搜索浪费时间。O(∩_∩)O哈哈~</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
